# 0227 ~ 0305

## 0227 - Filter를 통한 Logging
### 

<br>

## 0302 - 템플릿 메소드 패턴 (Template Method Pattern)
> 알고리즘의 일부 단계를 서브클래스에서 정의한다.

### 의도
#### **[ 의도 ]**
- GoF는 다음과 같이 이패턴의 의도를 설명한다.
> 객체의 연산에는 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미룹니다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계 처리를 서브클래스에서 재정의할 수 있게합니다.

- 실용주의 디자인 패턴에서는 이 패턴이 상속 기반의 프레임워크에서 사용된다고 설명한다.
> Template Method는 보통 상속 기반의 프레임워크에서 사용된다. 프레임워크는 작업의 90% 정도를 기반 클래스를 통해 제공하며, 애플리케이션에 용도에 맞게 맞춤화할 필요가 있는 부분은 추상 메소드로 남겨놓는다. 이 말은 곧 기반 클래스가 추상 템플릿 메소드를 호출한다는 의미이다. 사용자는 클래스를 상속하고 추상 메소드를 필요에 맞게 구현함으로써 프레임워크를 사용하게 된다.

- 패턴을 활용한 리팩터링에서는 다음과 같이 설명한다.
> 템플릿 메서드는 '알고리즘에서 불변적인 부분은 한 번만 구현하고 가변적인 동작은 서브클래스에서 구현할 수 있도록 남겨둔 것'을 말한다. 서브클래스에 불변적인 부분과 가변적인 부분이 뒤섞여 있다면, 불변적인 부분이 여러 서브클래스에서 중복될 것이다. 이런 코드를 Template Method 패턴으로 리팩터링하면, 불변적인 부분에 대한 구현은 한 곳에만, 즉 수퍼클래스 메서드 내의 일반화된 알고리즘에만 존재하게 되므로 코드 중복이 사라진다.
> 
> 템플릿 메서드의 불변적 동작은 다음을 포함한다.  
> 
> - 알고리즘을 구성하는 메서드 목록과 그 호출 순서
> - 서브클래스가 꼭 오버라이드해야 할 추상 메서드
> - 서브클래스가 오버라이드해도 되는 훅 메서드 hook method, 즉 구체 메서드

#### **[ 용어 ]**
- 템플릿 메소드
	- 필수 처리 절차를 정의한 메소드
	- 서브클래스가 오버라이드하는 추상 메소드들을 사용하여 알고리즘을 정의하는 메소드
- 훅 연산(hook operation)
	- 필요하다면 서브클래스에서 확장할 수 있는 기본적인 행동을 제공하는 연산(메소드)
	- 기본적으로는 아무 내용도 정의하지 않는다

#### **[ 구현 팁 ]**
- 템플릿 메소드가 호출하는 메소드들을 템플릿 메소드만 호ㅜㄹ할 수 있게 하는 것을 고려한다.
	- `protected` 접근 제한을 사용하면 된다
- 템플릿 메소드는 오버라이드할 수 없도록 구현하는 것을 고려한다.
	- Java라면 템플릿 메소드에 final을 달아주면 된다.
- 구현해야 하는 abstract 메소드의 수가 너무 많아지니 않도록 주의한다.
- 재정의할 abstract 메소드는 식별하기 쉽도록 접두사를 붙여주자
	- 예를 들어 메소드 이름이 `Do`로 시작하도록 한다.

### 헤드 퍼스트 디자인 패턴의 예제
```java
public class Coffee {
    // 커피 만드는 방법
    void prepareRecipe() {
        boilWater();
        brewCoffeeGrinds();
        pourInCup();
        addSugarAndMilk();
    }
    public void boilWater() {
        System.out.println("물 끓이는 중");
    }
    public void brewCoffeeGrinds() {
        System.out.println("필터를 통해서 커피를 우려내는 중");
    }
    public void pourInCup() {
        System.out.println("컵에 따르는 중");
    }
    public void addSugarAndMilk() {
        System.out.println("설탕과 우유를 추가하는 중");
    }
}
```

```java
public class Tea {
    // 홍차 만드는 방법
    void prepareRecipe() {
        boilWater();
        steepTeaBag();
        pourInCup();
        addLemon();
    }
    public void boilWater() {
        System.out.println("물 끓이는 중");
    }
    public void steepTeaBag() {
        System.out.println("차를 우려내는 중");
    }
    public void pourInCup() {
        System.out.println("컵에 따르는 중");
    }
    public void addLemon() {
        System.out.println("레몬을 추가하는 중");
    }
}
```
템플릿 메소드 패턴은 위의 두 클래스를 다음과 같이 리팩토링한다.
- 공통ㅇ적인 부분을 뽑아 추상 클래스를 만든다.
    - 알고리즘의 세부 항목에서 차이가 있는 곳은 추상 메소드로 정의한다.

```java
public abstract class CaffeineBeverage {
    // 알고리즘을 갖고 있는 이 메소드를 '템플릿 메소드'라 부른다
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    abstract void brew();           // 서브클래스에서 구현
    abstract void addCondiments();  // 서브클래스에서 구현

    void boilWater() {
        System.out.println("물 끓이는 중");
    }
    void pourInCup() {
        System.out.println("컵에 따르는 중");
    }
}
```

```java
public class Coffee extends CaffeineBeverage {
    public void brew() {
        System.out.println("필터로 커피를 우려내는 중");
    }
    public void addCondiments() {
        System.out.println("설탕과 커피를 추가하는 중");
    }
}
```

```java

public class Tea extends CaffeineBeverage {
    public void brew() {
        System.out.println("차를 우려내는 중");
    }
    public void addCondiments() {
        System.out.println("레몬을 추가하는 중");
    }
}
```

#### **[ hook 메소드 ]**
- 서브클래스 구현시 융통성을 발휘하기 위한 메소드
- 추상 클래스에서 선언하지만 기본적인 내용만 구현되어 있거나 내용이 비어 있는 메소드
```java
public abstract class CaffeineBeverage {
    // 알고리즘을 갖고 있는 이 메소드를 '템플릿 메소드'라 부른다
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        // 고객이 원하는 경우에만 첨가물을 넣는다
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    abstract void brew();           // 서브클래스에서 구현
    abstract void addCondiments();  // 서브클래스에서 구현

    void boilWater() {
        System.out.println("물 끓이는 중");
    }
    void pourInCup() {
        System.out.println("컵에 따르는 중");
    }

    // 이 메소드가 hook 메소드
    boolean customerWantsCondiments() {
        return true;
    }
}
```

### 람다를 사용해 서브 클래스 제거하기
1개의 추상 메소드를 사용하는 템플릿 메소드가 있다.
```java
abstract class OnlineBanking {
    // template method
    public void processCustomer(int id) {
        Customer c = Database.getCustomerWithId(id);
        makeCustomerHappy(c);
    }
    abstract void makeCustomerHappy(Customer c);
}
```
이 코드를 사용하려면 서브 클래스를 작성해야 한다.
```java
class OnlineBankingKorea extends OnlineBanking {
    @Override
    void makeCustomerHappy(Customer c) {
        System.out.println("안녕하세요 " + c.getName());
    }
}
```
다음과 같이 사용할 수 있다.
```java
new OnlineBankingKorea().processCustomer(1337);
```
구현해야 할 추상 메소드가 하나 뿐이므로 람다의 사용을 고려해볼 수 있다.  
OnlineBacking에서 abstract 키워드를 삭제하고, processCustomer 메소드가 Consumer를 받도록 수정한다.
```java
class OnlineBanking {
    public void processCustomer(int id, Consumer<Customer> makeCustomerHappy) {
        Customer c = Database.getCustomerWithId(id);
        makeCustomerHappy.accept(c);
    }
}
```
이제 상속 없이 Online

### 고려할 점들

<br>

## 0304 - @Constraint, ConstraintValidator
스프링에서는 JSR 303 기반 어노테이션 기반으로 일관성 있는 Validation을 진행할 수 있다. 기본으로 제공하는 어노테이션 말고 @Cnstraint로 커스텀 Validation을 만들 수 있다.

#### **[ 장점 ]**
- 일관성있는 처리 방법 - 검증방법과 검증시점에 대해 통일성을 가질 수 있다. 해당 커스텀 Validation을 구현하면 `@NotNull` `@Empty`와 같은 단계인 interceptor에서 처리가 가능하다.
- 간결함 - 로직 흐름에 대한 컨텍스트가 응축돼 있어 적재적소에 사용된다면 불필요한 반복코드가 줄어든다.
- 일관성 있는 ErrorResponse - ConstraintViolationException 에러를 통해 응답을 일관성있게 리턴할 수 있다.

#### **[ 구현 ]**
- 어노테이션 생성(필드 예제)
```java
@Constraint(validatedBy = GenderValidator.class)
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ValidGender {
    String message() default "올바른 성별을 입력해주세요";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

- ConstraintValidator를 구현한 Validator 생성
```java
public class GenderValidtor implements ConstraintValidator<ValidGender, String>{

    @Override
    public boolean isValid(String gender, ConstraintValidatorContext context) {
        try {
            Gender.valueOf(gender.toUpperCase()); 
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

- dto
```java
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class CreateUserReqDto {
        @Email(message = "올바른 이메일을 입력해주세요")
        private String email;

        private String password;

        @ValidGender(message = "올바른 성별을 입력해주세요") <-- CustomValidator
        private Gender gender;
    }
}
```

 - 추가예제
```java
@Constraint(validatedBy = NotEqualValidator.class)
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface NotEqual {
    String message() default "상행 역과 하행 역은 같을 수 없습니다.";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};

    String upStationId();

    String downStationId();

    @Target({ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    @interface List {
        NotEqual[] value();
    }
}
```

```java
public class NotEqualValidator implements ConstraintValidator<NotEqual, Object> {
    private String upStationId;
    private String downStationId;

    @Override
    public void initialize(NotEqual constraintAnnotation) {
        this.upStationId = constraintAnnotation.upStationId();
        this.downStationId = constraintAnnotation.downStationId();
    }

    @Override
    public boolean isValid(Object object, ConstraintValidatorContext context) {
        Object upStationValue = new BeanWrapperImpl(object).getPropertyValue(upStationId);
        Object downStationValue = new BeanWrapperImpl(object).getPropertyValue(downStationId);
        return !upStationValue.equals(downStationValue);
    }
}
```

```java
@NotEqual(upStationId = "upStationId", downStationId = "downStationId")
public class SectionRequest {
    @NotNull
    private Long upStationId;

    @NotNull
    private Long downStationId;
    
    // ...
}
```


#### **[ 결론 ]**
커스텀 어노테이션을 잘 이용하면 불필요한 반복코드가 줄어들고, 비지니스 로직에 더 집중 할 수 있다는 장점이 있다.  
다만, 커스텀 어노테이션은 의도와 목적을 명확히 하여 구성원간 공감대를 이룬 후 추가하는 것이 좋다.

<br>

## 0305 - APM
뭔지 왜쓰는지, 종류, 장단점