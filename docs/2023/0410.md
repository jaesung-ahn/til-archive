# 0410 ~ 0423

## 0411 - DB 파티셔닝(Partitioning)
#### 배경
- 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서, 기존에 사용하는 DB 시스템의 용량(storage)의 한계와 성능(performance)의 저하를 가져오게 된다.
- 즉, VLDB(Very Large DBMS)와 같이 하나의 DBMS에 너무 큰 table이 들어가면서 용량과 성능 측면에서 많은 이슈가 발생하게 되었고, 이런 이슈를 해결하기 위한 방법으로 table을 '파티션(Partition)'이라는 작은 단위로 나누어 관리하는 '파티셔닝(Partitioning)'기법이 나타나게 됨.
- '파티셔닝'기법을 통해 소프트웨어적으로 데이터베이스를 분산 처리하여 성능이 저하되는 것을 방지하고 관리를 보다 수월하게 할 수 있게 됨.

#### 개념
- 논리적인 데이터 element들을 다수의 entity로 쪼개는 행위를 뜻하는 일반적인 용어.
- 즉 큰 table이나 index를, 관리하기 쉬운 partition이라는 작은 단위로 물리적으로 분할하는 것을 의미함.
    - 물리적인 데이터 분할이 있더라도, DB에 접근하는 application의 입장에서는 이를 인식하지 못함.

#### 목적
1. 성능(Performance)
- 특정 DML과 Query의 성능을 향상시킨다.
- 주로 대용량 Data Write 환경에서 효율적이다.
- 특히, Full Scan에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다.
- 많은 INSERT가 있는 OLTP 시스템에서 INSERT 작업을 작은 단위인 partition들로 분산시켜 경합을 줄인다.
2. 가용성(Availability)
- 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다.
- 각 분할 영역(partition별로)을 독립적으로 백업하고 복구할 수 있다.
- table의 파티션 단위로 Disk I/O을 분산하여 경합을 줄이기 때문에 UPDATE 성능을 향상시킨다.
3. 관리용이성(Manageability)
- 큰 테이블들을 제거하여 관리를 쉽게 해준다.

#### 장점
- 관리적 측면 : 파티션 단위 백엽, 추가, 삭제, 변경
    - 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상.
    - 파티션별로 백업 및 복구가 가능.
    - 파티션 단위로 I/O 분산이 가능하여 UPDATE 성능을 향상.
- 성능적 측면 : 파티션 단위 조회 및 DML 수행
    - 데이터 전체 검색 시 필요한 부분만 탐색해 성능이 증가
    - 즉, 풀 스캔에서 데이터 Access의 범위를 줄여 성능 향상을 가져온다.
    - 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다.

#### 단점
- 테이블간 JOIN에 대한 비용이 증가한다.
- 테이블과 인덱스를 별도로 파티셔닝할 수 없다.
    - 테이블과 인덱스를 같이 파티셔닝해야 한다.

### 파티션 내부 동작
#### INSERT  
INSERT 쿼리가 실행되는 MYSQL 서버는 INSERT되는 컬럼 값 중에서 파티션 키 값을 이용해 파티션 표현식을 평가하고, 그 결과에 따라 저장될 파티션을 결정한다.  
INSERT되는 데이터가 파티션이 결정되면 그 후에는 일반적인 과정과 동일하게 진행된다.

#### UPDATE  
UPDATE 쿼리를 실행하려면 변경 대상 데이터가 어느 파티션에 저장되어있는지 찾아야 한다. 이때 WHERE 조건에 파티션 키 컬럼이 조건으로 존재하면 그 값을 통해 데이터가 저장된 파티션에서 빠르게 해당 데이터를 검색할 수 있다.  
만약 MYSQL에서 파티션 키 이외의 컬럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 컬럼 값만 병경한다. 그러나 파티션 키 컬럼이 변경될 때는 해당 파티션에서 데이터를 삭제한 후 해당 데이터를 새로운 파티션으로 복사한다. 그 다음 파티션 키 컬럼을 변경 시켜준다.

#### SELECT  
SQL이 수행되기 위해 파티션 테이블을 검색할때 성능에 크게 영향을 미치는 조건
- WHERE 절의 조건으로 검색해야 할 파티션을 선택 가능한가
- WHERE 절의 조건이 인덱스를 효율적으로 사용할 수 있는가  
첫번째 조건의 결과에 의해 두번째 선택사항의 작업이 달라질 수도 있다.  
그리고 두 조건이 모두 성립할 때 성능적으로 가장 효율적으로 처리될 수 있다. 두조건이 성립되면 파티션의 개수와 상관없이 검색을 위해 필요한 파티션의 인덱스만 스캔한다.

### 파티션 형식
#### Range
범위를 기반으로 파티션을 나누는 형식이다.  
Range Partition은 날씨 기반 데이터가 누적되고 날짜에 따라 분석 삭제할 경우, 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있는 경우, 대량의 과거 데이터 삭제 같은 경우에 사용한다.  
Range Partition에서 null은 어떤 값 보다 작은 값으로 취급되기 때문에 컬럼에 null인 데이터가 insert 된다면 가장 작은 값을 저장하는 파티션에 저장된다.

```sql
CREATE TABLE test (
    id INT NOT NULL,
    lname VARCHAR(30),
    datt DATE NOT NULL DEFAULT '2000-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    store_id INT NOT NULL
) PARTITION BY RANGE (YEAR(datt)) (
    PARTITION p0 VALUES LESS THAN (2020) ,
    PARTITION p1 VALUES LESS THAN (2021) ,
    PARTITION p2 VALUES LESS THAN (2022) ,
    PARTITION p3 VALUES LESS THAN MAXVALUE
    );

-- 추가
ALTER TABLE test ADD PARTITION(PARTITION p4 VALUES LESS THAN (2023));

-- 삭제
ALTER TABLE test DROP PARTITION p4;

-- 병합
ALTER TABLE test 
REORGANIZE PARTITION p2,p3 INTO (
PARTITION p23 VALUES LESS THAN (2020)
);
```

- 날짜 컬럼에 대한 Range파티션 적용시 YEAR(), TO_DAYS()함수만 사용하길 권장(좀더 알아볼 것)
	- 두 함수는 MYSQL 서버 내부적으로 파티션 프루닝 처리가 되어 성능상의 문제가 발생하지 않음

#### List
List Partition은 RangePartition과 비슷하고,코드나 카테고리 등 특정 값을 기반으로 파티션을 나눈다.  
List Partition은 파티션 키 값이 코드 값이나 카테고리와 같이 고정 값일 경우에 사용하고 파티션 키 값을 기준으로 레코드 건수가 균일하고 검색 조건에 파티션 키가 자주 사용되는 경우에 사용한다.  
List는 Range와 다르게 null을 명시할 수 있지만, MAXVALUE는 지정할 수 없다.

```sql
CREATE TABLE test (
    id INT NOT NULL,
    name VARCHAR(30),
    datt DATE NOT NULL DEFAULT '2000-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
) PARTITION BY LIST (job_code) (
    PARTITION p0 VALUES IN (2) ,
    PARTITION p1 VALUES IN (1,9) ,
    PARTITION p2 VALUES IN (3,6,7) ,
    PARTITION p3 VALUES IN (4,5,8, NULL)
    );

-- 추가
ALTER TABLE test ADD PARTITION(PARTITION p4 VALUES IN (3,10));

-- 삭제
ALTER TABLE test DROP PARTITION p4;

-- 병합
ALTER TABLE test 
REORGANIZE PARTITION p2,p3 INTO (
PARTITION p23  VALUES IN (3,6,7,4,5,8,NULL)
);
```

#### Hash
Hash Partition은 Hash 함수에 의해 레코드가 저장될 파티션을 결정하는 방식이다.  
Hash Partition은 테이블의 모든 레코드가 비슷한 사용빈도를 보이지만 너무 커서 파티션이 필요한 경우 사용된다.

```sql
CREATE TABLE test (
    id INT NOT NULL,
    name VARCHAR(30),
    datt DATE NOT NULL DEFAULT '2000-01-01',
    separated DATE NOT NULL DEFAULT '9999-12-31',
    job_code INT NOT NULL,
    store_id INT NOT NULL
) PARTITION BY HASH (id)
PARTITIONS 4;

-- 추가
ALTER TABLE test ADD PARTITION(PARTITION p5 ENGINE = INNODB);

-- 삭제
파티션 키 값을 이용하여 데이터를 각 파티션으로 분산한 것이므로 각 파티션에 저장된 레코드의 부류를 사용자가 예측할 수 없기에 해시나 키를 이용한 파티션에서는 파티션 단위의 삭제는 불가능하다.

-- 분할, 병합
분할은 불가능 하고 추가만 가능하다. 병합 기능도 제공하지 않지만 갯수를 줄이는 것은 가능하다.
```

#### Key
MD5() 함수를 이용한 Hash 값을 기반으로 파티션을 나누고 Hash Partition과 거의 동일하다.  
Key Partition은 선정된 파티션 키값에 대하여 내부적으로 MD5()를 이용하여 해시값을 계산하고, 그 값에 MOD를 적용하여 저장할 파티션을 결정한다.

<br>

## 0413 - 논리 연산과 불 대수
### 논리 연산
: 산술 연산(수치를 이용한 가감승제)을 제외한 문자나 숫자에 대한 여러 가지 연산. 데이터를 숫자로 취급하지 않으며 비트 또는 바이트 단위로 취급.

#### 논리 연산의 종류
논리합, 논리곱, 논리부정, 분기, 비교 시프트, 변환 등
- 분기 : 명령의 순서를 변경하는 것. 무조건 분기와 조건 분기 존재.
- 비교 : 조건에 따라 두 개의 데이터를 비교하여 그 대소를 판단하는 것.
- 시프트 : 각종 연산을 위해서 기억된 데이터 비트들을 왼쪽이나 오른쪽으로 차례대로 이동하는 연산.
- 변환 : 2진수와 10진수의 상호 변환이나 코드를 바꾸는 것.

### 불 대수
#### 대수
: 대수학 (개개의 숫자 대신에 숫자를 대표하는 일반적인 문자를 사용하여 수의 관계, 성질, 계산 법칙 따위를 학문하는 학문).

#### 불 대수
: 조지 불에 의해 창시된 논리 수학. 명제의 참과 거짓을 판단하는 론리 연산을 다루는 대수.   
논리 회로 설계에 이용되어 컴퓨터 동작의 기초가 됨.  
논리의 참 또는 거짓 값을 갖는 논리 변수들의 상관관계를 논리곱, 논리합, 논리부정 등의 논리 연산을 이용하여 논리식으로 표현.

> 논리식을 간단하게 할 수 있는 법칙과 정리들을 제공하므로 이들을 이용하여 정확하고 간결하게 논리 회로 설계 가능.

#### 불 대수의 기본 연산
- 논리곱 : 주어진 복수 명제 모두가 참이어야 결과가 참이 되는 연산
- 논리합 : 주어진 복수 명제에 적어도 1개 이상의 참이 있으면 결과가 참이 되는 연산
- 논리부정 : 주어진 명제의 참과 거짓을 부정하는 연산

#### 불 대수의 법치과 정리
![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcMGZyq%2FbtqD7GCIvFg%2FCimU7NQ17LL1uu3N5ZPBNk%2Fimg.png)

> 산술 연산에서 +와 *연산의 우선순의는 다르지만, 논리 연산에서 +와 *연산의 우선순의는 같으므로 분배법칙이 성립한다.

### 논리 게이트
: 하나 이상의 논리 값을 입력받아 논리 연산을 수행하여 하나의 결과를 출력하는 전자 회로

- AND 게이트 : 두 개 이상의 입력이 모두 1일 때 출력이 1인 게이트. 논리곱 회로
- OR 게이트 : 두 개 이상의 입력 중 하나 이상 입력이 1일 때 출력이 1인 게이트. 논리합 회로
- XOR 게이트 : 입력이 서로 다를 때 출력이 1인 게이트. 배타적 논리합 회로
- NOT 게이트 : 입력이 0이면 출력이 1, 입력이 1이면 출력이 0인 게이트. 논리부정 회로
- NAND 게이트 : NOT + AND 게이트로 AND 게이트의 반대가 출력.
- NOR 게이트 : NOT + OR 게이트로 OR 게이트의 반대가 출력.
- NXOR 게이트 : NOT + XOR 게이트로 XOR 게이트의 반대가 출력.

<br>

## 0421 - 
### 