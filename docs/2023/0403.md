# 0403 ~ 0409

## 0404 - Dispatcher-Servlet(디스패처 서블릿)
### Dispatcher-Servlet 개념
#### 개념
디스패처 서블릿의 dispatch는 "보내다"라는 뜻을 가지고 있다. 그리고 이러한 단어를 포함하는 디스패처 서블릿은 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)라고 정의할 수 있다.  
이것을 보다 자세히 설명하자면, 클라이언트로부터 어떠한 요청이 오면 Tomcat(톰캣)과 같은 서블릿 컨테이너가 요청을 받게 된다. 그리고 이 모든 요청을 프론트 컨트롤러인 디스패처 서블릿이 가장 먼저 받게 된다. 그러면 디스패처 서블릿은 공통적인 작업을 먼저 처리한 후에 해당 요청을 처리해야 하는 컨트롤러를 찾아서 작업을 위임한다.  
여기서 Front Controller(프론트 컨트롤러)라는 용어가 사용되는데, Front Controller는 주로 서블릿 컨테이너의 제일 앞에서 서버로 들어오는 클라이언트의 모든 요청을 받아서 처리해주는 컨트롤러로써, MVC 구조에서 함께 사용되는 디자인 패턴이다.

#### 장점
spring MVC는 DispatcherServlet이 등장함에 따라 web.xml의 역할을 상당히 축소시켜 주었다. 과거에는 모든 서블릿을 URL 매핑을 위해 web.xml에 모두 등록해주어야 했지만, dispatcher-servlet이 해당 어플리케이션으로 들어오는 모든 요청을 핸들링해주고 공통작업을 처리하면서 상당히 편리하게 이용할 수 있게 되었다. 우리는 컨트롤러를 구현해두기만 하면 디스패처 서블릿이 알아서 적합한 컨트롤러로 위임해주는 구조가 되었다.

### Dispatcher-Servelt 동작 과정
#### 동작방식
![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbImFbg%2FbtrGzZMTuu2%2FCkY4MiKvl5ivUJPoc5I3zk%2Fimg.png)
1. 클라이언트의 요청을 디스패처 서블릿이 받음
2. 요청 정보를 통해 요청을 위임할 컨트롤러를 찾음
3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달
4. 핸들러 어댑터가 컨트롤러로 요청을 위임함
5. 비지니스 로직을 처리함
6. 컨트롤러가 반환값을 반환함
7. 핸들러 어댑터가 반환값을 처리함
8. 서버의 응답을 클라이언트로 반환함

<br>

## 0406 - SpringBoot 실행 후에 초기화 코드를 넣는 3가지 방법과 이벤트 리스너
### 커맨드라인 파라미터를 위한 CommandLineRunner
#### CommandLineRunner를 구현하는 클래스 생성
CommandLineRunner는 스프링 부트 1.0에 추가된 함수형 인터페이스로써 스프링 애플리케이션이 구동된 후에 실행되어야 하는 빈을 정의하기 위해 사용된다. CommandLineRunner는 파라미터로 String 타입의 가변 인자를 받고 있으며 인터페이스 이름 그대로 컨맨드 라인으로 받은 스트링 타입의 인자를 파라미터로 받아서 사용하기 위해 만들어졌따. CommandLineRunner는 이를 구현하는 클래스를 정의하고 빈이 등록하면 어플리케이션이 구동된 후에 자동으로 run 메소드가 실행된다.
```java
@Component
class TestCommandLineRunner implements CommandLineRunner {

    @Override
    public void run(String... args) {
        System.out.println("Test");
    }
    
}
```

#### CommandLineRunner를 람다식으로 구현
우리가 필요로 하는 작업은 애플리케이션 실행 후에 1회 초기화 작업인데, 위와 같이 클래스로 만드는 것은 무거우며 번거롭다. CommandLineRunner는 함수형 인터페이스이므로 다음과 같이 main 클래스에 @Bean과 함께 람다식으로 구현하여 간소화할 수 있다.
```java
@SpringBootApplication
public class TestingApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestingApplication.class, args);
    }

    @Bean
    public CommandLineRunner commandLineRunner() {
        return args -> System.out.println("Test");
    }
}
```
@Bean은 @Configuration이 있는 클래스 안에서만 동작하는데, @SpringBootApplication이 갖고 있는 @SpringBootConfiguration 안에 @Configuration이 존재하므로 메인 클래스 역시 빈으로 등록이 되어 가능한 것이다.

### 다양한 파라미터를 위한 ApplicationRunner
ApplicationRunner 역시 마찬가지로 함수형 인터페이스로써 스프링 애플리케이션이 구동된 후에 실행되어야 하는 빈을 정의하기 위한 인터페이스이다. 목적 자체는 동일하지만 ApplicationRunner는 다양한 종류의 파라미터를 받아서 실행하는 경우에 사용할 수 있다. ApplicationRunner는 스프링 부터 2.0에 추가되었다.
```java
@SpringBootApplication
public class TestingApplication {

    public static void main(String[] args) {
        SpringApplication.run(TestingApplication.class, args);
    }

    @Bean
    public ApplicationRunner applicationRunner() {
        return args -> System.out.println("Test");
    }
}
```

### 이벤트 수신을 위한 EventListener
#### 이벤트 리스너 등록 및 이벤트 발행
스프링은 초기부터 애플리케이션 컨텍스트 내부에서 특정 타입의 이벤트를 던지고, 이를 리슨하는 리스너에게 전달해주는 메커니즘을 사용하고 있었다. 그리고 우리가 이를 애플리케이션 레벨에서 이용할 수도 있는데, 특정 타입의 이벤트를 수신하기 위해서는 해당 리스너를 구현해 빈으로 등록해두면 된다. 이벤트 리스너를 등록하고 이벤트를 발행하는 코드는 다음과 같다.
```java
@SpringBootApplication
public class TestingApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(TestingApplication.class, args);

        context.addApplicationListener(new ApplicationListener<ApplicationEvent>() {
            @Override
            public void onApplicationEvent(ApplicationEvent event) {
                System.out.println("Test");
            }
        });

        context.publishEvent(new ApplicationEvent(context) {

        });
    }
}
```

ApplicationEvent의 생성자는 Object 타입을 받고 있는데, 이벤트를 발행하는 객체를 넣는 용도로 존재한다. 위의 코드에서 ApplicationContext 객체를 넣어주었다. ApplicationListener는 역시 함수형 인터페이스이므로 람다식으로 간소화할 수 있다.
```java
@SpringBootApplication
public class TestingApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(TestingApplication.class, args);

        context.addApplicationListener(event -> System.out.println("Test"));

        context.publishEvent(new ApplicationEvent(context) {

        });
    }
}
```

#### @EventListner를 사용한 이벤트 리스너 등록







<br>

## 0407 - 
### 