# 0320 ~ 0402

## 0322 - 테스트 커버리지(Test Coverage)
#### 화이트 박스 테스트
- 테스트 커버리지는 화이트 박스 테스트에서 사용되는 개념
- 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트 방식, 개발자 관점의 단위테스팅 기법
- 소프트웨어의 동작을 검사하는 블랙박스 테스트와는 반대되는 개념

#### 테스트 커버리지란
- 검증 중에 소프트웨어 코드를 얼마만큼 실행시켜 봤는지에 대한 척도 = 소스코드 수행률
- 전체 코드 중에 테스트로 실행된 코드의 비율로 표현
    - 0%면 실행된 코드가 없는것이고 100%면 전체 코드를 모두 실행시켜 봤다는 것을 의미

#### 테스트 커버리지를 측정해야하는 이유
- 테스트 작업 자체의 품질을 객관적/정량적으로 확인이 가능
- 측정된 테스트 커버리지는 테스트 종료 조건으로 활용 가능
    - 가이드라인이 될 수 있음
    - (ex. 커버리지 80% 이상이면 테스트 종료)
- 테스트 커버리지 효과
    - 테스트 커버리지가 50%일 때 25%에 불과하던 오류 검출률이 커버리지 90%일 때는 79%까지 상승

#### 테스트 커버리지의 종류
- 구문 커버리지(Statement Coverage)
    - 실행된 라인 수 / 실행가능한 전체 라인 수
- 결정 커버리지(Branch or Decision Coverage)
    - 분기마다 True/False 가능한 모든 경로가 실행되는지
- 변형 조건/ 결정 커버리지(MC/DC)
    - Multiple condition Coverage의 단점을 보완
    - 각 조건이 독립적으로 분기의 결과에 영향을 미치는 경우를 확인

#### 높은 테스트 커버리지의 이점
- 배포 안정성
- 리팩토링
- 불필요한 프로덕션 코드 삭제
- 프로덕션 코드에 대한 이해도 상승

<br>

## 0323 - JVM의 default Heap Size
JVM(Java Virutal Machine)의 기본 메모리 값은 사용 중인 Java 버전에 따라 다르지만 다음은 Java 8을 기본으로 한다.

#### 런타임시 확인
```java
Runtime.getRuntime().maxMemory()
```

#### Java Default Heap/Perm Size 확인
- Linux
```sh
java -XX:+PrintFlagsFinal -version 2>&1 | grep -i -E 'heapsize|permsize|version'
```

```sh
# java -XX:+PrintFlagsFinal -version 2>&1 | grep -i -E 'heapsize|permsize|version'

    uintx AdaptivePermSizeWeight                    = 20              {product}
    uintx ErgoHeapSizeLimit                         = 0               {product}
    uintx HeapSizePerGCThread                       = 87241520        {product}
    uintx InitialHeapSize                          := 128983616       {product}
    uintx LargePageHeapSizeThreshold                = 134217728       {product}
    uintx MaxHeapSize                              := 2065694720      {product}
    uintx MaxPermSize                               = 174063616       {pd product}
    uintx PermSize                                  = 21757952        {pd product}

java version "1.7.0_79"
```

- Windows
```sh
java -XX:+PrintFlagsFinal -version 2>&1 | findstr /I "heapsize permsize version"
```

```sh
D:\>java -XX:+PrintFlagsFinal -version 2>&1 | findstr /I "heapsize metaspacesize version"

    uintx ErgoHeapSizeLimit                         = 0                                   {product}
    uintx HeapSizePerGCThread                       = 87241520                            {product}
    uintx InitialBootClassLoaderMetaspaceSize       = 4194304                             {product}
    uintx InitialHeapSize                          := 134217728                           {product}
    uintx LargePageHeapSizeThreshold                = 134217728                           {product}
    uintx MaxHeapSize                              := 2147483648                          {product}
    uintx MaxMetaspaceSize                          = 4294901760                          {product}
    uintx MetaspaceSize                             = 21807104                            {pd product}

java version "1.8.0_111"
```

#### 초기 값 기준
jvm을 server class로 실행하면 초기 heap size는 메모리의 1/64 이고, 최대 heap size는 1/4까지 늘어난다.

<br>

## 0329 - Heap 영역의 TLAB, PLAB
TLAB 및 PLAB는 힙 메모리 할당 성능을 향상시키기 위해 JVM에서 사용되는 두 가지 메모리 할당 기술이다.

### TLAB(Thread Local Allocation Buffers)란 무엇인가?
TLAB는 각 스레드에서 작은 개체에 대한 메모리를 할당하는 데 사용된다. 각 스레드에는 자체 TLAB가 있어 스레드 간의 메모리 할당 경합을 줄이는 데 도움이 된다. 스레드가 메모리를 요청하면 JVM은 스레드의 TLAB 부분을 요청에 할당한다. TLAB가 가득 차면 스레드는 힙에서 메모리를 요청한다. TLAB는 작은 객체에 대한 메모리 할당 성능을 향상시킬 수 있지만 힙 조각화를 유발할 수도 있다.

- Heap 메모리에 새로운 객체가 생성될 때, 만약 TLAB이 활성화되어 있다면 객체는 우선 TLAB에 위치하게 된다.
- TLAB은 Eden 영역에만 존재한다. 따라서 TLAB을 사용하면 에덴 영역을 좀 더 많이 사용하게 되지만 객체 생성시 성능 효과를 볼 수 있다.
- 각 스레드는 빠른 메모리 할당을 위해 자신만의 TLAB을 가지고 있다.
- 따라서 TLAB의 총 크기는 스레드 수에 비례한다.
- TLAB를 사용하려면 -XX:+UseTLAB 옵션을 사용한다.
- TLAB의 크기를 조절하려면 -XX:+UseTLAB 옵션을 사용한다. 디폴트는 0인데 이때는 시스템이 알아서 조절하게 된다.

### PLAB(Promotion Local Allocation BUffers)란 무엇인가?
PLAB는 GC가 힙으

- GC에서 Generation을 청소하는 동안 사용된다.
- 각 스레드에 존재한다.

<br>

## 0330 - 
### 

