(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{427:function(t,a,r){"use strict";r.r(a);var e=r(42),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_1003-1009"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1003-1009"}},[t._v("#")]),t._v(" 1003 ~ 1009")]),t._v(" "),r("h2",{attrs:{id:"_1003-db-동시성-문제-해결-방법"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1003-db-동시성-문제-해결-방법"}},[t._v("#")]),t._v(" 1003 - DB 동시성 문제 해결 방법")]),t._v(" "),r("h3",{attrs:{id:"동시성이란-concurrency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#동시성이란-concurrency"}},[t._v("#")]),t._v(" 동시성이란(Concurrency)?")]),t._v(" "),r("p",[t._v("사전적 의미는 하나의 CPU 코어에서 시간분할(Time sharing)을 통하여 여러 일을 처리하는 것 처럼 보여지게 하는 기법을 의미한다."),r("br"),t._v("\n하지만, 대중적으로는 여러 요청이 동시에 동일한 자원(data)에 접근하고 수정하려는 것을 의미한다.")]),t._v(" "),r("h3",{attrs:{id:"동시성-문제-해결방법"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#동시성-문제-해결방법"}},[t._v("#")]),t._v(" 동시성 문제 해결방법")]),t._v(" "),r("h4",{attrs:{id:"비관적인-방법"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#비관적인-방법"}},[t._v("#")]),t._v(" [ 비관적인 방법 ]")]),t._v(" "),r("p",[t._v("현재 수정하려는 데이터가 언제든 다른 요청에 의해 수정될 가능성을 고려하여 해당 데이터에 Lock을 거는 방식."),r("br"),t._v("\n장점은 데이터의 무결성을 완벽히 지킬 수 있다. 수정할 데이터에 row level lock을 걸기 때문에 다른 요청에서 수정하려는 것은 불가능하다."),r("br"),t._v("\n단점은 lock으로 인해 이후의 다른 요청은 대기상태로 빠진다. 기존의 lock의 transaction이 commit 또는 rollback으로 끝나면 대기하고 있떤 요청을 비로소 실행한다."),r("br"),t._v("\n해당 방법은 서버의 성능에 따라 처리량이 결정되기 때문에 도입하기전 서비스의 최소 처리 tps에 부합하는지 확인해야한다."),r("br"),t._v("\n이 방법은 세가지 방식으로 적용할 수 있다.")]),t._v(" "),r("p",[t._v("첫 번째는 DB에서 제공하는 데이터 Lock수준을 높이는 것이다. 일반적인 기본수준값인 "),r("code",[t._v("Repeatable Read")]),t._v("를 "),r("code",[t._v("Serializer")]),t._v(" 이상의 수준으로 올린다. 강도 높은 락으로 완전한 일관성을 유지할 수 있다. 하지만, 이로인한 다른 요청들이 모두 취소가된다. 취소된 작업들은 재시도를 위한 처리가 반드시 필요하기 때문에 서비스에 적용하는것엔 현실성이 부족하다.")]),t._v(" "),r("p",[t._v("두 번째는 "),r("code",[t._v("select for update")]),t._v(" 활용하여 명시적으로 lock을 잡을 수 있다. 하지만 lock을 잡는 구간이 길어져 성능에 심각한 영향을 준다. 극장예매와 같은 서비스가 아니라면 사용하지 않는것이 좋다.")]),t._v(" "),r("p",[t._v("마지막은 Data의 transaction의 write lock을 활용한다. 일반적으로 데이터를 수정할 때 write lock이 걸리고 transaction이 끝나야 lock이 풀리는 것을 이용한다. 데이터의 일관성을 유지할 수 있찌만 DB와 서버 성능에 따라서 서비스의 속도가 좌우된다.")]),t._v(" "),r("h4",{attrs:{id:"낙관적인-방법"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#낙관적인-방법"}},[t._v("#")]),t._v(" [ 낙관적인 방법 ]")]),t._v(" "),r("p",[t._v("수정하려는 데이터는 나만 수정할 것이라는 낙관적인 생각의 방법이다. 테이블에 version이라는 숫자컬럼 또는 updated_at 이라는 시간컬럼을 만들어서 수정될 때마다 1씩 증가하거나, 현재시간으로 갱신하게 해준다. 값을 수정할떄 Version이 동일하면 수정이 가능해지고, 동일하지 않으면 수정에 실패한다.")]),t._v(" "),r("p",[t._v("장점으로는 모델에 컬럼을 하나 추가하면 구현이 비교적으로 쉽지만, 두개의 DB세션이 동일한 버전으로 수정하려고 하면 한 개의 세션에선 version conflict이 발생하여 affected row count가 0이 된다. 따라서 이 경우 요청을 재시도하도록 구현이 필요.")]),t._v(" "),r("br"),t._v(" "),r("h2",{attrs:{id:"_1004"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1004"}},[t._v("#")]),t._v(" 1004 -")]),t._v(" "),r("h3",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);a.default=s.exports}}]);