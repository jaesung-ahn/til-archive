<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="ahnjs/TIL/rss.xml" rel="self" type="application/rss+xml"/>
    <title>안재성 TIL</title>
    <link>ahnjs/TIL/</link>
    <description>Today I Learned</description>
    <language>en-US</language>
    <pubDate>Thu, 05 Jan 2023 14:23:46 GMT</pubDate>
    <lastBuildDate>Thu, 05 Jan 2023 14:23:46 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>0102 ~ 0108</title>
      <link>ahnjs/TIL/2023/0102/</link>
      <guid isPermaLink="false">ahnjs/TIL/2023/0102/</guid>
      <source url="ahnjs/TIL/rss.xml">0102 ~ 0108</source>
      <pubDate>Sat, 31 Dec 2022 04:46:27 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0102-0108"> 0102 ~ 0108</h1>
<h2 id="_0103-preparedstatement-사용-이유"> 0103 - Preparedstatement 사용 이유</h2>
<h4 id="성능-측면"> <strong>[ 성능 측면 ]</strong></h4>
<p><img src="https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F8587157c-7cf4-47a5-acce-c8b9fab630b5%2FwiRZS.png" alt="image"></p>
<p>SQL 서버 엔진이 쿼리를 수행할 때 마다 다음의 과정을 거친다.</p>
<ol>
<li>구문 분석 및 정규화 단계 : 쿼리 문법이 제대로 작성되었는지 확인하고 해당 테이블과 컬럼이 데이터베이스에 존재하는지 확인한다.</li>
<li>컴파일 단계 : 쿼리를 컴파일한다.</li>
<li>쿼리 최적화 계획 : 쿼리를 실행할 수 있는 방법의 수와 쿼리를 실행하는 각 방법의 비용을 알아내 최적의 계획을 선택한다.</li>
<li>캐시 : 쿼리 최적화 계획에서 선택된 계획은 캐시에 저장되므로 동일한 쿼리가 들어올때마다 1, 2, 3 단계를 다시 실행하지 않고 다음에 동일한 쿼리가 들어오면 Cache를 찾아 실행한다.</li>
<li>실행 단계 : 쿼리가 실행되고 데이터가 ResultSet 객체로 사용자에게 반환된다.</li>
</ol>
<p>Statement는 쿼리를 실행할 때마다 1~5단계를 수행한다.</p>
<p>PreparedStatement는 완전한 SQL 쿼리가 아니고 SQL 쿼리의 틀을 미리 생성해 놓고 물음표를 대체할 값을 나중에 지정한다. 따라서 PreparedStatement가 처음 실행될 때 위의 1~3단계를 수행 후 사전 컴파일 되어 캐시에 저장된다. 이후에 <code>Placeholder Replacement</code>라는 추가 단계가 있으며 런타임시에 사용자가 입력한 데이터로 set메서드를 사용해 <code>?</code>를 대체한다.</p>
<p><img src="https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F3744ceb3-6cd8-4646-9566-15de6144b2d2%2FkWnd1.png" alt="image"></p>
<p><code>?</code>가 사용자가 입력한 데이터로 바뀐 후에는 최종 쿼리가 다시 구문 분석하거나 컴파일하지 않는다.</p>
<h4 id="보안-측면"> <strong>[ 보안 측면 ]</strong></h4>
<p>PreparedStatement는 SQL Injection 공격을 방지하기 때문에 보안 측면에서도 좋다.</p>
<p>PreparedStatement에서는 쿼리 실행 단계에서 알 수 있듯이, 쿼리가 컴파일 되어 캐시된 이후에 Placeholder Replacement단계에서 사용자의 데이터로 대체되기 때문에 이미 컴파일된 최종 쿼리는 다시 컴파일 과정을 거치지 않는다. 따라서 사용자의 데이터는 항상 간단한 문자열이여야 하며 쿼리의 원래 논리를 수정할 수 없다. 따라서 PreparedStatement를 사용한 쿼리는 SQL 주입 공격에 대한 영향을 받지 않는다.</p>
<br>
<h2 id="_0104-쿼리-캐시"> 0104 - 쿼리 캐시</h2>
<ul>
<li>쿼리 캐시란, SELECT 쿼리문을 이용하여 조회한 값을 저장하고 있다가, 같은 쿼리 문을 요청하였을 때 미리 캐싱된 값을 반환하는 DBMS 기능이다.</li>
<li>일반적인 웹사이트와 같이 쓰기(wirte)보다는 읽는(read) 횟수가 많은 환경에서 유용하다.</li>
<li>하지만, 멀티 코어 시스템 및 처리량이 높은 환경에서는 확장성이 좋지 않으므로 기본적으로 사용되지 않도록 설정된다.</li>
</ul>
<h4 id="쿼리-캐시-기능-사용"> <strong>[ 쿼리 캐시 기능 사용 ]</strong></h4>
<ul>
<li>쿼리 캐시 기능을 사용할 수 있는지 확인하려면, 기본적으로 <code>have_query_cache</code> 설정이 되어 있어야 한다.</li>
<li>설정이 되어있는지 확인하고 싶다면, 아래와 같은 쿼리 문을 입력한다.</li>
</ul>
<div><pre><code><span>SHOW</span> VARIABLES <span>LIKE</span> <span>'HAVE_QUERY_CACHE'</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>조회 결과 YES로 나온다면, 쿼리 캐시 기능을 사용할 수 있따는 뜻이다.</li>
</ul>
<div><pre><code><span>SHOW</span> VARIABLES <span>LIKE</span> <span>'QUERY_CACHE_TYPE'</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>현재 시스템에서 쿼리 캐시 기능을 사용하고 있는지를 조회한다.</li>
</ul>
<h4 id="쿼리-캐시가-되지-않는-경우"> <strong>[ 쿼리 캐시가 되지 않는 경우 ]</strong></h4>
<p>아래와 같은 함수를 사용하면, 기본적으로 쿼리가 캐싱되지 않는다.</p>
<div><pre><code>BENCHMARK<span>(</span><span>)</span>
CONNECTION_ID<span>(</span><span>)</span>
CONVERT_TZ<span>(</span><span>)</span>
CURDATE<span>(</span><span>)</span>
<span>CURRENT_DATE</span><span>(</span><span>)</span>
<span>CURRENT_TIME</span><span>(</span><span>)</span>
<span>CURRENT_TIMESTAMP</span><span>(</span><span>)</span>
CURTIME<span>(</span><span>)</span>
<span>DATABASE</span><span>(</span><span>)</span>
ENCRYPT<span>(</span><span>)</span> <span>(</span>one parameter<span>)</span>
FOUND_ROWS<span>(</span><span>)</span>
GET_LOCK<span>(</span><span>)</span>
LAST_INSERT_ID<span>(</span><span>)</span>
LOAD_FILE<span>(</span><span>)</span>
MASTER_POS_WAIT<span>(</span><span>)</span>
<span>NOW</span><span>(</span><span>)</span>
RAND<span>(</span><span>)</span>
RELEASE_LOCK<span>(</span><span>)</span>
SLEEP<span>(</span><span>)</span>
SYSDATE<span>(</span><span>)</span>
UNIX_TIMESTAMP<span>(</span><span>)</span>
<span>(</span><span>no</span> parameters<span>)</span>
<span>USER</span><span>(</span><span>)</span>
UUID<span>(</span><span>)</span>
UUID_SHORT<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><ul>
<li>또한 쿼리에 아래와 같은 구문이 있을 경우 쿼리가 캐싱되지 않는다.</li>
</ul>
<div><pre><code><span>SELECT</span> SQL_NO_CACHE <span>.</span><span>.</span><span>.</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>INTO</span> <span>OUTFILE</span> <span>.</span><span>.</span><span>.</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>INTO</span> <span>DUMPFILE</span> <span>.</span><span>.</span><span>.</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>FOR</span> <span>UPDATE</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> <span>.</span><span>.</span><span>.</span> <span>WHERE</span> autoincrement_column <span>IS</span> <span>NULL</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>LOCK</span> <span>IN</span> <span>SHARE</span> <span>MODE</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="쿼리-캐시-크기-제한"> <strong>[ 쿼리 캐시 크기 제한 ]</strong></h4>
<p><img src="https://user-images.githubusercontent.com/14002238/120759865-6f475980-c54e-11eb-8b81-ad5975fa0449.png" alt="image"></p>
<div><pre><code><span>SHOW</span> VARIABLES <span>LIKE</span> <span>'query_cache_size'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>쿼리 캐시 크기 설정 확인</li>
</ul>
<div><pre><code><span>SET</span> <span>GLOBAL</span> query_cache_size <span>=</span> <span>800000</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li><code>query_cache_size</code>값 설정</li>
<li>쿼리의 빈도수가 적고, 데이터가 많이 조회되는 쿼리가 있을 경우 캐싱을 할 필요가 없으므로 <code>query_cache_limit</code> 옵션으로 크기를 설정해서 특정 결과값의 용량이 설정해놓은 값이 넘으면 캐싱하지 않도록 설정을 할 수 있다.</li>
</ul>
<h4 id="캐시-설정-및-의미"> <strong>[ 캐시 설정 및 의미 ]</strong></h4>
<div><pre><code><span>SHOW</span> <span>STATUS</span> <span>LIKE</span> <span>'Qcache%'</span><span>;</span>
<span>+</span><span>-------------------------+----------+</span>
<span>|</span> Variable_name           <span>|</span> <span>Value</span>    <span>|</span>
<span>+</span><span>-------------------------+----------+</span>
<span>|</span> Qcache_free_blocks      <span>|</span> <span>1158</span>     <span>|</span>
<span>|</span> Qcache_free_memory      <span>|</span> <span>3760784</span>  <span>|</span>
<span>|</span> Qcache_hits             <span>|</span> <span>31943398</span> <span>|</span>
<span>|</span> Qcache_inserts          <span>|</span> <span>42998029</span> <span>|</span>
<span>|</span> Qcache_lowmem_prunes    <span>|</span> <span>34695322</span> <span>|</span>
<span>|</span> Qcache_not_cached       <span>|</span> <span>652482</span>   <span>|</span>
<span>|</span> Qcache_queries_in_cache <span>|</span> <span>4628</span>     <span>|</span>
<span>|</span> Qcache_total_blocks     <span>|</span> <span>11123</span>    <span>|</span>
<span>+</span><span>-------------------------+----------+</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>
<li>Qcache_inserts : 현재, 캐싱된 쿼리의 값을 의미</li>
<li>Qcache_hits : 쿼리를 캐싱하여, 캐싱된 값을 반환한 값을 의미</li>
<li>Qcache_lowmem_prunes : 메모리 값이 부족하여, 캐시에서 이전에 있떤 값을 제거한 값
<ul>
<li>해당 값을 줄이려면 query_cache_limit 값을 적절하게 설정한다.</li>
</ul>
</li>
</ul>
<h4 id="결론"> <strong>[ 결론 ]</strong></h4>
<ul>
<li>그 밖에도, query_cache_wlock_invalidate 옵션을 끄면, WRITE 락이 걸리더라도, 캐싱된 값을 반환하게 하여, 경합 상태에서도 기다리지 않고 값을 읽을 수 있다.</li>
<li>캐리된 쿼리를 잘 이용하면, 성능을 높일 수 있다.</li>
<li>실제 SQL은 대소문자를 구분하지 않지만, 캐싱된 쿼리 값을 반환받기 위해서는 대소문자까지 같아야 한다.</li>
<li>쿼리 캐시 값의 크기를 크게 늘리면, 읽기 속도는 빨라지지만 락 경합 때문에 쓰기 속도는 느려질 수 있다.</li>
</ul>
<br>
<h2 id="_0106"> 0106 -</h2>
<h3 id=""> </h3>
]]></content:encoded>
      <enclosure url="https://velog.velcdn.com/images%2Fjsj3282%2Fpost%2F8587157c-7cf4-47a5-acce-c8b9fab630b5%2FwiRZS.png" type="image/png"/>
    </item>
    <item>
      <title>1212 ~ 0101</title>
      <link>ahnjs/TIL/2022/1212/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/1212/</guid>
      <source url="ahnjs/TIL/rss.xml">1212 ~ 0101</source>
      <pubDate>Mon, 12 Dec 2022 14:48:24 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1212-0101"> 1212 ~ 0101</h1>
<h2 id="_1213-람다-캡처링-capturing-lambda"> 1213 - 람다 캡처링(Capturing Lambda)</h2>
<p>기본적으로 람다 표현식은 (파라미터) -&gt; 동작과 같은 구조를 지니며, 파라미터로 넘겨진 변수를 활용하여 바디에서 작업을 수행한다. 람다 캡처링(capturing lambda)이란 간단히 말해 이처럼 파라미터로 넘겨받은 데이터가 아닌 &quot;람다식 외부에서 정의된 변수&quot;를 참조하는 변수를 람다식 내부에 저장하고 사용하는 동작을 의미한다. 아래는 그 예이다.</p>
<div><pre><code><span>void</span> <span>lambdaCapturing</span><span>(</span><span>)</span> <span>{</span>
   <span>int</span> localVariable <span>=</span> <span>1000</span><span>;</span>

   <span>Runnable</span> r <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>localVariable<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="제약-조건-지역변수는-final이어야-한다"> <strong>[ 제약 조건: 지역변수는 final이어야 한다 ]</strong></h4>
<p>람다는 값이 단 한 번만 할당되는 지역변수만을 캡처할 수 있으며, 만일 람다에서 캡처되는 지역변수의 값을 재할당되는 경우 컴파일 에러가 발생한다. 즉, 명시적으로 final로 선언되었거나, 실질적으로 final인 지역변수만 람다식 바디에 들어올 수 있다는 것이다.</p>
<p>이러한 제약조건은 JVM 메모리 구조와 관련이 있다. JVM 메모리상으로 힙에 저장되는 인스턴스 변수 등과는 달리, 지역변수는 스택에 저장되기 때문이다.</p>
<p>예를 들어 '지역변수의 값을 캡처하는 람다'를 반환하는 메서드를 한 번 생각해보자. 해당 메서드의 실행이 종료되는 경우, JVM은 반환되는 람다식의 바디에 포함되어 있는 지역변수의 할당을 해제한다. 그럼에도 불구하고 람다는 지역변수의 값을 아무 문제 없이 참조하여 사용할 수 있다. 이는 람다 내부에서 사용되는 지역변수는 원본 지역변수를 복제한 데이터이기 때문이다. 그렇기 때문에 실제 지역변수의 할당이 해제되어도 람다 내부의 값은 유지되는 것이며, 복제품의 값이 변경되지 않아야 한다는 이유로 단 한 번만 값을 할당해야 한다는 제약이 생겨난 것이다.</p>
<div><pre><code><span>void</span> <span>useLambda</span><span>(</span><span>)</span> <span>{</span>
   <span>Supplier</span><span><span>&lt;</span><span>Integer</span><span>></span></span> lambda <span>=</span> <span>getLambda</span><span>(</span><span>)</span><span>;</span>

   <span>int</span> actual <span>=</span> lambda<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>

   <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>actual<span>)</span><span>;</span> <span>// 1005</span>
<span>}</span>

<span>// 지역변수를 캡처하여 사용하는 람다를 외부로 반환하는 메서드</span>
<span>private</span> <span>Supplier</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>getLambda</span><span>(</span><span>)</span> <span>{</span>
   <span>int</span> localVariable <span>=</span> <span>1000</span><span>;</span> <span>// 지역변수 localVariable</span>

   <span>return</span> <span>(</span><span>)</span> <span>-></span> localVariable <span>+</span> <span>5</span><span>;</span> <span>// 자유변수 localVariable</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>그리고 이처럼 람다식 내부에서 저장되는 지역변수의 복제품은 원본이 되는 지역변수이 사라져도 자유롭게 존재할 수 있기 때문에 자유변수라고 불린다.</p>
<p>사실 지역변수의 불변성을 강제하는 것은 딱히 문제라고 보기 어렵다. 불변성이 지닌 다양한 이점도 있겠지만, 외부 변수의 값을 직접적으로 변화하는 일반적인 절차형/명령형 프로그래밍 패턴을 예방한다는 점이 가장 큰 이점이라고 볼 수 있다점을 제약 조건의 이점으로 볼 수 있다.</p>
<br>
<h2 id="_1215-thread와-runnable"> 1215 - Thread와 Runnable</h2>
<h3 id="_1-thread와-runnable에-대한-이해-및-사용법"> 1. Thread와 Runnable에 대한 이해 및 사용법</h3>
<h4 id="쓰레드와-자바의-멀티-쓰레드"> <strong>[ 쓰레드와 자바의 멀티 쓰레드 ]</strong></h4>
<p>쓰레드란 프로그램 실행의 가장 작은 단위이다. 일반적으로 자바 애플리케이션을 만들어 실행하면 1개의 메인(main) 쓰레드에 의해 프로그램이 실행된다. 하지만 1개의 쓰레드 만으로는 동시에 여러 작업을 할 수 없다. 동시에 여러 작업을 처리하고 싶다면, 별도의 쓰레드를 만들어 실행시켜줘야 하는데, 자바는 멀티 쓰레드 기반으로 동시성 프로그래밍을 지원하기 위한 방법들을 계속해서 발전시켜 왔다.<br>
그 중에서 Thread와 Runnable은 자바 초기부터 멀티 쓰레드를 위해 제공되었던 기술이다.</p>
<ul>
<li>java5 이전 : Runnable과 Thread</li>
<li>java5 : Callable과 Future 및 Executor, ExecutorService, Executors</li>
<li>java7 : Fork/Join 및 RecursiveTask</li>
<li>java9 : Flow</li>
</ul>
<h4 id="thread-클래스"> <strong>[ Thread 클래스 ]</strong></h4>
<p>Thread는 쓰레드 생성을 위해 Java에서 미리 구현해둔 클래스이다. Thread는 기본적으로 다음과 같은 메소드들을 제공한다.</p>
<ul>
<li>sleep
<ul>
<li>현재 쓰레드 멈추기</li>
<li>자원을 놓아주지는 않고, 제어권을 넘겨주므로 데드락이 발생할 수 있음</li>
</ul>
</li>
<li>interupt
<ul>
<li>다른 쓰레드를 깨워서 interruptedException을 발생시킴</li>
<li>Interupt가 발생한 쓰레드는 예외를 catch하여 다른 작업을 할 수 있음</li>
</ul>
</li>
<li>join
<ul>
<li>다른 쓰레드의 작업이 끝날 때 까지 기다리게 함</li>
<li>쓰레드의 순서를 제어할 때 사용할 수 있음</li>
</ul>
</li>
</ul>
<p>Thread 클래스로 쓰레드를 구현하려면 이를 상속받는 클래스를 만들고, 내부에서 run 메소드를 구현해야 한다. 그리고 Thread의 start 메소드를 호출하면 run 메소드가 실행된다. 실행 결과를 보면 main 쓰레드가 아닌 별도의 쓰레드에서 실행됨을 확인할 수 있다.</p>
<div><pre><code><span>@Test</span>
<span>void</span> <span>threadStart</span><span>(</span><span>)</span> <span>{</span>
    <span>Thread</span> thread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>

    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>static</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 출력 결과</span>
<span>// Hello: main</span>
<span>// Thread: Thread-2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>여기서 run을 직접 호출하는 것이 아니라 start를 호출하는 것에 주의해야 한다. 우리는 해당 메소드의 실행을 별도의 쓰레드로 하고 싶은 것인데, run을 직접 호출하는 것은 메인 쓰레드에서 객체의 메소드를 호출하는 것에 불과하다. 이를 별도의 쓰레드로 실행시키려면 JVM의 도움이 필요하다. 따라서 start를 호출한다.</p>
<div><pre><code><span>public</span> <span>synchronized</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>threadStatus <span>!=</span> <span>0</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>

    group<span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>

    <span>boolean</span> started <span>=</span> <span>false</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>start0</span><span>(</span><span>)</span><span>;</span>
        started <span>=</span> <span>true</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>if</span> <span>(</span><span>!</span>started<span>)</span> <span>{</span>
                group<span>.</span><span>threadStartFailed</span><span>(</span><span>this</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> ignore<span>)</span> <span>{</span>
        
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>위의 코드를 보면 알 수 있듯이 start는 크게 다음과 같은 과정으로 진행된다.</p>
<blockquote>
<ol>
<li>쓰레드가 실행 가능한지 검사함</li>
</ol>
</blockquote>
<p>쓰레드는 New, Runnable, Waiting, Timed Waiting, Terminated 총 5가지 상태가 있다. start 가장 처음에는 해당 쓰레드가 실행 가능한 상태인지(0인지) 확인한다. 그리고 만약 쓰레드가 New(0) 상태가 아니라면 IllegalThreadStateException 예외를 발생시킨다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbuLmDm%2FbtrER3drmAo%2FL8Vw0lq8lB0hkZs01jiijk%2Fimg.png" alt="image"></p>
<blockquote>
<ol start="2">
<li>쓰레드를 쓰레드 그룹에 추가함</li>
</ol>
</blockquote>
<p>그 다음 쓰레드 그룹에 해당 쓰레드를 추가시킨다. 여기서 쓰레드 그룹이란 서로 관련있는 쓰레드를 하나의 그룹으로 묶어 다루기 위한 장치인데, 자바에서는 ThreadGroup 클래스를 제공한다. 쓰레드 그룹에 해당 쓰레드를 추가하면 쓰레드 그룹에 실행 준비된 쓰레드가 있음을 알려주고, 관련 작업들이 내부적으로 진행된다.</p>
<blockquote>
<ol start="3">
<li>쓰레드를 JVM이 실행시킴</li>
</ol>
</blockquote>
<p>그리고 start0 메소드를 호출하는데, 이것은 native 메소드로 선언되어 있다. 이것은 JVM에 의해 호출되는데, 이것이 내부적으로 run을 호출하는 것이다. 끄리고 쓰레드의 상태 역시 Runnable로 바뀌게 된다. 그래서 start는 여러 번 호출하는 것이 불가능하고 1번만 가능하다.</p>
<div><pre><code><span>private</span> <span>native</span> <span>void</span> <span>start0</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="runnable-인터페이스"> <strong>[ Runnable 인터페이스 ]</strong></h4>
<p>Runnable 인터페이스는 1개의 메소드 만을 갖는 함수형 인터페이스이다. 그렇기 때문에 람다로도 사용 가능하다.</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Runnable</span> <span>{</span>

    <span>public</span> <span>abstract</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>이것은 쓰레드를 구현하기 위한 템플릿에 해당하는데, 해당 인터페이스의 구현체를 만들고 Thread 객체 생성 시에 넘겨주면 실행 가능하다. 앞서 살펴본 Thread 클래스는 반드시 run 메소드를 구현해야 했는데, Thread 클래스가 Runnable를 구현하고 있기 때문이다.</p>
<div><pre><code><span>public</span> <span>class</span> <span>Thread</span> <span>implements</span> <span>Runnable</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>기존에 Thread로 작성되었던 코드를 Runnable로 변경하면 다음과 같다. 마찬가지로 별도의 쓰레드에서 실행됨을 확인할 수 있다.</p>
<div><pre><code><span>@Test</span>
<span>void</span> <span>runnable</span><span>(</span><span>)</span> <span>{</span>
    <span>Runnable</span> runnable <span>=</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>;</span>

    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>runnable<span>)</span><span>;</span>
    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello: "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>// 출력 결과</span>
<span>// Hello: main</span>
<span>// Thread: Thread-1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_2-thread와-runnable-비교"> 2. Thread와 Runnable 비교</h3>
<h4 id="threaddhk-runnable-비교"> <strong>[ Threaddhk Runnable 비교 ]</strong></h4>
<p>Runnable은 익명 객체 및 람다로 사용할 수 있지만, Thread는 별도의 클래스를 만들어야 한다는 점에서 번거롭다. 또한 Java에서는 다중상속이 불가능하므로 Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없어서 좋지 않다. 또한 Thread 클래스를 상속받으면 해당 클래스에 구현된 코드들에 의해 더 많은 자원을 필요로 하므로 Runnable이 주로 사용된다.<br>
물론 Thread 관련 기능의 확장이 필요한 경우에는 Thread 클래스를 상속받아 구현해야 할 때도 있다. 하지만 거의 대부분의 경우에는  Runnable 인터페이스를 사용하면 해결 가능하다.</p>
<h4 id="thread와-runnable의-단점-및-한계"> <strong>[ Thread와 Runnable의 단점 및 한계 ]</strong></h4>
<ul>
<li>지나치게 저수준의 API(쓰레드의 생성)의존함</li>
<li>값의 반환이 불가능</li>
<li>매번 쓰레드 생성과 종료하는 오버헤드가 발생</li>
<li>쓰레드들의 관리가 어려움</li>
</ul>
<p>Executor, ExecutorService, ScheduledExecutionService와 Callable, Future</p>
<br>
<h2 id="_1224-자바-8-표준-api의-함수형-인터페이스"> 1224 - 자바 8 표준 API의 함수형 인터페이스</h2>
<h3 id="자바-8이-제공하는-함수형-인터페이스"> 자바 8이 제공하는 함수형 인터페이스</h3>
<p>자바 8버전부터 빈번하게 사용되는 함수형 인터페이스를 <code>java.util.function</code> 표준 API 패키지로 제공한다. 제공되는 함수형 인터페이스는 크게 5가지로 <code>Consumer</code>, <code>Supplier</code>, <code>Function</code>, <code>Operator</code>, <code>Predicate</code> 이다. 각 인터페이스는 또 여러개의 언터페이스로 나뉜다.</p>
<p>두개의 매개변수를 받는 인터페이스라면 <code>Bi</code> 라는 접두사, 정수 타입을 매개변수로 전달받는 인터페이스라면 <code>Int</code> 라는 접두사가 혻은 실수 타입을 반환하는 인터페이스라면 <code>AsDouble</code> 과 같은 접미사가 달려있는 등 일정한 네이밍 규칙이 존재한다.</p>
<h3 id="consumer-계열"> Consumer 계열</h3>
<p>매개값은 있고 반환값은 없다. 매개값을 전달받아 사용하고 아무것도 반환하지 않을 때 사용된다. 이를 소비(Consume) 한다고 표현한다. <code>accept</code> 추상 메소드를 가지고 있다.</p>
<h4 id="용례"> <strong>[ 용례 ]</strong></h4>
<p>대표적으로 Stream 의 <code>forEach</code> 메소드의 매개변수 타입이 <code>Consumer</code> 이다</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span>
numbers<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span>number <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>number<span>)</span><span>)</span><span>;</span>
<span>// Consumer 전달됨</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>매개값으로 <code>number</code>를 받고 람다 표현식 내부에서 사용되기만 할 뿐 아무것도 반환하지 않는 것을 확인할 수 있다.</p>
<p>또한 <code>Map</code> 의 <code>forEach</code> 메소드는 <code>BiConsumer</code> 타입을 매개변수로 받는다.</p>
<div><pre><code><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>Map</span><span>.</span><span>of</span><span>(</span><span>"hudi"</span><span>,</span> <span>25</span><span>,</span> <span>"baby"</span><span>,</span> <span>1</span><span>)</span><span>;</span>
map<span>.</span><span>forEach</span><span>(</span><span>(</span>name<span>,</span> number<span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>name <span>+</span> <span>"는 "</span> <span>+</span> number <span>+</span> <span>"살"</span><span>)</span><span>)</span><span>;</span>
<span>// BiConsumer 전달됨</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>위와 같이 첫번째 매개변수는 <code>Map</code> 의 key를, 두번째 매개변수는 <code>Map</code> 의 value 를 전달받는다.</p>
<h3 id="supplier-계열"> Supplier 계열</h3>
<p>매개값은 없고, 반환값은 있다. 실행 후 호출한 곳으로 데이터 공급(Supply) 한다. <code>getXXX</code> 추상메소드를 가지고 있다.</p>
<h4 id="용례-2"> <strong>[ 용례 ]</strong></h4>
<p>Stream의 <code>generate</code>는 매개변수로 <code>Supplier</code>타입을 받아 해당 <code>get</code>메소드의 반환값으로 무한한 Stream 을 생성한다.</p>
<div><pre><code><span>Stream</span><span>.</span><span>generate</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>"Infinite Stream!"</span><span>)</span> <span>// Supplier 전달됨</span>
        <span>.</span><span>limit</span><span>(</span><span>5</span><span>)</span>
        <span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="function-계열"> Function 계열</h3>
<p>매개값도 있고, 리턴값도 있다. 주로 매개값을 반환값으로 매핑할 때 즉, 타입 변환이 목적일 때 사용한다. <code>applyXXX</code> 추상 메소드를 갖고 있다.</p>
<h4 id="용례-3"> <strong>[ 용례 ]</strong></h4>
<p><code>IntStream</code>의 <code>mapToObj</code>는 정수를 객체로 매핑하는 메소드이다. 이 메소드는 인자로 <code>IntFunction</code> 타입을 전달받는다.</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Number</span><span>></span></span> numbers <span>=</span> <span>IntStream</span><span>.</span><span>rangeClosed</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>)</span>
        <span>.</span><span>mapToObj</span><span>(</span>number <span>-></span> <span>new</span> <span>Number</span><span>(</span>number<span>)</span><span>)</span> <span>// IntFunction 전달됨</span>
        <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="operator-계열"> Operator 계열</h3>
<p>Function과 마찬가지로, 매개값도 있고, 반환값도 있다. 주로 매개값을 연산 (Operation) 하여 결과를 반환할 때 사용된다. <code>Function</code>과 마찬가지로 <code>applyXXX</code> 추상 메소드를 가지고 있다.</p>
<h4 id="용례-4"> <strong>[ 용례 ]</strong></h4>
<p>Stream의 여러 오버로드된 <code>reduce</code> 메소드 중 하나는 매개변수로 <code>BinaryOperator</code>를 전달받는다. 아래는 <code>BinaryOperator</code>를 활용하여 컬렉션의 모든 수를 더하는 예시이다.</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span>
<span>Integer</span> sum <span>=</span> numbers<span>.</span><span>stream</span><span>(</span><span>)</span>
        <span>.</span><span>reduce</span><span>(</span><span>(</span>acc<span>,</span> cur<span>)</span> <span>-></span> acc <span>+</span> cur<span>)</span> <span>// BinaryOperator 전달됨</span>
        <span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="predicate-계열"> Predicate 계열</h3>
<p>매개값은 있고, 반환 타입은 boolean 이다. 매개값을 받아 검사하고 true/false를 반환할때 사용된다. <code>test</code> 추상 메소드를 가지고 있다.</p>
<h4 id="용례-5"> <strong>[ 용례 ]</strong></h4>
<p>Stream의 <code>allMatch</code> 메소드는 매개변수로 <code>Predicate</code> 타입을 전달받아, 컬렉션의 모든 요소가 주어진 조건에 모두 일치하면 ture를 반환한다.</p>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>,</span> <span>25</span><span>,</span> <span>15</span><span>,</span> <span>30</span><span>,</span> <span>35</span><span>)</span><span>;</span>
<span>boolean</span> allMatched <span>=</span> numbers<span>.</span><span>stream</span><span>(</span><span>)</span>
        <span>.</span><span>allMatch</span><span>(</span>number <span>-></span> number <span>></span> <span>5</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>Consumer, Function, Operator 계열은 andThen과 copose라는 디폴트 메소드를 가지고 있다. 또한 Predicate 계열은 and, or, negate 라는 디폴트 메소드, 그리고 isEqual이라는 정적 메소드를 가지고 있다.</p>
</blockquote>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbuLmDm%2FbtrER3drmAo%2FL8Vw0lq8lB0hkZs01jiijk%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>1128 ~ 1211</title>
      <link>ahnjs/TIL/2022/1128/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/1128/</guid>
      <source url="ahnjs/TIL/rss.xml">1128 ~ 1211</source>
      <pubDate>Sat, 26 Nov 2022 00:37:20 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1128-1211"> 1128 ~ 1211</h1>
<h2 id="_1201-spring-rest-docs-rest-assured"> 1201 - Spring REST Docs + Rest Assured</h2>
<p><strong>[ build.gradle ]</strong></p>
<div><pre><code>plugins {
    ...
    // Asciidoctor 플러그인을 적용
    id &quot;org.asciidoctor.jvm.convert&quot; version &quot;3.3.2&quot;
    ...
}

configurations {
    ...
    // asciidoctorExtAsciidoctor를 확장하는 종속성에 대한 구성을 선언
    asciidoctorExt
    ...
}

dependencies {
    ...
    // asciidoctorExt : spring-restdocs-asciidoctor 구성 의존성을 추가
    // snippets을 .adoc로 가리키고 build/generated-snippets 생성되도록 자동으로 구성 
    asciidoctorExt &#39;org.springframework.restdocs:spring-restdocs-asciidoctor&#39;
    // spring-restdocs-restassured 의존성을 추가
    testImplementation &#39;org.springframework.restdocs:spring-restdocs-restassured&#39;
    ...
}

ext {
    ...
    // 생성된 스니펫의 출력 위치를 정의하도록 속성을 구성
    set(&#39;snippetsDir&#39;, file(&quot;build/generated-snippets&quot;))
    ...
}

tasks.named(&#39;test&#39;) {
    outputs.dir snippetsDir
    useJUnitPlatform()
}


tasks.named(&#39;asciidoctor&#39;) {
    inputs.dir snippetsDir
    // 	asciidoctorExt확장 에 대한 구성 사용을 구성
    configurations &#39;asciidoctorExt&#39;
    dependsOn test
}

tasks.named(&#39;bootJar&#39;) {
    dependsOn asciidoctor
    // 생성된 문서를 jar static/docs디렉토리에 복사
    copy {
        from &quot;${asciidoctor.outputDir}&quot;
        into &#39;src/main/resources/static/docs&#39;
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p><strong>[ 테스트 클래스 ]</strong></p>
<ul>
<li>AcceptanceTest</li>
</ul>
<div><pre><code><span>@SpringBootTest</span><span>(</span>webEnvironment <span>=</span> <span>SpringBootTest<span>.</span>WebEnvironment</span><span>.</span>RANDOM_PORT<span>)</span>
<span>@ExtendWith</span><span>(</span><span>{</span><span>RestDocumentationExtension</span><span>.</span><span>class</span><span>,</span> <span>SpringExtension</span><span>.</span><span>class</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>AcceptanceTest</span> <span>{</span>

    <span>@LocalServerPort</span>
    <span>int</span> port<span>;</span>

    <span>protected</span> <span>RequestSpecification</span> spec<span>;</span>

    <span>@BeforeEach</span>
    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>RestDocumentationContextProvider</span> restDocumentation<span>)</span> <span>{</span>
        <span>RestAssured</span><span>.</span>port <span>=</span> port<span>;</span>
        <span>this</span><span>.</span>spec <span>=</span> <span>new</span> <span>RequestSpecBuilder</span><span>(</span><span>)</span>
                <span>.</span><span>addFilter</span><span>(</span><span>documentationConfiguration</span><span>(</span>restDocumentation<span>)</span><span>)</span>
                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ul>
<li>OrderRestControllerTest</li>
</ul>
<div><pre><code><span>class</span> <span>OrderRestControllerTest</span> <span>extends</span> <span>AcceptanceTest</span> <span>{</span>

    <span>@Test</span>
    <span>void</span> <span>postOrder</span><span>(</span><span>)</span> <span>{</span>
        <span>// given</span>
        <span>String</span> menuName <span>=</span> <span>"메뉴"</span><span>;</span>

        <span>// when</span>
        <span>ExtractableResponse</span><span><span>&lt;</span><span>Response</span><span>></span></span> response <span>=</span> 주문_생성_요청<span>(</span>menuName<span>,</span> <span>2</span><span>)</span><span>;</span>
        <span>OrderModel</span> order <span>=</span> response<span>.</span><span>as</span><span>(</span><span>OrderModel</span><span>.</span><span>class</span><span>)</span><span>;</span>

        <span>// then</span>
        <span>assertThat</span><span>(</span>response<span>.</span><span>statusCode</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>HttpStatus</span><span>.</span>OK<span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>assertThat</span><span>(</span>order<span>.</span><span>getMenuName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span>menuName<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>ExtractableResponse</span><span><span>&lt;</span><span>Response</span><span>></span></span> 주문_생성_요청<span>(</span><span>String</span> menuName<span>,</span> <span>Integer</span> quantity<span>)</span> <span>{</span>
        <span>OrderPostRequestDTO</span> dto <span>=</span> <span>new</span> <span>OrderPostRequestDTO</span><span>(</span>menuName<span>,</span> quantity<span>)</span><span>;</span>

        <span>return</span> <span>RestAssured</span>
                <span>.</span><span>given</span><span>(</span><span>this</span><span>.</span>spec<span>)</span><span>.</span><span>log</span><span>(</span><span>)</span><span>.</span><span>all</span><span>(</span><span>)</span>
                <span>.</span><span>accept</span><span>(</span>APPLICATION_JSON_VALUE<span>)</span>
                <span>.</span><span>filter</span><span>(</span><span>document</span><span>(</span><span>"post-order"</span><span>,</span>
                        <span>requestFields</span><span>(</span>
                                <span>fieldWithPath</span><span>(</span><span>"order.menuName"</span><span>)</span><span>.</span><span>type</span><span>(</span>STRING<span>)</span><span>.</span><span>description</span><span>(</span><span>"order menu name"</span><span>)</span><span>,</span>
                                <span>fieldWithPath</span><span>(</span><span>"order.quantity"</span><span>)</span><span>.</span><span>type</span><span>(</span>NUMBER<span>)</span><span>.</span><span>description</span><span>(</span><span>"order quantity"</span><span>)</span><span>)</span><span>,</span>
                        <span>responseFields</span><span>(</span>
                                <span>fieldWithPath</span><span>(</span><span>"order.menuName"</span><span>)</span><span>.</span><span>type</span><span>(</span>STRING<span>)</span><span>.</span><span>description</span><span>(</span><span>"order menu name"</span><span>)</span><span>,</span>
                                <span>fieldWithPath</span><span>(</span><span>"order.quantity"</span><span>)</span><span>.</span><span>type</span><span>(</span>NUMBER<span>)</span><span>.</span><span>description</span><span>(</span><span>"order quantity"</span><span>)</span><span>)</span>
                <span>)</span><span>)</span>
                
                <span>.</span><span>body</span><span>(</span>dto<span>)</span>
                <span>.</span><span>contentType</span><span>(</span>APPLICATION_JSON_VALUE<span>)</span>
                <span>.</span><span>when</span><span>(</span><span>)</span><span>.</span><span>post</span><span>(</span><span>"/orders"</span><span>)</span>
                <span>.</span><span>then</span><span>(</span><span>)</span><span>.</span><span>log</span><span>(</span><span>)</span><span>.</span><span>all</span><span>(</span><span>)</span>
                <span>.</span><span>extract</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p><strong>[ adoc 문서 작성 ]</strong></p>
<ul>
<li>common.adoc</li>
</ul>
<div><pre><code><span><span><span>[[</span>index<span>]]</span></span></span>
<span><span>===</span> <span><span>link</span><span>:</span>./index-docs.html<span><span>[</span><span>HOME</span><span>]</span></span></span></span>

<span><span><span>[[</span>common<span>]]</span></span></span>
<span><span>==</span> Common API Docs</span>

<span><span>===</span> HTTP Status Code</span>
<span><span>[</span><span>cols</span><span>=</span><span>"2,3,5"</span><span>]</span></span>
<span><span>|===</span>
<span>|</span> Code <span>|</span> Description <span>|</span> Constraint

<span>|</span> 200
<span>|</span> Success
<span>|</span>

<span>|</span> 400
<span>|</span> Bad Request
<span>|</span>
<span>|===</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>order.adoc</li>
</ul>
<div><pre><code><span><span>=</span> Order API</span>
<span>:doctype: book</span>
<span>:icons: font</span>
<span>:source-highlighter: highlightjs</span>
<span>:toc: left</span>
<span>:toclevels: 3</span>
<span>:sectlinks:</span>

<span><span>include</span><span>::</span>{docfile}/../common.adoc<span><span>[</span><span>]</span></span></span>

<span><span>==</span> Order API Docs</span>

<span><span>===</span> POST /orders</span>
Curl Request
<span><span>include</span><span>::</span>{snippets}/post-order/curl-request.adoc<span><span>[</span><span>]</span></span></span>

Request Headers

Path Parameters

Request Parameters

Request Fields
<span><span>include</span><span>::</span>{snippets}/post-order/request-fields.adoc<span><span>[</span><span>]</span></span></span>

Response Fields
<span><span>include</span><span>::</span>{snippets}/post-order/response-fields.adoc<span><span>[</span><span>]</span></span></span>

HTTP Request
<span><span>include</span><span>::</span>{snippets}/post-order/http-request.adoc<span><span>[</span><span>]</span></span></span>

HTTP Response
<span><span>include</span><span>::</span>{snippets}/post-order/http-response.adoc<span><span>[</span><span>]</span></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><br>
<h2 id="_1205-caffeine-cache"> 1205 - Caffeine Cache</h2>
<h3 id="caffeine-vs-ehcache"> Caffeine vs EhCache</h3>
<ul>
<li>Ehcache는 multi-level 캐시, distributed 캐시, 캐시 리스너 등과 같은 많은 기능을 지원한다.</li>
<li>Caffeine은 Ehcache보다 캐시의 성능이 높으며, 실제로 더 우수한 캐시 제거 전략을 사용한다.(Window TinyLfu 퇴출 정책을 사용, 거의 최적의 적중률을 제공)</li>
</ul>
<h3 id="caffeine-기능"> Caffeine 기능</h3>
<h4 id="population-strategy"> <strong>[ Population Strategy ]</strong></h4>
<p>캐시 추가 전략</p>
<p>Caffeine Cache는 아래의 세가지 타입의 캐시로 제작하여 사용할 수 있다.</p>
<ol>
<li>Manual</li>
</ol>
<blockquote>
<p>Cache&lt;K, V&gt; cache = Caffeine.newBuilder().build()</p>
</blockquote>
<p>엔트리를 자동 로드하는 캐시를 생성.</p>
<ol start="2">
<li>Loading (Synchronously)</li>
</ol>
<blockquote>
<p>LoadingCache&lt;K, V&gt; cache = Caffeine.newBuilder().build(CacheLoader&lt;&gt; loader)</p>
</blockquote>
<p>동기 방식으로 loader를 통해 캐시 생성한다.</p>
<ol start="3">
<li>Asynchronous Loading</li>
</ol>
<blockquote>
<p>AsyncLoadingCache&lt;K, V&gt; cache = Caffeine.newBuilder().buildAsync( ... );</p>
</blockquote>
<p>비동기 방식으로 loader를 통해 캐시 생성한다.</p>
<h4 id="eviction"> <strong>[ Eviction ]</strong></h4>
<p>Caffeine Cache는 아래의 세가지 타입으로 캐시를 Evict하는 설정을 할 수 있다.</p>
<ol>
<li>Size-based</li>
</ol>
<blockquote>
<p>Caffeine.newBuilder().maximumSize(long)</p>
</blockquote>
<p>크기 기준으로 캐시를 제거하는 방식은 개발자가 설정한 특정 값을 기준으로, entries의 크기가 그 값을 넘을 떄 entries의 일부분을 제거한다.(Window TinyLfu를 적용하여 가장 최근에 사용되지 않았거나, 자주 사용되어지지 않은 것을 제거)</p>
<ol start="2">
<li>Time-based</li>
</ol>
<blockquote>
<p>Caffeine.newBuilder().expireAfterAccess(long)<br>
Caffeine.newBuilder().expireAfterWrite(long[, TimeUnit])<br>
Caffeine.newBuilder().expireAfter(Expiry)</p>
</blockquote>
<ul>
<li>expireAfterAccess : (캐시 생성 이후) 해당 값이 가장 최근에 대체되거나 마지막으로 읽은 후 특정 기간이 지나면 각 항목이 캐시에서 자동으로 제거되도록 지정한다.</li>
<li>expireAfterWrite : 캐시 생성 후 또는 가장 최근에 바뀐 후 특정 기간이 지나면 각 항목이 캐시에서 자동으로 제거되도록 지정한다.</li>
<li>expireAfter : 캐시가 생성되거나 마지막으로 업데이트된 후 지정된 시간 간격으로 캐시를 새로 고침한다.</li>
</ul>
<ol start="3">
<li>Reference-based</li>
</ol>
<blockquote>
<p>Caffeine.newBuilder().weakKeys().weakValues()<br>
Caffeine.newBuilder().softValues()</p>
</blockquote>
<ul>
<li>
<p>Caffeine.weakKeys(), Caffeine.weakValues() : Week References를 사용하여 키를 저장한다. Week References는 키에 대한 다른 강력한 참조(Strong References)가 없는 경우 가비지 수집할 수 있다. 가비지 수집은 identity에만 의존하므로 전체 캐시가 동등성(.equals()) 대신 identity 동일성(==)을 사용하여 키를 비교한다.</p>
</li>
<li>
<p>Caffeine.softValues() : Soft References를 사용하여 값을 저장한다. Soft References 오브젝트는 메모리 수요에 따라 least-recently-used 방식으로 가비지가 수집된다. 소프트 레퍼런스를 사용하면 퍼포먼스가 영향을 받기 때문에 일반적으로 예측 가능한 최대 캐시 크기를 사용하는 것이 좋다. softValues()를 사용하면 Week References와 마찬가지로 값이 equals 대신 identity(==) equality를 사용하여 비교된다.</p>
</li>
</ul>
<h4 id="notification-of-removal"> <strong>[ Notification of Removal ]</strong></h4>
<p>제거되는 캐시 엔트리에 대해 리스너를 달아 추가적인 작업을 할 수 있다.</p>
<blockquote>
<p>Caffeine.newBuilder()<br>
.evictionListener((K, V, RemovalCause) -&gt; { /* ... <em>/ })<br>
.removalListener((K, V, RemovalCause) -&gt; { /</em> ... */ })<br>
.build();</p>
</blockquote>
<p>두 리스너의 차이는 캐시 관련 용어를 이해하면 적절히 사용할 수 있다.</p>
<ul>
<li>Eviction : 캐시 정책 Policy에 의한 삭제</li>
<li>Invalidation : Caller에 의한 수동 삭제</li>
<li>Removal : invalidation과 eviction, 두 가지를 모두 포함</li>
</ul>
<p>ex)</p>
<div><pre><code><span>Cache</span><span><span>&lt;</span><span>Key</span><span>,</span> <span>Graph</span><span>></span></span> graphs <span>=</span> <span>Caffeine</span><span>.</span><span>newBuilder</span><span>(</span><span>)</span>
    <span>.</span><span>evictionListener</span><span>(</span><span>(</span><span>Key</span> key<span>,</span> <span>Graph</span> graph<span>,</span> <span>RemovalCause</span> cause<span>)</span> <span>-></span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"Key %s was evicted (%s)%n"</span><span>,</span> key<span>,</span> cause<span>)</span><span>)</span>
    <span>.</span><span>removalListener</span><span>(</span><span>(</span><span>Key</span> key<span>,</span> <span>Graph</span> graph<span>,</span> <span>RemovalCause</span> cause<span>)</span> <span>-></span>
        <span>System</span><span>.</span>out<span>.</span><span>printf</span><span>(</span><span>"Key %s was removed (%s)%n"</span><span>,</span> key<span>,</span> cause<span>)</span><span>)</span>
    <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="compute"> <strong>[ Compute ]</strong></h4>
<p>외부 데이터(리소스)에 접근하며 캐시를 쓸 수 있다.</p>
<blockquote>
<p>graphs.asMap().compute(key, (k, v) -&gt; { /* ... */ });</p>
</blockquote>
<p>불러온 캐시 데이터를 Map으로 변경한 후 키를 차례로 조작할 수 있다.</p>
<div><pre><code>graphs<span>.</span><span>asMap</span><span>(</span><span>)</span><span>.</span><span>compute</span><span>(</span>key<span>,</span> <span>(</span>k<span>,</span> v<span>)</span> <span>-></span> <span>{</span>
  <span>Graph</span> graph <span>=</span> <span>createExpensiveGraph</span><span>(</span>key<span>)</span><span>;</span>
  <span>.</span><span>.</span><span>.</span> <span>// update a secondary store</span>
  <span>return</span> graph<span>;</span>
<span>}</span><span>)</span><span>;</span>

map<span>.</span><span>compute</span><span>(</span>key<span>,</span> <span>(</span>k<span>,</span> v<span>)</span> <span>-></span> <span>(</span>v <span>==</span> <span>null</span><span>)</span> <span>?</span> msg <span>:</span> v<span>.</span><span>concat</span><span>(</span>msg<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="statistics"> <strong>[ Statistics ]</strong></h4>
<p>캐시 액세스 통계 정보를 제공한다. 통계 정보를 사용하면 Caffeine.recordStats()를 설정해주면 된다.</p>
<p>Cache.stats() 메소드가 CacheStats를 반환해준다. CacheStats는 아래와 같은 내용을 가진다.</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>CacheStats</span> <span>{</span>

    <span>// ... </span>
    <span>private</span> <span>final</span> <span>long</span> hitCount<span>;</span>
    <span>private</span> <span>final</span> <span>long</span> missCount<span>;</span>
    <span>private</span> <span>final</span> <span>long</span> loadSuccessCount<span>;</span>
    <span>private</span> <span>final</span> <span>long</span> loadFailureCount<span>;</span>
    <span>private</span> <span>final</span> <span>long</span> totalLoadTime<span>;</span>
    <span>private</span> <span>final</span> <span>long</span> evictionCount<span>;</span>
    <span>private</span> <span>final</span> <span>long</span> evictionWeight<span>;</span>
    <span>// ... </span>
    <span>public</span> <span>double</span> <span>hitRate</span><span>(</span><span>)</span> <span>{</span><span>/* ... */</span><span>}</span>
    <span>public</span> <span>long</span> <span>evictionCount</span><span>(</span><span>)</span> <span>{</span><span>/* ... */</span><span>}</span>
    <span>public</span> <span>double</span> <span>averageLoadPenalty</span><span>(</span><span>)</span> <span>{</span><span>/* ... */</span><span>}</span>
    <span>// ... </span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="caffeine-configuration"> Caffeine Configuration</h3>
<ul>
<li>dependency</li>
</ul>
<div><pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
  &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
  &lt;version&gt;3.0.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>yml</li>
</ul>
<div><pre><code><span>spring</span><span>:</span>
  <span>cache</span><span>:</span>
    <span>caffeine</span><span>:</span>
      <span>spec</span><span>:</span> maximumSize=500<span>,</span>expireAfterWrite=5s
    <span>type</span><span>:</span> caffeine
    <span>cache-names</span><span>:</span>
      <span>-</span> users
      <span>-</span> books
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>@configuration</li>
</ul>
<div><pre><code><span>@Configuration</span>
<span>@EnableCaching</span>
<span>public</span> <span>class</span> <span>CaffeineCacheConfig</span> <span>{</span> <span>/* ... */</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ex)</p>
<div><pre><code><span>@EnableCaching</span>
<span>@Configuration</span>
<span>public</span> <span>class</span> <span>CacheConfig</span> <span>{</span>

    <span>@Bean</span>
    <span>public</span> <span>Caffeine</span> <span>caffeineConfig</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>Caffeine</span>
                <span>.</span><span>newBuilder</span><span>(</span><span>)</span>
                <span>.</span><span>maximumSize</span><span>(</span><span>10_000</span><span>)</span>
                <span>.</span><span>expireAfterWrite</span><span>(</span><span>60</span><span>,</span> <span>TimeUnit</span><span>.</span>MINUTES<span>)</span><span>;</span>
    <span>}</span>

    <span>@Bean</span>
    <span>public</span> <span>CacheManager</span> <span>cacheManager</span><span>(</span><span>Caffeine</span> caffeine<span>)</span> <span>{</span>
        <span>CaffeineCacheManager</span> cacheManager <span>=</span> <span>new</span> <span>CaffeineCacheManager</span><span>(</span><span>)</span><span>;</span>
        cacheManager<span>.</span><span>setCaffeine</span><span>(</span>caffeine<span>)</span><span>;</span>
        <span>return</span> cacheManager<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><br>
<h2 id="_1209-java-17"> 1209 - Java 17</h2>
<ul>
<li>2021년 9월 출시</li>
<li>LTS(Long Term Support)
<ul>
<li>2018년에 등장한 11버전 이후의 새로운 LTS버전
<ul>
<li>(Java 8의 종료 일정(EOL, End of Life)이 Java 11보다 뒤다)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="jdk-17-release-notes"> JDK 17 Release Notes</h3>
<h4 id="jep-356-enhanced-pseudo-random-number-generators"> <strong>[ JEP 356: Enhanced Pseudo-Random Number Generators ]</strong></h4>
<p>기본 레거시 랜덤(Java.util.Random) 클래스를 확장, 리팩토링한 <code>RandomGenerator</code> 난수 생성 API가 추가 되었다. 아래와 같은 코드로 자바 17에서 사용 가능한 알고리즘을 확인할 수 있다.</p>
<div><pre><code><span>RandomGeneratorFactory</span><span>.</span><span>all</span><span>(</span><span>)</span>
	<span>.</span><span>map</span><span>(</span>factory <span>-></span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"%s: %s"</span><span>,</span> factory<span>.</span><span>group</span><span>(</span><span>)</span><span>,</span> factory<span>.</span><span>name</span><span>(</span><span>)</span><span>)</span><span>)</span>
	<span>.</span><span>sorted</span><span>(</span><span>)</span>
	<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>LXM: L128X1024MixRandom
LXM: L128X128MixRandom
LXM: L128X256MixRandom
LXM: L32X64MixRandom
LXM: L64X1024MixRandom
LXM: L64X128MixRandom
LXM: L64X128StarStarRandom
LXM: L64X256MixRandom
Legacy: Random
Legacy: SecureRandom
Legacy: SplittableRandom
Xoroshiro: Xoroshiro128PlusPlus
Xoshiro: Xoshiro256PlusPlus
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="jep-382-new-macos-rendering-pipeline"> <strong>[ JEP 382: New macOS Rendering Pipeline ]</strong></h4>
<p>애플사에서 기존의 OpenGL이 아닌 Metal 이라는 새로운 렌더링 API로 대체하는 움직임에 맞춘 대응이다. 향후 MacOS 버전에서 OpenGL API를 제거하는 경우를 대비하기 위함이다. 코드 사용과 직접적인 관련은 없겠으나, MacOS에서 인텔리제이 IDE의 렌더링이 개선되지 않을까 하는 기대가 있다.</p>
<h4 id="jep-398-deprecate-the-applet-api-for-removal"> <strong>[ JEP 398: Deprecate the Applet API for Removal ]</strong></h4>
<p>애플릿(Applet) API는 자바 9에서부터 이미 @Deprecated 선언되었는데, 이번 버전에서는 forRemoval 태깅도 선언되었다.</p>
<div><pre><code><span>@Deprecated</span><span>(</span>since <span>=</span> <span>"9"</span><span>,</span> forRemoval <span>=</span> <span>true</span><span>)</span>
<span>@SuppressWarnings</span><span>(</span><span>"removal"</span><span>)</span>
<span>public</span> <span>class</span> <span>Applet</span> <span>extends</span> <span>Panel</span> <span>{</span>
	<span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="jep-403-strongly-encapsulate-jdk-internals"> <strong>[ JEP 403: Strongly Encapsulate JDK Internals ]</strong></h4>
<p>중요한 내부 API를 제외하고는 JDK의 모든 내부 요소를 강력하게 캡슐화한다. 아래와 같은 리플렉션 코드가 더 이상 동작하지 않는다.</p>
<div><pre><code><span>var</span> ks <span>=</span> <span><span>java<span>.</span>security<span>.</span></span>KeyStore</span><span>.</span><span>getInstance</span><span>(</span><span>"jceks"</span><span>)</span><span>;</span>
<span>var</span> f <span>=</span> ks<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"keyStoreSpi"</span><span>)</span><span>;</span>
f<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="jep-406-pattern-matching-for-switch-preview"> <strong>[ JEP 406: Pattern Matching for switch (Preview) ]</strong></h4>
<blockquote>
<p>자바 14부터 등장했던 내용인데 아직까지 프리뷰(Preview) 기능이다. 실행하려면 명령어 옵션 추가가 필요하다. (Intellij에서는 Language Level 설정을 변경하면 된다.)</p>
</blockquote>
<p>아래 예시처럼 <code>instanceof</code>를 사용할 때 캐스팅하는 단계를 간소화할 수 있다.</p>
<div><pre><code><span>// AS-IS: 기존의 instanceof 연산자 사용. 캐스팅이 들어간다.</span>
<span>if</span> <span>(</span>o <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
    <span>String</span> s <span>=</span> <span>(</span><span>String</span><span>)</span> str<span>;</span>
    <span>// ... 변수 s를 사용하는 코드</span>
<span>}</span>

<span>// TO-BE: 형변환 과정을 없애고, 그 변수('s')를 담을 수 있다.</span>
<span>if</span> <span>(</span>o <span>instanceof</span> <span>String</span> s<span>)</span> <span>{</span>
    <span>// ... 변수 s를 사용하는 코드</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>그리고 <code>null</code>에 대해서도 조금 더 간편하게 핸들링할 수 있다.</p>
<div><pre><code><span>// 기존</span>
<span>static</span> <span>void</span> <span>someMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>s <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"null!"</span><span>)</span><span>;</span>
        <span>return</span><span>;</span>
    <span>}</span>

    <span>switch</span> <span>(</span>s<span>)</span> <span>{</span>
        <span>case</span> <span>"kim"</span><span>,</span> <span>"taeng"</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello~"</span><span>)</span><span>;</span>
        <span>default</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Wow!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 변경</span>
<span>static</span> <span>void</span> <span>someMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
    <span>switch</span> <span>(</span>s<span>)</span> <span>{</span>
        <span>case</span> <span>null</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"null!"</span><span>)</span><span>;</span>
        <span>case</span> <span>"kim"</span><span>,</span> <span>"taeng"</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello~"</span><span>)</span><span>;</span>
        <span>default</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Wow!"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>더 나아가 <code>switch</code>문을 위한 패턴 매칭을 적용할 수 있다. 아래와 같은 형태의 <code>switch</code>코드를 작성할 수 있는데, 파라미터 <code>o</code>값은 <code>Long l</code>에 매칭되어 코드가 실행된다.</p>
<div><pre><code><span>Object</span> o <span>=</span> <span>123L</span><span>;</span>
<span>String</span> formatted <span>=</span> <span>switch</span> <span>(</span>o<span>)</span> <span>{</span>
    <span>case</span> <span>Integer</span> i <span>-></span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"int %d"</span><span>,</span> i<span>)</span><span>;</span>
    <span>case</span> <span>Long</span> l <span>-></span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"long %d"</span><span>,</span> l<span>)</span><span>;</span>
    <span>case</span> <span>Double</span> d <span>-></span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"double %f"</span><span>,</span> d<span>)</span><span>;</span>
    <span>case</span> <span>String</span> s <span>-></span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"String %s"</span><span>,</span> s<span>)</span><span>;</span>
    <span>default</span> <span>-></span> o<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="jep-407-remove-rmi-activation"> <strong>[ JEP 407: Remove RMI Activation ]</strong></h4>
<p>RMI 일부 기능(java.rmi.activation 패키지)이 제거됨.</p>
<h4 id="jep-409-sealed-classes"> <strong>[ JEP 409: Sealed Classes ]</strong></h4>
<p>자바에서는 상속을 통해서 코드를 재사용할 수 있찌만 너무 부분별한 상속은 코드를 이해하는데 더 어려움을 줄 수 있다. 따라서 상속을 일부 제한하는 방법이 제안되었다. JEP 스펙 문서를 보면 알 수 있듯이 새로운 패러다임이기 때문에 조금 복잡하다. 내용 또한 여러 버전에 거쳐서 Preview로 소개 되었다,</p>
<ul>
<li><a href="https://openjdk.org/jeps/360" target="_blank" rel="noopener noreferrer">JDK 15에서 Preview로 제안(JEP 360)<i>Content not supported</i></a></li>
<li><a href="https://openjdk.org/jeps/397" target="_blank" rel="noopener noreferrer">JDK 16에서 Second Preview로 수정제안(JEP 397)<i>Content not supported</i></a></li>
</ul>
<p>핵심은 &quot;확장(extends) 하거나 구현(implements) 할 수 있는 클래스 또는 인터페이스를 제한한다.&quot;라고 생각 하면 된다. 보통 우리 말로는 봉인 클래스 또는 봉인된 클래스로 표기한다. 이제 상속, 구현에 이은 <code>봉인</code>이라는 단어도 사용될거라 예측.</p>
<p>기존에는 상속을 제한하는 방법은 final 키워드를 통해서 사용.</p>
<div><pre><code><span>class</span> <span>Person</span> <span>{</span>
<span>}</span>

<span>// `Developer` 클래스는 확장/상속(extends)할 수 없다.</span>
<span>final</span> <span>class</span> <span>Developer</span> <span>extends</span> <span>Person</span> <span>{</span>
<span>}</span>

<span>// `Designer` 클래스는 확장/상속(extends)할 수 없다.</span>
<span>final</span> <span>class</span> <span>Designer</span> <span>extends</span> <span>Person</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>이번에는 다른 컨셉으로, 특정 서브 클래스에게만 확장을 허용하고 다른 클래스에는 봉인(sealed)하는 방법.</p>
<div><pre><code><span>// `Person`는 허용된(permits) 서브 클래스만 확장할 수 있다.</span>
<span>sealed</span> <span>class</span> <span>Person</span>
    <span>permits</span> <span>Developer</span><span>,</span> <span>Designer</span> <span>{</span>
<span>}</span>

<span>// `Developer` 클래스는 봉인이 해제되었다.</span>
<span>non-sealed</span> <span>class</span> <span>Developer</span> <span>extends</span> <span>Person</span> <span>{</span>

<span>}</span>

<span>// 봉인이 해제된 `Student` 클래스는 다른 서브 클래스에서 확장 가능하다.</span>
<span>// 그리고 자기 자신을 Developer 봉인(sealed)할 수 있다. </span>
<span>sealed</span> <span>class</span> <span>Student</span> <span>extends</span> <span>Developer</span> 
    <span>permits</span> <span>HighSchoolStudent</span><span>,</span> <span>MiddleSchoolStudent</span> <span>{</span>
    <span>// 이 클래스는 `HighSchoolStudent`, `MiddleSchoolStudent` 클래스만 확장 가능하다.</span>
<span>}</span>

<span>// permitted 서브 클래스는 확장을 못하게 하거나(final),</span>
<span>// 서브 클래스를 가진채로 자신을 봉인하거나(sealed), 봉인을 해제(non-sealed)해야만 한다.</span>
<span>final</span> <span>class</span> <span>HighSchoolStudent</span> <span>extends</span> <span>Student</span> <span>{</span>

<span>}</span>

<span>non-sealed</span> <span>class</span> <span>MiddleSchoolStudent</span> <span>extends</span> <span>Student</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>봉인 클래스를 사용하려면 아래와 같은 몇가지 규칙이 있다.</p>
<ul>
<li>sealed 클래스와 permitted된 서브 클래스와 동일한 모듈 또는 패키지에 속해야한다.</li>
<li>모든 permitted 서브 클래스는 sealed 클래스를 확장(extends)해야 한다. 그렇지 않으면 컴파일 오류가 발생한다.</li>
<li>모든 permitted 서브 클래스는 수퍼 클래스에 의해 시작된 봉인을 계속할지 말지 선언해야한다.
<ul>
<li>더이상 확장되지 않도록 final을 적용할 수 있다.</li>
<li>non-sealed로 선언하여 다른 클래스가 확장하도록 할 수 있다.</li>
<li>자기 자신도 봉인(sealed) 클래스로 선언될 수 있다.</li>
</ul>
</li>
</ul>
<h4 id="jep-410-remove-the-experimental-aot-and-jit-compiler"> <strong>[ JEP 410: Remove the Experimental AOT and JIT Compiler ]</strong></h4>
<p>AOT(Ahead-Of-Time), JIT(Just-In-Time) 컴파일러가 제거되었다. 대상은 <code>jdk.aot</code>, <code>jdk.internal.vm.compilerm</code>, <code>jdk.internal.vm.compiler.management</code> 이다.</p>
<h4 id="jep-411-deprecate-the-security-manager-for-removal"> <strong>[ JEP 411: Deprecate the Security Manager for Removal ]</strong></h4>
<p><code>java.lang.SecurityManager</code>와 일부 클래스에 <code>@Deprecated(forRemoval=true)</code>가 선언됨.</p>
<blockquote>
<p>자바 14버전 Preview 중 몇 가지가 정식 반영</p>
</blockquote>
<h4 id="jep-359-records"> <strong>[ JEP 359: Records ]</strong></h4>
<p><code>record</code>는 자바 16에서 스펙이 확정되어 정식 추가됨.</p>
<div><pre><code><span>record</span> <span>RecordPoint</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span>
    <span>// 상속 불가(final 클래스)</span>

    <span>// 각 필드는 private final. 수정 불가</span>
    <span>// x = 5;</span>

    <span>// serialize 할 때는? 필드에 `@JsonProperty`를 붙여준다.</span>

    <span>// static 필드와 메서드 소유 가능</span>
    <span>static</span> <span>int</span> MAX_LENGTH <span>=</span> <span>25</span><span>;</span>

    <span>public</span> <span>static</span> <span>int</span> <span>getMaxLength</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> MAX_LENGTH<span>;</span>
    <span>}</span>
<span>}</span>

<span>// 사용할 때는? 클래스와 동일하게 `new` 연산자로 인스턴스화한다.</span>
<span>RecordPoint</span> recordPoint <span>=</span> <span>new</span> <span>RecordPoint</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>

<span>// 그런데 getter가 자동 생성!</span>
recordPoint<span>.</span><span>x</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h4 id="jep-378-text-blocks"> <strong>[ JEP 378: Text Blocks ]</strong></h4>
<p>JDK 15에 정식 포함.</p>
<div><pre><code><span>private</span> <span>void</span> <span>runJEP368</span><span>(</span><span>)</span> <span>{</span>
    <span>String</span> html <span>=</span> <span>"""
            {
                "list": [
                    {
                        "title": "hello, taeng",
                        "author": "taeng"
                    },
                    {
                        "title": "hello, news",
                        "author": "taeng"
                    }
                ]
            }
            """</span><span>.</span><span>indent</span><span>(</span><span>2</span><span>)</span><span>;</span>
    <span>// indent 는 자바 12에서 추가된 것인데, 문자열 각 맨 앞 행을 n만큼 띄운다.</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>html<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ul>
<li>변수 매핑</li>
</ul>
<div><pre><code><span>String</span> textBlock <span>=</span> <span>"""
        {
            "title": %s,
            "author": %s,
            "id": %d
        }
        """</span><span>.</span><span>formatted</span><span>(</span><span>"hi"</span><span>,</span> <span>"taeng"</span><span>,</span> <span>2</span><span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>textBlock<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1114 ~ 1127</title>
      <link>ahnjs/TIL/2022/1114/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/1114/</guid>
      <source url="ahnjs/TIL/rss.xml">1114 ~ 1127</source>
      <pubDate>Sun, 13 Nov 2022 15:04:31 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1114-1127"> 1114 ~ 1127</h1>
<h2 id="_1114-도메인-주도-설계의-모듈-구성-패키지-구성"> 1114 - 도메인 주도 설계의 모듈 구성(패키지 구성)</h2>
<h3 id="계층-기반-패키지"> 계층 기반 패키지</h3>
<p>가장 단순한 첫번째 설계원칙인 수평 계층형 아키텍처</p>
<ul>
<li>기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할. 보통 웹베이스 코딩을 하게 되면 <code>MVC</code>, <code>MVP</code> 패턴으로 개발을 하게 되는데 이도 <code>계층 기반 패키지</code>라고 부르며 각 계층은 유사한 종류의 것들을 묶는 도구로 사용</li>
<li>이 전형적인 아키텍처에서는 <code>사용 인터페이스</code>, <code>업무규칙</code>, <code>영속성코드</code>를 계층이 각각 하나씩 존재하며, 임의의 N계층은 반드시 N+1계층에만 의존 해야한다.</li>
</ul>
<h3 id="기능-도메인-기반-패키지"> 기능(도메인) 기반 패키지</h3>
<p>기능 기반 패키지는 서로 연관된 기능, 도메인 개념 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식.<br>
특정 기능을 지칭하는 하나의 패키지 내에 모든 타입과, 개념을 반영해서 구현.</p>
<ul>
<li>인터페이스와 클래스가 모두 단 하나의 패키지에 속한다. 이로 인해 코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게 된다. 따라서 이 코드베이스가 계층단위(웹, 서비스, 리포지토리)가 아니라 주문(업무 도메인)과 관련된 무언가를 한다는 것을 볼 수 있다.</li>
<li>변경시 변경해야 할 코드가 모두 한 패키지 내에 응집력을 갖고 있기때문에 유리하다.</li>
</ul>
<h3 id="포트와-어댑터"> 포트와 어댑터</h3>
<p>엉클 밥에 따르면 <code>포트와 어댑터</code> 혹은 <code>육각형 아키텍처</code>, <code>경계, 컨트롤러, 엔티티</code> 등의 방식으로 접근하는 이유는 업무/도메인에 초점을 둔 코드가 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해서이다.</p>
<p>'내부' 영역은 도메인 개념을 모두 포함하는 반면, '외부'영역은 UI, 데이터베이스, 서드파티등과의 상호작용을 포함한다. 여기서 중요한 규칙은 '외부'가 '내부'에 의존하며, 그 반대는 불가능하다.</p>
<ul>
<li>도메인 주도 설계에서는 OrderRepository는 Orders라는 명칭으로 바꿔줘야 한다. 그 이유는 도메인에 대해 논의할때 '주문'에 대해 말하는것이지 '주문 리포지토리'에 대해 말하는 것이 아니기 때문이다.</li>
</ul>
<h3 id="컴포넌트-기반-패키지"> 컴포넌트 기반 패키지</h3>
<p>컴포넌트 기반 패키지는 마틴 파울러가 제시하는 방법으로, 지금까지 방식을 혼합한 것으로 큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 패키지로 묶는데 주안점을 두고 있다.<br>
이 접근법은 서비스 중심적인 시각으로 소프트웨어 시스템을 바라 보며, 마이크로서비스 아키텍처가 가진 시각과도 동일하다.</p>
<ul>
<li>여기서 말하는 '컴포넌트'에 대해 마틴파울러는 &quot;컴포넌트는 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음으로, 애플리케이션과 같은 실행 환경 내부에 존재한다.&quot;로 정의하고 있다.</li>
<li>컴포넌트 기반 패키지 접근법의 주된 이점은 주문과 관련된 무언가를 코딩해야 할 때 오직, OrdersComponent만 둘러보면 된다는 점이다. 이 컴포넌트 내부에서 관심사의 분리는 여전히 유효하며, 컴포넌트 구현과 관련된 세부사항은 사용자가 알 필요가 없다.</li>
<li>이는 마이크로 서비스나 서비스 지향 아키텍처를 적용했을 때 얻는 이점과도 유사하다. 따라서 모노리틱 애플리케이션에서 컴포넌트를 잘 정의하면 결합 분리 모드를 통해 마이크로 서비스 아키텍처로 가기 위한 발판으로 삼을 수 있다.</li>
</ul>
<br>
<h2 id="_1116-spring-security-without-the-websecurityconfigureradapter"> 1116 - Spring Security without the WebSecurityConfigurerAdapter</h2>
<p>Spring Security 5.7.0-M2 부터는 구성 요소 기반 보안 설정으로 변경된다. 따라서 <code>WebSecurityConfigurerAdapter</code> 상속 후, configure 메소드를 오버라이딩 하여 설정하는 방식에서 <code>SecurityFilterChain</code>를 빈으로 등록하는 방식을 권장한다.</p>
<h3 id="httpsecurity-구성-비교"> HttpSecurity 구성 비교</h3>
<ul>
<li>WebSecurityConfigurerAdapter의 configure 메소드를 오버라이딩</li>
</ul>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>SecurityConfiguration</span> <span>extends</span> <span>WebSecurityConfigurerAdapter</span> <span>{</span>

    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>configure</span><span>(</span><span>HttpSecurity</span> http<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        http
            <span>.</span><span>authorizeHttpRequests</span><span>(</span><span>(</span>authz<span>)</span> <span>-></span> authz
                <span>.</span><span>anyRequest</span><span>(</span><span>)</span><span>.</span><span>authenticated</span><span>(</span><span>)</span>
            <span>)</span>
            <span>.</span><span>httpBasic</span><span>(</span><span>withDefaults</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>
<li>SecurityFilterChain 빈 등록</li>
</ul>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>SecurityConfiguration</span> <span>{</span>

    <span>@Bean</span>
    <span>public</span> <span>SecurityFilterChain</span> <span>filterChain</span><span>(</span><span>HttpSecurity</span> http<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        http
            <span>.</span><span>authorizeHttpRequests</span><span>(</span><span>(</span>authz<span>)</span> <span>-></span> authz
                <span>.</span><span>anyRequest</span><span>(</span><span>)</span><span>.</span><span>authenticated</span><span>(</span><span>)</span>
            <span>)</span>
            <span>.</span><span>httpBasic</span><span>(</span><span>withDefaults</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> http<span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="ldap란"> LDAP란?</h3>
<p>LDAP(Lightweight Directory Access Protocol)란, 네트워크 상에서 조직이나 개인정보 혹은 파일이나 디바이스 정보 등을 찾아보는 것을 가능하게 만든 소프트웨어 프로토콜이다.</p>
<h3 id="jdbc-인증-설정-비교"> JDBC 인증 설정 비교</h3>
<ul>
<li>WebSecurityConfigurerAdapter 상속, configure(AuthenticationManagerBuilder auth) 메소드 오버라이딩하여 설정</li>
</ul>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>SecurityConfiguration</span> <span>extends</span> <span>WebSecurityConfigurerAdapter</span> <span>{</span>
    <span>@Bean</span>
    <span>public</span> <span>DataSource</span> <span>dataSource</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>EmbeddedDatabaseBuilder</span><span>(</span><span>)</span>
            <span>.</span><span>setType</span><span>(</span><span>EmbeddedDatabaseType</span><span>.</span>H2<span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>configure</span><span>(</span><span>AuthenticationManagerBuilder</span> auth<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>UserDetails</span> user <span>=</span> <span>User</span><span>.</span><span>withDefaultPasswordEncoder</span><span>(</span><span>)</span>
            <span>.</span><span>username</span><span>(</span><span>"user"</span><span>)</span>
            <span>.</span><span>password</span><span>(</span><span>"password"</span><span>)</span>
            <span>.</span><span>roles</span><span>(</span><span>"USER"</span><span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
        auth<span>.</span><span>jdbcAuthentication</span><span>(</span><span>)</span>
            <span>.</span><span>withDefaultSchema</span><span>(</span><span>)</span>
            <span>.</span><span>dataSource</span><span>(</span><span>dataSource</span><span>(</span><span>)</span><span>)</span>
            <span>.</span><span>withUser</span><span>(</span>user<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>JdbcUserDetailsManager 빈을 등록하는 방식</li>
</ul>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>SecurityConfiguration</span> <span>{</span>
    <span>@Bean</span>
    <span>public</span> <span>DataSource</span> <span>dataSource</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>EmbeddedDatabaseBuilder</span><span>(</span><span>)</span>
            <span>.</span><span>setType</span><span>(</span><span>EmbeddedDatabaseType</span><span>.</span>H2<span>)</span>
            <span>.</span><span>addScript</span><span>(</span><span>JdbcDaoImpl</span><span>.</span>DEFAULT_USER_SCHEMA_DDL_LOCATION<span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Bean</span>
    <span>public</span> <span>UserDetailsManager</span> <span>users</span><span>(</span><span>DataSource</span> dataSource<span>)</span> <span>{</span>
        <span>// 이 예에서는 User.withDefaultPasswordEncoder()가독성을 위해 방법을 사용</span>
        <span>UserDetails</span> user <span>=</span> <span>User</span><span>.</span><span>withDefaultPasswordEncoder</span><span>(</span><span>)</span>
            <span>.</span><span>username</span><span>(</span><span>"user"</span><span>)</span>
            <span>.</span><span>password</span><span>(</span><span>"password"</span><span>)</span>
            <span>.</span><span>roles</span><span>(</span><span>"USER"</span><span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
        <span>JdbcUserDetailsManager</span> users <span>=</span> <span>new</span> <span>JdbcUserDetailsManager</span><span>(</span>dataSource<span>)</span><span>;</span>
        users<span>.</span><span>createUser</span><span>(</span>user<span>)</span><span>;</span>
        <span>return</span> users<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>https://blog.naver.com/PostView.naver?blogId=h850415&amp;logNo=222755455272&amp;parentCategoryNo=&amp;categoryNo=37&amp;viewDate=&amp;isShowPopularPosts=true&amp;from=search<br>
https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter</p>
<br>
<h2 id="_1123-spring-security-구조"> 1123 - Spring Security 구조</h2>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbeDENY%2FbtrBs0cquNc%2FPkwRQzgyzhoy1ecQrlQOJk%2Fimg.png" alt="image"></p>
<h3 id="spring-security-주요-모듈"> Spring Security 주요 모듈</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAbFLx%2FbtqEJC1tYaJ%2FBDq9cRTqiDarlBa3Z05FoK%2Fimg.png" alt="image"></p>
<h4 id="security-contextholder"> <strong>[ Security ContextHolder ]</strong></h4>
<p>SecurityContextHolder는 보안 주체의 세부 정보를 포함하여 응용프로그램의 현재 보안 컨텍스트에 대한 세부 정보가 저장된다. SecurityContextHolder는 기본적으로 SecurityContextHolder.MODE_INHERITABLETHREADLOCAL 방법과 SecurityContextHolder.MODE_THREADLOCAL 방법을 제공한다.</p>
<h4 id="securitycontext"> <strong>[ SecurityContext ]</strong></h4>
<p>Authentication을 보관하는 역할을 하며, SecurityContext를 통해 Authentication 객체를 꺼내올 수 있다.</p>
<h4 id="authentication"> <strong>[ Authentication ]</strong></h4>
<p>Authentication는 현재 접근하는 주체의 정보와 권한을 담는  인터페이스이다. Authentication 객체는 Security Context에 저장되며, SecurityContextHolder를 통해 SecurityContext에 접근하고, SecurityContext를 통해 Authentication에 접근할 수 있다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Authentication</span> <span>extends</span> <span>Principal</span><span>,</span> <span>Serializable</span> <span>{</span>  
    <span>// 현재 사용자의 권한 목록을 가져옴  </span>
    <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>GrantedAuthority</span><span>></span></span> <span>getAuthorities</span><span>(</span><span>)</span><span>;</span>  
  
    <span>// credentials(주로 비밀번호)을 가져옴  </span>
    <span>Object</span> <span>getCredentials</span><span>(</span><span>)</span><span>;</span>  
  
    <span>Object</span> <span>getDetails</span><span>(</span><span>)</span><span>;</span>  
  
    <span>// Principal 객체를 가져옴.  </span>
    <span>Object</span> <span>getPrincipal</span><span>(</span><span>)</span><span>;</span>  
  
    <span>// 인증 여부를 가져옴  </span>
    <span>boolean</span> <span>isAuthenticated</span><span>(</span><span>)</span><span>;</span>  
  
    <span>// 인증 여부를 설정함  </span>
    <span>void</span> <span>setAuthenticated</span><span>(</span><span>boolean</span> isAuthenticated<span>)</span> <span>throws</span> <span>IllegalArgumentException</span><span>;</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="usernamepasswordauthenticationtoken"> <strong>[ UsernamePasswordAuthenticationToken ]</strong></h4>
<p>UsernamePasswordAuthenticationToken은 Authentication을 implements한 AbstractAuthenticationToken의 하위 클래스로, User의 ID가 Principal 역할을 하고, Password가 Credential의 역할을 한다. UsernamePasswordAuthenticationToken의 첫 번째 생성자는 인증전의 객체를 생성하고, 두번째 생성자는 인증이 완료된 객체를 생성한다.</p>
<div><pre><code><span>public</span> <span>class</span> <span>UsernamePasswordAuthenticationToken</span> <span>extends</span> <span>AbstractAuthenticationToken</span> <span>{</span>  
    <span>// 주로 사용자의 ID에 해당함  </span>
    <span>private</span> <span>final</span> <span>Object</span> principal<span>;</span>  
    <span>// 주로 사용자의 PW에 해당함  </span>
    <span>private</span> <span>Object</span> credentials<span>;</span>  
  
    <span>// 인증 완료 전의 객체 생성  </span>
    <span>public</span> <span>UsernamePasswordAuthenticationToken</span><span>(</span><span>Object</span> principal<span>,</span> <span>Object</span> credentials<span>)</span> <span>{</span>  
        <span>super</span><span>(</span><span>null</span><span>)</span><span>;</span>  
        <span>this</span><span>.</span>principal <span>=</span> principal<span>;</span>  
        <span>this</span><span>.</span>credentials <span>=</span> credentials<span>;</span>  
        <span>setAuthenticated</span><span>(</span><span>false</span><span>)</span><span>;</span>  
    <span>}</span>  
  
    <span>// 인증 완료 후의 객체 생성  </span>
    <span>public</span> <span>UsernamePasswordAuthenticationToken</span><span>(</span><span>Object</span> principal<span>,</span> <span>Object</span> credentials<span>,</span>  
                                               <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>GrantedAuthority</span><span>></span></span> authorities<span>)</span> <span>{</span>  
        <span>super</span><span>(</span>authorities<span>)</span><span>;</span>  
        <span>this</span><span>.</span>principal <span>=</span> principal<span>;</span>  
        <span>this</span><span>.</span>credentials <span>=</span> credentials<span>;</span>  
        <span>super</span><span>.</span><span>setAuthenticated</span><span>(</span><span>true</span><span>)</span><span>;</span> <span>// must use super, as we override  </span>
    <span>}</span>  
<span>}</span>  
  
  
<span>public</span> <span>abstract</span> <span>class</span> <span>AbstractAuthenticationToken</span> <span>implements</span> <span>Authentication</span><span>,</span> <span>CredentialsContainer</span> <span>{</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h4 id="authenticationprovider"> <strong>[ AuthenticationProvider ]</strong></h4>
<p>AuthentivationProvider에서는 실제 인증에 대한 부분을 처리하는데, 인증 전의 Authentication 객체를 받아서 인증이 완료된 객체를 반환하는 역할을 한다. 아래와 같은 AuthenticationProvider 인터페이스를 구현해서 Custom한 AuthenticationProvider을 작성해서 AuthenticationManager에 등록하면 된다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>AuthenticationProvider</span> <span>{</span>  
  
    <span>// 인증 전의 Authenticaion 객체를 받아서 인증된 Authentication 객체를 반환  </span>
    <span>Authentication</span> <span>authenticate</span><span>(</span><span>Authentication</span> var1<span>)</span> <span>throws</span> <span>AuthenticationException</span><span>;</span>  
  
    <span>boolean</span> <span>supports</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> var1<span>)</span><span>;</span>  
  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="authentication-manager"> <strong>[ Authentication Manager ]</strong></h4>
<p>인증에 대한 부분은 SpringSecurity의 AuthenticationManager를 통해서 처리하게 되는데, 실질적으로는 AuthenticationManager에 등록된 AuthenticationProvider에 의해 처리된다. 인증이 성공하면 2번째 생성자를 이용해 인증이 성공한(isAuthenticated=true)객체를 생성하여 Security Context에 저장한다. 그리고 인증 상태를 유지하기 위해 세션에 보관하며, 인증이 실패한 경우에는 AuthenticationException를 발생시킨다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>AuthenticationManager</span> <span>{</span>  
    <span>Authentication</span> <span>authenticate</span><span>(</span><span>Authentication</span> authentication<span>)</span>  
            <span>throws</span> <span>AuthenticationException</span><span>;</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>AuthenticationManager를 implements한 ProviderManager는 실제 인증 과정에 대한 로직을 가지고 있는 AuthenticationProvider를 List로 가지고 있으며, ProviderManager는 for문을 통해 모든 provider를 조회하면서 authenticate 처리를 한다.</p>
<div><pre><code><span>public</span> <span>class</span> <span>ProviderManager</span> <span>implements</span> <span>AuthenticationManager</span><span>,</span> <span>MessageSourceAware</span><span>,</span>  
        <span>InitializingBean</span> <span>{</span>  
    <span>public</span> <span>List</span><span><span>&lt;</span><span>AuthenticationProvider</span><span>></span></span> <span>getProviders</span><span>(</span><span>)</span> <span>{</span>  
        <span>return</span> providers<span>;</span>  
    <span>}</span>  
    <span>public</span> <span>Authentication</span> <span>authenticate</span><span>(</span><span>Authentication</span> authentication<span>)</span>  
            <span>throws</span> <span>AuthenticationException</span> <span>{</span>  
        <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Authentication</span><span>></span></span> toTest <span>=</span> authentication<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>  
        <span>AuthenticationException</span> lastException <span>=</span> <span>null</span><span>;</span>  
        <span>Authentication</span> result <span>=</span> <span>null</span><span>;</span>  
        <span>boolean</span> debug <span>=</span> logger<span>.</span><span>isDebugEnabled</span><span>(</span><span>)</span><span>;</span>  
        <span>//for문으로 모든 provider를 순회하여 처리하고 result가 나올 때까지 반복한다.  </span>
        <span>for</span> <span>(</span><span>AuthenticationProvider</span> provider <span>:</span> <span>getProviders</span><span>(</span><span>)</span><span>)</span> <span>{</span>  
        <span>.</span><span>.</span><span>.</span><span>.</span>  
            <span>try</span> <span>{</span>  
                result <span>=</span> provider<span>.</span><span>authenticate</span><span>(</span>authentication<span>)</span><span>;</span>  
  
                <span>if</span> <span>(</span>result <span>!=</span> <span>null</span><span>)</span> <span>{</span>  
                    <span>copyDetails</span><span>(</span>authentication<span>,</span> result<span>)</span><span>;</span>  
                    <span>break</span><span>;</span>                <span>}</span>  
            <span>}</span>  
            <span>catch</span> <span>(</span><span>AccountStatusException</span> e<span>)</span> <span>{</span>  
                <span>prepareException</span><span>(</span>e<span>,</span> authentication<span>)</span><span>;</span>  
                <span>// SEC-546: Avoid polling additional providers if auth failure is due to  </span>
                <span>// invalid account status                throw e;  </span>
            <span>}</span>  
        <span>.</span><span>.</span><span>.</span><span>.</span>  
        <span>}</span>  
        <span>throw</span> lastException<span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>위에서 설명한 ProviderManager에 우리가 직접 구현한 CustomAuthenticationProvider를 등록하는 방법은 SecurityConfig에서 빈으로 등록할 수 있다.</p>
<h4 id="userdetails"> <strong>[ UserDetails ]</strong></h4>
<p>인증에 성공하여 생성된 UserDetails 객체는 Authentication 객체를 구현한 UsernamePasswordAuthenticationToken을 생성하기 위해 사용된다. UserDetails 인터페이스를 살펴보면 아래와 같이 정보를 반환하는 메소드를 가지고 있다. UserDetails 인터페이스의 경우 직접 개발한 UserVO 모델에 UserDetails를 implements하여 이를 처리하거나 UserDetailsVO에 UserDetails를 implements하여 처리할 수 있다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>UserDetails</span> <span>extends</span> <span>Serializable</span> <span>{</span>  
  
    <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>GrantedAuthority</span><span>></span></span> <span>getAuthorities</span><span>(</span><span>)</span><span>;</span>  
  
    <span>String</span> <span>getPassword</span><span>(</span><span>)</span><span>;</span>  
  
    <span>String</span> <span>getUsername</span><span>(</span><span>)</span><span>;</span>  
  
    <span>boolean</span> <span>isAccountNonExpired</span><span>(</span><span>)</span><span>;</span>  
  
    <span>boolean</span> <span>isAccountNonLocked</span><span>(</span><span>)</span><span>;</span>  
  
    <span>boolean</span> <span>isCredentialsNonExpired</span><span>(</span><span>)</span><span>;</span>  
  
    <span>boolean</span> <span>isEnabled</span><span>(</span><span>)</span><span>;</span>  
  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="userdetailsservice"> <strong>[ UserDetailsService ]</strong></h4>
<p>UserDetailsService 인터페이스는 UserDetails 객체를 반환하는 단 하나의 메소드를 가지고 있는데, 일반적으로 이를 구현한 클래스의 내부에 UserRepository를 주입받아 DB와 연결하여 처리한다. UserDetails 인터페이스는 아래와 같다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>UserDetailsService</span> <span>{</span> 

<span>UserDetails</span> <span>loadUserByUsername</span><span>(</span><span>String</span> var1<span>)</span> <span>throws</span> <span>UsernameNotFoundException</span><span>;</span> 

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbeDENY%2FbtrBs0cquNc%2FPkwRQzgyzhoy1ecQrlQOJk%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>1031 ~ 1113</title>
      <link>ahnjs/TIL/2022/1031/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/1031/</guid>
      <source url="ahnjs/TIL/rss.xml">1031 ~ 1113</source>
      <pubDate>Sun, 30 Oct 2022 14:52:32 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1031-1113"> 1031 ~ 1113</h1>
<h2 id="_1031-gradle-implementation-vs-compile"> 1031 - [Gradle] implementation vs compile</h2>
<p><strong>[ api(compile) ]</strong></p>
<blockquote>
<p>The dependencies required to compile the production source of the project which are part of the API exposed by the project. For example the project uses Guava and exposes public interfaces with Guava classes in their method signatures.</p>
</blockquote>
<p><strong>[ implementation ]</strong></p>
<blockquote>
<p>The dependencies required to compile the production source of the project which are not part of the API exposed by the project. For example the project uses Hibernate for its internal persistence layer implementation.</p>
</blockquote>
<p>compile은 상위 모듈까지 가져온다. compile은 implementation 보다 더 많은 라이브러리를 빌드한다. 예를 들어 다음과 같이 의존하는 관계의 프로젝트 세 개가 있다고 가정했을 때</p>
<div><pre><code>myApp -&gt; mySpring -&gt; myJava
</code></pre>
<div><span>1</span><br></div></div><p>compile을 사용해서 mySpring을 빌드하게 되면 의존하고 있는 myJava까지 함께 빌드한다.<br>
implementation을 사용해서 빌드하면 mySpring 모듈만 가져오기 때문에 빌드 속도가 빠르고 필요한 API만 노출해서 사용할 수 있다. 또한 complie은 deprecated 되고 api로 대체됐다.</p>
<br>
<h2 id="_1103-커서-기반-페이지네이션"> 1103 - 커서 기반 페이지네이션</h2>
<p><strong>[ 오프셋 기반 페지 네션의 한계 ]</strong></p>
<ul>
<li>각각의 페이지를 요청하는 사이에 데이터의 변화가 있는 경우 중복 데이터가 노출된다.</li>
<li>대부분의 RDBMS에서 OFFSET 쿼리의 퍼포먼스 이슈가 있다.</li>
</ul>
<blockquote>
<p>오프셋은 단순히 레코드를 조회하기 전에 데이터 베이스가 건너 뛰는 레코드의 수다.<br>
즉, 요청한 데이터를 바로 조회하는 것이 아니라 이전의 데이터를 모두 조회하고 그 ResultSet에서 오프셋을 조건으로 잘라내는 것이다.</p>
</blockquote>
<h3 id="커서-기반-페이지네이션-cursor-based-pagination-이란"> 커서 기반 페이지네이션(Cursor-based Pagination)이란?</h3>
<ul>
<li>커서 개념을 사용한다. 사용자에게 응답해준 마지막의 데이터의 식별자 값이 Cursor가 된다.</li>
<li>커서를 기준으로 다음 n개의 데이터를 응답해주는 방식이다.</li>
</ul>
<p><strong>[ 구현 ]</strong></p>
<ul>
<li>Querydsl</li>
</ul>
<div><pre><code><span>public</span> <span>Page</span><span><span>&lt;</span><span>Club</span><span>></span></span> <span>findClubsByCondition</span><span>(</span><span>Long</span> cursorId<span>,</span> <span>ClubFindCondition</span> condition<span>,</span> <span>Account</span> loginAccount<span>,</span>
                                       <span>Pageable</span> pageable<span>)</span> <span>{</span>

    <span>List</span><span><span>&lt;</span><span>AccountClub</span><span>></span></span> findAccountClubs <span>=</span> queryFactory<span>.</span><span>selectFrom</span><span>(</span>accountClub<span>)</span>
						<span>.</span><span>.</span><span>.</span>
            <span>.</span><span>where</span><span>(</span>
                    <span>cursorId</span><span>(</span>cursorId<span>)</span>
										<span>.</span><span>.</span><span>.</span>
            <span>)</span>
            <span>.</span><span>limit</span><span>(</span>pageable<span>.</span><span>getPageSize</span><span>(</span><span>)</span><span>)</span>
            <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>

    <span>.</span><span>.</span><span>.</span>
<span>}</span>

<span>private</span> <span>BooleanExpression</span> <span>cursorId</span><span>(</span><span>Long</span> cursorId<span>)</span><span>{</span>
    <span>return</span> cursorId <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> club<span>.</span>id<span>.</span><span>gt</span><span>(</span>cursorId<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>BookPaginationDto</span><span>></span></span> <span>paginationNoOffset</span><span>(</span><span>Long</span> bookId<span>,</span> <span>String</span> name<span>,</span> <span>int</span> pageSize<span>)</span> <span>{</span>

    <span>return</span> queryFactory
            <span>.</span><span>select</span><span>(</span><span>Projections</span><span>.</span><span>fields</span><span>(</span><span>BookPaginationDto</span><span>.</span><span>class</span><span>,</span>
                    book<span>.</span>id<span>.</span><span>as</span><span>(</span><span>"bookId"</span><span>)</span><span>,</span>
                    book<span>.</span>name<span>,</span>
                    book<span>.</span>bookNo<span>)</span><span>)</span>
            <span>.</span><span>from</span><span>(</span>book<span>)</span>
            <span>.</span><span>where</span><span>(</span>
                    <span>ltBookId</span><span>(</span>bookId<span>)</span><span>,</span>
                    book<span>.</span>name<span>.</span><span>like</span><span>(</span>name <span>+</span> <span>"%"</span><span>)</span>
            <span>)</span>
            <span>.</span><span>orderBy</span><span>(</span>book<span>.</span>id<span>.</span><span>desc</span><span>(</span><span>)</span><span>)</span>
            <span>.</span><span>limit</span><span>(</span>pageSize<span>)</span>
            <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>BooleanExpression</span> <span>ltBookId</span><span>(</span><span>Long</span> bookId<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>bookId <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span> <span>// BooleanExpression 자리에 null이 반환되면 조건문에서 자동으로 제거된다</span>
    <span>}</span>

    <span>return</span> book<span>.</span>id<span>.</span><span>lt</span><span>(</span>bookId<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>[ 단점 ]</strong></p>
<ul>
<li>
<p>where에 사용되는 기준 Key가 중복이 가능할 경우</p>
<ul>
<li>이를 테면 group by 등으로 기준으로 잡을 Key가 중복이 될 경우 정확한 결과를 반환할 수 없어서 사용할 수가 없다.</li>
</ul>
</li>
<li>
<p>UX관점에서 페이징 버튼 형식으로 해야할 경우 사용불가</p>
</li>
</ul>
<br>
<h2 id="_1109-커버링-인덱스"> 1109 - 커버링 인덱스</h2>
<h3 id="using-index"> Using index</h3>
<p>커버링 인덱스 (쿼리의 모든 항목이 인덱스 컬럼으로 이루어진 상태)</p>
<h3 id="non-clustered-key와-clustered-key"> Non Clustered Key와 Clustered Key</h3>
<ul>
<li>Clustered Key
<ul>
<li>대상 : PK, PK가 없을땐 유니크키, 둘다 없을 경우 6byte의 Hidden Key를 생성(rowid)</li>
<li>제한 : 테이블당 1개만 존재 가능</li>
</ul>
</li>
<li>Non Clustered Key
<ul>
<li>대상 : 일반적인 인덱스</li>
<li>제한 : 여러개 생성 가능</li>
</ul>
</li>
</ul>
<p><img src="https://t1.daumcdn.net/cfile/tistory/999315505E4933DF02" alt="image"></p>
<ul>
<li>Non Clustered Key(일반적인 인덱스)에는 인덱스 컬럼의 값들과 Clustered Key(PK)의 값이 포함되어 있다</li>
<li>Clustered Key 만이 실제 테이블의 row 위치를 알고 있다</li>
</ul>
<blockquote>
<p>인덱스 조건에 부합한 <code>where</code> 조건이 있더라도 <code>select</code>에 인덱스에 포함된 컬럼 외에 다른 컬럼값이 필요할때는 Non Clustered Key에 있는 Clusterd Key 값으로 데이터 블록을 찾는 과정이 필요하다.<br>
다만 PK를 사용할 경우 인덱스 탐색 시간이 없어지기 때문에 향상된 데이터 파일 접근이 가능하다.<br>
커버링 인덱스는 여기서 &quot;실제 데이터 접근&quot;의 행위 없이 인덱스에 있는 컬럼값들로만 쿼리를 완성하는 것을 이야기한다.</p>
</blockquote>
<p><strong>[ WHERE + GROUP BY ]</strong>
GROUP BY 인덱스 적용 조건</p>
<ul>
<li>GROUP BY 절에 명시된 컬럼이 인덱스 컬럼의 순서와 같아야 한다.
<ul>
<li>아래 모든 케이스는 인덱스가 적용 안된다. (index: a,b,c)</li>
<li>group by b</li>
<li>group by b, a</li>
<li>group by a, c, b</li>
</ul>
</li>
<li>인덱스 컬럼 중 뒤에 컬럼이 GROUP BY 절에 명시되지 않아도 사용할 수 있다.
<ul>
<li>아래 모든 케이스는 인덱스가 적용된다. (index: a,b,c)</li>
<li>group by a</li>
<li>group by a, b</li>
<li>group by a, b, c</li>
</ul>
</li>
<li>반대로 인덱스 컬럼 중 앞에 있는 컬럼이 GROUP BY 절에 명시되지 않으면 인덱스를 사용할 수 없다.
<ul>
<li>ex: (index: a,b,c), group by b, c 는 인덱스 적용 안됨</li>
</ul>
</li>
<li>인덱스에 없는 컬럼이 GROUP BY 절에 포함되어 있으면 인덱스가 적용되지 않는다.
<ul>
<li>ex: (index: a,b,c), group by a,b,c,d 는 인덱스 적용안됨</li>
</ul>
</li>
</ul>
<p>여기서 WHERE 조건과 GROUP BY가 함께 사용되면 WHERE 조건이 동등 비교일 경우 GROUP BY 절에 해당 컬럼은 없어도 인덱스가 적용된다.</p>
<div><pre><code><span>WHERE</span> a <span>=</span> <span>1</span> 
<span>GROUP</span> <span>BY</span> b<span>,</span> c

<span>WHERE</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>'b'</span>
<span>GROUP</span> <span>BY</span> c
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><br>
<h2 id="_1113-커버링-인덱스를-활용한-페이징-성능-개선"> 1113 - 커버링 인덱스를 활용한 페이징 성능 개선</h2>
<p>커버링 인덱스란 쿼리를 충족시키는 데 필요한 모든 데이터를 갖고 있는 인덱스를 이야기한다.<br>
즉, select, where, order by, limit, group by 등에서 사용되는 모든 컬럼이 Index 컬럼안에 다 포함된 경우이다.</p>
<blockquote>
<p>페이징 성능을 개선할때나 실제로 커버링 인덱스를 태우는 부분은 select를 제외한 나머지만 우선으로 수행한다.</p>
</blockquote>
<div><pre><code><span>-- AS BE</span>
<span>SELECT</span> <span>*</span>
<span>FROM</span> items
<span>WHERE</span> 조건문
<span>ORDER</span> <span>BY</span> id <span>DESC</span>
<span>OFFSET</span> 페이지번호
<span>LIMIT</span> 페이지사이즈

<span>-- TO BE</span>
<span>SELECT</span>  <span>*</span>
<span>FROM</span>  items <span>as</span> i
<span>JOIN</span> <span>(</span><span>SELECT</span> id
        <span>FROM</span> items
        <span>WHERE</span> 조건문
        <span>ORDER</span> <span>BY</span> id <span>DESC</span>
        <span>OFFSET</span> 페이지번호
        <span>LIMIT</span> 페이지사이즈<span>)</span> <span>as</span> <span>temp</span> <span>on</span> <span>temp</span><span>.</span>id <span>=</span> i<span>.</span>id
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>[ 커버링 인덱스가 빠른이유 ]</strong><br>
일반적으로 인덱스를 이용해 조회되는 쿼리에서 가장 큰 성능 저하를 일으키는 부분은 인덱스를 검색하고 대상이 되는 row의 나머지 컬럼값을 데이터 블록에서 읽을 때이다.<br>
페이징 쿼리와 무관하게 인덱스를 탔음에도 느린 쿼리의 경우 이 select절 항목때문이다.<br>
이를테면 커버링 인덱스를 태우지 않은 일반적인 조회 쿼리는 order by, offset ~ limit을 수행할때도 데이터 블록으로 접근하게 된다.
<img src="https://t1.daumcdn.net/cfile/tistory/99F169425F93A3A52E" alt="image">
반대로 커버링 인덱스 방식을 이용하면, where, order by, offset ~ limit을 인덱스 검색으로 빠르게 처리하고, 이미 다 걸러진 10개의 row에 대해서만 데이터 블록에 접근하기 때문에 성능의 이점을 얻게 된다.
<img src="https://t1.daumcdn.net/cfile/tistory/998F7C3D5F93A3A52F" alt="image"></p>
<p><strong>[ Querydsl-JPA 구현코드 ]</strong><br>
querydsl-jpa에서 커버링 인덱스를 사용해야 한다면 2개의 쿼리로 분리해서 진행할 수 밖에 없다. 이유는 Querydsl-jpa에서 from절의 서브쿼리를 지원하지 않기 때문이다.</p>
<ul>
<li>커버링 인덱스를 활용해 조회 대상의 PK를 조회</li>
<li>해당 PK로 필요한 컬럼항목들 조회</li>
</ul>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>BookPaginationDto</span><span>></span></span> <span>paginationCoveringIndex</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> pageNo<span>,</span> <span>int</span> pageSize<span>)</span> <span>{</span>
        <span>// 1) 커버링 인덱스로 대상 조회</span>
        <span>List</span><span><span>&lt;</span><span>Long</span><span>></span></span> ids <span>=</span> queryFactory
                <span>.</span><span>select</span><span>(</span>book<span>.</span>id<span>)</span>
                <span>.</span><span>from</span><span>(</span>book<span>)</span>
                <span>.</span><span>where</span><span>(</span>book<span>.</span>name<span>.</span><span>like</span><span>(</span>name <span>+</span> <span>"%"</span><span>)</span><span>)</span>
                <span>.</span><span>orderBy</span><span>(</span>book<span>.</span>id<span>.</span><span>desc</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>limit</span><span>(</span>pageSize<span>)</span>
                <span>.</span><span>offset</span><span>(</span>pageNo <span>*</span> pageSize<span>)</span>
                <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>

        <span>// 1-1) 대상이 없을 경우 추가 쿼리 수행 할 필요 없이 바로 반환</span>
        <span>if</span> <span>(</span><span>CollectionUtils</span><span>.</span><span>isEmpty</span><span>(</span>ids<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>// 2)</span>
        <span>return</span> queryFactory
                <span>.</span><span>select</span><span>(</span><span>Projections</span><span>.</span><span>fields</span><span>(</span><span>BookPaginationDto</span><span>.</span><span>class</span><span>,</span>
                        book<span>.</span>id<span>.</span><span>as</span><span>(</span><span>"bookId"</span><span>)</span><span>,</span>
                        book<span>.</span>name<span>,</span>
                        book<span>.</span>bookNo<span>,</span>
                        book<span>.</span>bookType<span>)</span><span>)</span>
                <span>.</span><span>from</span><span>(</span>book<span>)</span>
                <span>.</span><span>where</span><span>(</span>book<span>.</span>id<span>.</span><span>in</span><span>(</span>ids<span>)</span><span>)</span>
                <span>.</span><span>orderBy</span><span>(</span>book<span>.</span>id<span>.</span><span>desc</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span> <span>// where in id만 있어 결과 정렬이 보장되지 않는다.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>[ JdbcTemplate 구현코드 ]</strong></p>
<div><pre><code><span>public</span> <span>List</span><span><span>&lt;</span><span>BookPaginationDto</span><span>></span></span> <span>paginationCoveringIndexSql</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> pageNo<span>,</span> <span>int</span> pageSize<span>)</span> <span>{</span>
<span>String</span> query <span>=</span>
        <span>"SELECT i.id, book_no, book_type, name "</span> <span>+</span>
        <span>"FROM book as i "</span> <span>+</span>
        <span>"JOIN (SELECT id "</span> <span>+</span>
        <span>"       FROM book "</span> <span>+</span>
        <span>"       WHERE name LIKE '?%' "</span> <span>+</span>
        <span>"       ORDER BY id DESC "</span> <span>+</span>
        <span>"       LIMIT ? "</span> <span>+</span>
        <span>"       OFFSET ?) as temp on temp.id = i.id"</span><span>;</span>

<span>return</span> jdbcTemplate
        <span>.</span><span>query</span><span>(</span>query<span>,</span> <span>new</span> <span>BeanPropertyRowMapper</span><span><span>&lt;</span><span>></span></span><span>(</span><span>BookPaginationDto</span><span>.</span><span>class</span><span>)</span><span>,</span>
                name<span>,</span>
                pageSize<span>,</span>
                pageNo <span>*</span> pageSize<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>[ 단점 ]</strong></p>
<ul>
<li>너무 많은 인덱스가 필요하다
<ul>
<li>결국 쿼리의 모든 항목이 인덱스에 포함되어야하기 때문에 느린 쿼리가 발생할때마다 인덱스가 신규 생성될 수도 있다.</li>
</ul>
</li>
<li>인덱스 크기가 너무 커진다
<ul>
<li>인덱스도 결국 데이터이기 때문에 너무 많은 항목이 들어가면 성능 상 이슈가 발생할 수 밖에 없는데, where절에 필요한 컬럼외에도 order by, group by, having 등에 들어가는 컬럼들까지 인덱스에 들어가게 되면 인덱스 크기가 너무 비대해진다.</li>
</ul>
</li>
<li>데이터 양이 많아지고, 페이지 번호가 뒤로 갈수록 NoOffset에 비해 느리다.
<ul>
<li>시작 지점을 PK로 지정하고 조회하는 NoOffset 방식에 비해서 성능 차이가 있음 (NoOffset과 동일한 데이터 조회시 커버링 인덱스 방식은 272ms, No Offset은 83ms)</li>
<li>테이블 사이즈가 계속 커지면 No Offset 방식에 비해서는 성능 차이가 발생</li>
</ul>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://t1.daumcdn.net/cfile/tistory/999315505E4933DF02" type="image/"/>
    </item>
    <item>
      <title>1017 ~ 1030</title>
      <link>ahnjs/TIL/2022/1017/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/1017/</guid>
      <source url="ahnjs/TIL/rss.xml">1017 ~ 1030</source>
      <pubDate>Sun, 16 Oct 2022 12:47:57 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1017-1030"> 1017 ~ 1030</h1>
<h2 id="_1018-mysql-explain-실행계획-사용법-및-분석"> 1018 - MySQL Explain 실행계획 사용법 및 분석</h2>
<h3 id="mysql-explain란"> MySQL Explain란?</h3>
<p>MySQL 튜닝에서 가장 중요한 것은 쿼리와 스키마 최적화이다. 스키마 설꼐는 한번 진행되면 그 테이블을 사용하는 모든 쿼리에 영향을 주기 때문에 좀처럼 변경하기 힘들지만 쿼리는 해당 쿼리만 수정하면 되므로 변경하기 쉽다. Slow Query를 없애는 것은 성능을 향상 시키기 위한 매우 중요한 수단이므로 어플리케이션의 성능을 향상시키고 싶다면 우선적으로 쿼리의 튜닝을 컴토해봐야 한다.</p>
<p>성능 진단의 가장 첫걸음은 실행한 SQL이 DB에서 어떻게 처리되는지를 파악하는 것이다. 사람이 이해할 수 있는 언어로 구성된 SQL을 실행하도록 DB에 명령을 내리면 DB는 내부적으로 SQL 파싱(문법 체크 및 DB에서 실행하기 위한 형태로 변환하는 단계)을 하고 옵티마이징(데이터를 찾는 가장 빠른 방법을 찾아내는 단계)을 거친 후 실제로 데이터를 찾는다. 사용자가 느끼기에는 SQL만으로 모든 조작이 이루어지는 것처럼 보이나 실제로는 조금이라도 빠르게 데이터를 찾아내기 위해 DB 내부적으로는 의외로 많은 단계를 거친다.</p>
<p>MySQL Explain 이란 DB가 데이터를 찾아가는 일련의 과정을 사람이 알아보기 쉽게 DB 결과 셋으로 보여주는것이다. MySQL Explain을 활용하여 기존의 쿼리를 튜닝할 수 있을 뿐만 아니라 성능 분석, 인덱스 전략 수립 등과 같이 성능 최적화에 대한 전반적인 업무를 처리할 수 있다.</p>
<h3 id="mysql-explain-사용방법"> MySQL Explain 사용방법</h3>
<div><pre><code><span>EXPLAIN</span> <span>[</span><span>EXTENDED</span><span>]</span> <span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>FROM</span> <span>.</span><span>.</span><span>.</span> <span>WHERE</span> <span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="mysql-explain-결과의-각-항목-별-의미"> MySQL Explain 결과의 각 항목 별 의미</h3>
<ul>
<li>id : select 아이디로 SELECT를 구분하는 번호</li>
<li>table : 참조하는 테이블</li>
<li>select_type : select에 대한 타입</li>
<li>type : 조인 혹은 조회 타입</li>
<li>possible_keys : 데이터를 조회할 때 DB에서 사용할 수 있는 인덱스 리스트</li>
<li>key : 실제로 사용할 인덱스</li>
<li>key_len : 실제로 사용할 인덱스의 길이</li>
<li>ref : Key 안의 인덱스와 비교하는 컬럼(상수)</li>
<li>rows : 쿼리 실행 시 조사하는 행 수립</li>
<li>extra : 추가 정보</li>
</ul>
<h4 id="id"> [ id ]</h4>
<p>행이 어떤 SELECT 구문을 나타내는 지를 알려주는 것으로 구문에 서브 쿼리나 UNION이 없다면 SELECT는 하나밖에 없기 때문에 모든 행에 대해 1이란 값이 부여되지만 이외의 경우에는 원 구문에서 순서에 따라 각 SELECT 구문들에 순차적으로 번호가 부여된다.</p>
<h4 id="table"> [ table ]</h4>
<p>행이 어떤 테이블에 접근하는 지를 보여주는 것으로 대부분의 경우 테이블 이름이나 SQL에서 지정된 별명 같은 값을 나타낸다.</p>
<h4 id="select-type"> [ select_type ]</h4>
<ul>
<li>SIMPLE : 단순 SELECT (Union이나 Sub Query가 없는 SELECT 문)</li>
<li>PRIMARY : Sub Query를 사용할 경우 Sub Query의 외부에 있는 쿼리(첫번째 쿼리) UNION을 사용할 경우 UNION의 첫 번째 SELECT 쿼리</li>
<li>UNION : UNION 쿼리에서 Primary를 제외한 나머지 SELECT</li>
<li>DEPENDENT_UNION : UNION과 동일하나, 외부쿼리에 의존적임 (값을 공급 받음)</li>
<li>UNION_RESULT : UNION 쿼리의 결과물</li>
<li>SUBQUERY : Sub Query 또는 Sub Query를 구성하는 여러 쿼리 중 첫번째 SELECT문</li>
<li>DEPENDENT_SUBQUERY : Sub Query와 동일하나, 외곽쿼리에 의존적임 (값을 공급 받음)</li>
<li>DERIVED : SELECT로 추출된 테이블 (FROM 절 에서의 서브쿼리 또는 Inline View)</li>
<li>UNCACHEABLE SUBQUERY : Sub Query와 동일하지만 공급되는 모든 값에 대해 Sub Query를 재처리. 외부쿼리에서 공급되는 값이 동이라더라도 Cache된 결과를 사용할 수 없음.</li>
<li>UNCACHEABLE UNION : UNION과 동일하지만 공급되는 모든 값에 대하여 UNION 쿼리를 재처리</li>
</ul>
<h4 id="type"> [ TYPE ]</h4>
<ul>
<li>system : 테이블에 단 한개의 데이터만 있는 경우</li>
<li>const : SELECT에서 Primary Key 혹은 Unique Key를 살수로 조회하는 경우로 많아야 한 건의 데이터만 있음</li>
<li>eq_ref : 조인을 할 때 Primary Key</li>
<li>ref : 조인을 할 때 Primary Key 혹은 Unique Key가 아닌 Key로 매칭하는 경우</li>
<li>ref_or_null : ref와 같지만 null이 추가되어 검색되는 경우</li>
<li>index_merge : 두 개의 인덱스가 병합되어 검색이 이루어지는 경우</li>
<li>unique_subquery : 다음과 같이 IN 절 안의 서브쿼리에서 Primary Key가 오는 특수한 경우</li>
</ul>
<div><pre><code><span>SELECT</span> <span>*</span>  
<span>FROM</span> tab01  
<span>WHERE</span> col01 <span>IN</span> <span>(</span><span>SELECT</span> <span>Primary</span> <span>Key</span> <span>FROM</span> tab01<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>index_subquery : unique_subquery와 비슷하나 Primary Key가 아닌 인덱스인 경우</li>
</ul>
<div><pre><code><span>SELECT</span> <span>*</span>  
<span>FROM</span> tab01  
<span>WHERE</span> col01 <span>IN</span> <span>(</span><span>SELECT</span> key01 <span>FROM</span> tab02<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>range : 특정 범위 내에서 인덱스를 사용하여 원하는 데이터를 추출하는 경우로, 데이터가 방대하지 않다면 단순 SELECT에서는 나쁘지 않음</li>
<li>index : 인덱스를 처음부터 끝까지 찾아서 검색하는 경우로, 일반적으로 인덱스 풀스캔이라고 함</li>
<li>all : 테이블을 처음부터 끝까지 검색하는 경우로, 일반적으로 테이블 풀스캔이라고 함</li>
</ul>
<h4 id="possible-keys"> [ possible_keys ]</h4>
<p>쿼리에서 접근하는 컬럼들과 사용된 비교 연산자들을 바탕으로 인덱스를 사용할 수 있는지를 표시해준다.</p>
<h4 id="key"> [ key ]</h4>
<p>테이블에 접근하는 방법을 최적화 하기 위해 어떤 인덱스를 사용하기로 결정했는지를 나타낸다.</p>
<h4 id="key-len"> [ key_len ]</h4>
<p>MySQL이 인덱스에 얼마나 많은 바이트를 사용하고 있는지를 보여준다. MySQL에서 인덱스에 있는 컬럼들 중 일부만 사용한다면 이 값을 통해 어떤 컬럼들이 사용되는 지를 계산할 수 있다.</p>
<h4 id="ref"> [ ref ]</h4>
<p>키 컬럼에 나와 있는 인덱스에서 값을 찾기 위해 선행 테이블의 어떤 컬럼이 사용되었는지를 나타낸다.</p>
<h4 id="rows"> [ rows ]</h4>
<p>원하는 행을 찾기 위해 얼마나 많은 행을 읽어야 할 지에 대해 예측값을 의미한다.</p>
<h4 id="extra"> [ extra ]</h4>
<ul>
<li>using index : 커버링 인덱스라고 하며 인덱스 자료 구조를 이용해서 데이터를 추출</li>
<li>using where : where 조건으로 데이터를 추출. type이 ALL 혹은 Index 타입과 함께 표현되면 성능이 좋지 않다는 의미</li>
<li>using filesort : 데이터 정렬이 필요한 경우로 메모리 혹은 디스크상에서의 정렬을 모두 포함. 결과 데이터가 많은 경우 성능에 직접적인 영향을 줌</li>
<li>using temporary : 쿼리 처리 시 내부적으로 temporary table이 사용되는 경우를 의미함</li>
</ul>
<blockquote>
<p>MySQL Explain 상 일반적으로 데이터가 많은 경우 Using Filesort 와 Using Temporary 상태는 좋지 않으며 쿼리 튜닝 후 모니터링이 필요하다.</p>
</blockquote>
<br>
<h2 id="_1026-transactional-동작원리"> 1026 - @Transactional 동작원리</h2>
<p>트랜잭션 처리를 위한 <code>@Transactional</code> 애노테이션은 Spring AOP의 대표적인 예이다. <code>@Transactional</code> 역시 Proxy 형태로 동작한다. (Spring은 JDK Proxy, Spring Boot는 CGLib Proxy를 기본으로 하기 때문에, 사용하는 것에 따라 생성된 프록시 객체 형태는 다를 수 있다.)</p>
<p><img src="https://velog.velcdn.com/images/ann0905/post/56a48b12-b2d0-4071-b09e-959e585551bb/image.png" alt="image"></p>
<p><code>@Transactional</code>은 AOP를 사용하여 구현된다. transaction의 <code>begin</code>과 <code>commit</code>을 메인 로직 앞 뒤로 수행주는 기능을 담당한다.
<code>@Transactional</code>가 붙은 메소드가 호출되기전 <code>begin</code>을 호출하고, 메서드가 종료되고 <code>commit</code>을 호출한다. 이 때 Spring AOP는 기본적으로 <code>PROXY 패턴</code>을 사용한다.</p>
<ol>
<li><code>@Transactional</code> 애노테이션을 발견하면 그 빈의 다이나믹 프록시를 생성.</li>
<li>그 프록시 객체는 트랜잭션 매니저에 접근하고 트랜잭션이나 커넥션을 열고 닫도로 요청</li>
<li>트랜잭션 매니저는 JDBC 방식으로 코드를 실행</li>
</ol>
<br>
<h2 id="_1027-transactional-전파-레벨-정리"> 1027 - @Transactional 전파 레벨 정리</h2>
<p><code>@Transactional</code>을 클래스 또는 메소드 레벨에 명시하면 해당 메소드 호출시 지정된 트랜잭션이 작동하게 된다. 단, 조건이 있다. 해당 클래스의 Bean을 다른 클래스의 Bean에서 호출할 때만 @Transactional을 인지하고 작동하게 된다. (같은 빈 내에서 @Transactional이 명시된 다른 메소드를 호출해도 작동하지 않는다.) Spring Framework는 내부적으로 AOP를 통해 해당 어노테이션을 인지하여 프록시를 생성하여 트랜잭션을 자동 관리하기 때문이다.</p>
<h3 id="전파레벨-propagation"> 전파레벨(Propagation)</h3>
<p>***[ Propagation.REQUIRED(기본 값) ]</p>
<div><pre><code><span>@Transactional</span><span>(</span>propagation <span>=</span> <span>Propagation</span><span>.</span>REQUIRED<span>)</span>
<span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>특정 메소드의 트랜잭션이 <code>Propagation.REQUIRED</code>로 설정되었을 때의 트랜잭션 동작은 다음과 같다. 기본적으로 해당 메소드를 호출한 곳에서 별도의 트랜잭션이 설정되어 있지 않았다면 트랜잭션을 새로 시작한다.(새로운 연결을 생성하고 실행한다.) 만약, 호출한 곳에서 이미 트랜잭션이 설정되어 있다면 기존의 트랜잭션 내에서 로직을 실행한다.(동일한 연결 안에서 실행된다.) 예외가 발생하면 롤백이 되고 호출한 곳에도 롤백이 전파된다. 이러한 REQUIRED 동작 방식을 원할 경우 기본값으로 설정되어 있기 떄문에 생략가능하다.</li>
<li>만약, 해당 메소드가 호출한 곳과 별도의 쓰레드라면 전파 레벨과 상관없이 무조건 별도의 트랜잭션을 생성하여 해당 메소드를 실행한다. Spring은 내부적으로 트랜잭션 정보를 ThreadLocal 변수에 저장하기 때문에 다른 쓰레드로 트랜잭션이 전파되지 않는다.</li>
</ul>
<p>***[ Propagation.REQUIRES_NEW ]</p>
<div><pre><code><span>@Transactional</span><span>(</span>propagation <span>=</span> <span>Propagation</span><span>.</span>REQUIRES_NEW<span>)</span> 
<span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li><code>Propagation.REQUIRES_NEW</code>로 설정되었을 때에는 매번 새로운 트랜잭션을 시작한다. (새로운 연결을 생성하고 실행한다.) 만약, 호출한 곳에서 이미 트랜잭션이 설정되어 있다면(기존의 연결이 존재한다면) 기존의 트랜잭션은 메소드가 종료할 때까지 잠시 대기 상태로 두고 자신의 트랜잭션을 실행한다. 새로운 트랜잭션 안에서 예외가 발생해도 호출한 곳에는 롤백이 전파되지 않는다. 즉, 2개의 트랜잭션은 완전히 독립적인 별개의 단위로 작동한다.</li>
</ul>
<p>***[ Propagaion.NESTED ]</p>
<div><pre><code><span>@Transactional</span><span>(</span>propagation <span>=</span> <span>Propagation</span><span>.</span>NESTED<span>)</span> 
<span>public</span> <span>void</span> <span>doSomething</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li><code>Propagation.NESTED</code>는 기본적으로 앞서 설명한 Propagation.REQUIRED와 동일하게 작동한다. 중요한 차이점은, SAVEPOINT를 지정한 시점까지 부분 롤백이 가능하다. 유의할 점은, 데이터베이스가 SAVEPOINT 기능을 지원해야 사용이 가능하다.</li>
</ul>
<br>
<h2 id="_1028-aop-aspect-oriented-progamming"> 1028 - AOP(Aspect Oriented Progamming)</h2>
<p>관점 지향 프로그래밍 : 객체를 핵심관심과 횡단관심으로 구분하여 처리하는 프로그래밍 기법
<img src="https://itwiki.kr/images/4/48/AOP의_핵심관심과_횡단관심.jpg" alt="image"></p>
<ul>
<li>핵심 기능(Core Concerns, Primary Concerns): 핵심 업무 로직을 수행하는 기능</li>
<li>부가 기능(Cross-cutting Concerns): 핵심 기능을 도와주는 부가적인 기능(로깅, 보안 등)</li>
</ul>
<p><em><strong>[ 용어 ]</strong></em>
<img src="https://itwiki.kr/images/thumb/1/11/AOP_개요도.png/500px-AOP_개요도.png" alt="image"></p>
<ul>
<li>Joinpoing
<ul>
<li>메소드를 호출하는 '시점', 예외가 발생하는 '시점'과 같이 애플리케이션을 실행할 때 특정 작업이 실행되는 '시점'을 의미</li>
</ul>
</li>
<li>Advice
<ul>
<li>joinpoint에서 실행되어야 하는 코드</li>
<li>횡단관점에 해당함(트랜잭션/로그/보안/인증 등)</li>
</ul>
</li>
<li>Target
<ul>
<li>실질적인 비즈니스 로직을 구현하고 있는 코드</li>
<li>핵심관점에 해당함(업무로직)</li>
</ul>
</li>
<li>Pointcut
<ul>
<li>Target 클래스와 Advice가 결합(Weaving) 될 때 둘 사이의 결합규칙을 정의하는 것이다.</li>
<li>예로 Advice가 실행된 Target의 특정 메소드등을 지정</li>
</ul>
</li>
<li>Aspect
<ul>
<li>Advice와 Pointcut을 합쳐서 하나의 Aspect라고 한다.</li>
<li>즉 일정한 패턴을 가지는 클래스에 Advice를 적용하도록 지원할 수 있는 것을 Aspect라고 한다.</li>
</ul>
</li>
<li>Weaving
<ul>
<li>AOP에서 Joinpoint들을 Advice로 감싸는 과정을 Weaving이라고 한다.</li>
<li>Weaving 하는 작업을 도와주는 것이 AOP툴이 하는 역할이다.</li>
</ul>
</li>
</ul>
<br>
<h2 id="_1029-spring-aop-weaving"> 1029 - Spring AOP Weaving</h2>
<h3 id="weaving-이란"> Weaving 이란?</h3>
<p>Weaving은 Pointcut에 의해서 결정된 타겟의 Join Point에 부가기능(Advice)를 삽입하는 과정을 뜻한다.<br>
Weaving은 AOP가 핵심기능(타겟)의 코드에 영향을 주지 않으면서 필요한 부가기능(어드바이스)를 추가할 수 있도록 해주는 핵심적인 처리과정이다.</p>
<blockquote>
<ul>
<li>Pointcut : 어드바이스를 적용할 타겟의 메서드를 선별하는 정규표현식이다.</li>
<li>Advice : 어드바이스는 타겟에 제공할 부가기능을 담고 있는 모듈이다.</li>
<li>Join Point : 어드바이스가 적용될 수 있는 위치를 말한다.</li>
</ul>
</blockquote>
<h3 id="weaving의-종류"> Weaving의 종류</h3>
<p><strong>[ Compile Time Weaving(CTW) ]</strong></p>
<ul>
<li>AspectJ에는 AJC(AspectJ Compiler)라는 컴파일러가 있는데 Java Compiler를 확장한 형태의 컴파일러이다.</li>
<li>AJC를 통해 java파일을 컴파일 하며, 컴파일 과정에서 바이트 코드 조작을 통해 Advisor 코드를 직접 삽입하여 위빙을 수행한다.</li>
<li>장점으로는 3가지 위빙 중에서는 가장 빠른 퍼포먼스를 보여준다. 하지만 컴파일 과정에서 lombok과 같이 컴파일 과정에서 코드를 조작하는 플러그인과 충돌이 발생할 가능성이 아주 높다.(거의 같이 사용 불가)</li>
</ul>
<p><strong>[ Runtime Weaving(RTW) ]</strong></p>
<ul>
<li>Spring AOP에서 사용하는 방식으로, Proxy를 생성해 실제 타깃 오브젝트의 변형없이 위빙을 수행한다.</li>
<li>실제 런타임시 Method 호출 시에 위빙이 이루어지는 방식이다.</li>
<li>소스파일, 클래스 파일에 변형이 없다는 장점이 있지만, Point Cut에 대한 Advice 수가 늘어날수록 성능이 떨어진다는 단점이 있다.</li>
</ul>
<p><strong>[ Load Time Weaving(LTW) ]</strong></p>
<ul>
<li>ClassLoader를 이용해 클래스가 JVM에 로드될 때 바이트 코드 조작을 통해 위빙되는 방식으로 컴파일 시간은 상대적으로 CTW보다 짧다. 하지만 오브젝트가 메모리에 올라가는 과정에서 위빙이 일어나기 때문에 런타임시 시간은 CTW보다 상대적으로 느리다.</li>
<li>Application Context에 객체가 로드될 때, 객체 핸들링이 발생하므로 퍼포먼스가 저하된다.</li>
</ul>
<p><strong>[ Post-Compile Weaving ]</strong></p>
<ul>
<li>컴파일 후 기존 클래스 파일과 JAR파일을 위빙하는데 사용, Compile Time Weavng 같은 방식으로 처리한다.</li>
</ul>
<h3 id="spring-aop와-aspectj"> Spring AOP와 AspectJ</h3>
<ul>
<li>AspectJ가 Compile 시점과 Load 시점 Weaving을 사용.</li>
<li>Spring AOP는 RunTime Weaving을 사용.</li>
<li>Spring AOP보다 AspectJ가 속도와 기능적인 측면에 조금 좋은 성능을 보이지만 바이트 코드 조작을 위해 JVM의 실행 옵션을 변경하거나, 별도의 바이트코드 컴파일러를 사용 등에 번거로운 작업이 따르므로 Spring AOP 사용 후 그 이상의 기능이 필요한 경우 AspectJ를 확장해서 사용하는 것을 추천한다.</li>
</ul>
<br>
<h2 id="_1030-spring-aop와-aspectj-비교"> 1030 - Spring AOP와 AspectJ 비교</h2>
<p><strong>[ Spring AOP ]</strong></p>
<ul>
<li>순수 Java로만으로도 구현됨</li>
<li>복잡한 과정이 필요 없음</li>
<li>런타임 Weaving만 가능함</li>
<li>메서드 레벨의 Weaving만 지원함</li>
<li>Spring Container에 의해 관리되는 빈즈에만 적요할 수 있음</li>
<li>메서드 실행 Point cut만 지원함</li>
<li>대상 객체의 Proxy가 생성되고 Aspect는 이러한 Proxy를 대상으로 적용됨</li>
<li>AspectJ에 비해 훨씬 느리다</li>
<li>배우고 적용하기 쉽다</li>
</ul>
<p><strong>[ AspectJ ]</strong></p>
<ul>
<li>추가 도구(자바 프로그램)를 통해 구현됨</li>
<li>로드 시즘 Weaving을 사용하더라도 AspectJ compiler(ajc)가 필요하다</li>
<li>런타임 Weaving이 불가능함. 컴파일 시점/컴파일 전/로드 시점 Weaving을 지원함</li>
<li>필드, 메서드, 생성자, final클래스/메서드 등 다양하게 지원함</li>
<li>모든 객체를 대상으로 적용 가능함</li>
<li>모든 Pint cut을 지원함</li>
<li>Aspect는 애플리케이션이 실행되기 전에 코드에 바로 Weaving됨(런타임 이전)</li>
<li>Spring AOP에 비해 좋은 성능</li>
<li>Spring AOP에 비해 복잡하다</li>
</ul>
]]></content:encoded>
      <enclosure url="https://velog.velcdn.com/images/ann0905/post/56a48b12-b2d0-4071-b09e-959e585551bb/image.png" type="image/png"/>
    </item>
    <item>
      <title>1010 ~ 1016</title>
      <link>ahnjs/TIL/2022/1010/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/1010/</guid>
      <source url="ahnjs/TIL/rss.xml">1010 ~ 1016</source>
      <pubDate>Sun, 09 Oct 2022 08:47:56 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1010-1016"> 1010 ~ 1016</h1>
<h2 id="_1011-생성자-바인딩-constructor-binding-로-프로퍼티-properties-설정-값-불러오기"> 1011 - 생성자 바인딩(Constructor Binding)로 프로퍼티(Properties) 설정 값 불러오기</h2>
<h4 id="생성자로-바인딩하기-constructorbinding"> [ 생성자로 바인딩하기(@ConstructorBinding) ]</h4>
<ul>
<li>설정파일</li>
</ul>
<div><pre><code>spring<span>.</span>datasource<span>.</span>driver<span>-</span><span>class</span><span>-</span>name<span>=</span><span><span>org<span>.</span>h2<span>.</span></span>Driver</span>
spring<span>.</span>datasource<span>.</span>url<span>=</span>jdbc<span>:</span>h2<span>:</span>mem<span>:</span>db<span>;</span>DB_CLOSE_DELAY<span>=</span><span>-</span><span>1</span>
spring<span>.</span>datasource<span>.</span>username<span>=</span>h2test
spring<span>.</span>datasource<span>.</span>password<span>=</span>h2test
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>생상자를 이용해 properties의 값을 바인딩하도록 @ConstructorBinding 어노테이션을 추가</li>
</ul>
<div><pre><code><span>@Getter</span>
<span>@RequiredArgsConstructor</span>
<span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span> <span>"spring.datasource"</span><span>)</span>
<span>@ConstructorBinding</span>
<span>public</span> <span>class</span> <span>DataSourceProperties</span> <span>{</span>

	<span>private</span> <span>final</span> <span>String</span> driverClassName<span>;</span>
	<span>private</span> <span>final</span> <span>String</span> url<span>;</span>
	<span>private</span> <span>final</span> <span>String</span> username<span>;</span>
	<span>private</span> <span>final</span> <span>String</span> password<span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><br>
<h2 id="_1012-불변-객체-immutable-object-및-final을-사용해야-하는-이유"> 1012 - 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유</h2>
<h3 id="_1-불변-객체-immutable-object-및-final을-사용해야-하는-이유"> 1. 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유</h3>
<h4 id="불변-객체-immutable-object-란"> [ 불변 객체(Immutable Object)란? ]</h4>
<p>불변 객체란 객체 생성 이후 내부의 상태가 변하지 않는 객체이다. 불변 객체는 read-only 메소드만을 제공하며, 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사(defensive-copy)를 통해 제공한다. Java의 대표적인 불변 객체로는 String이 있다.</p>
<div><pre><code><span>String</span> name <span>=</span> <span>"Old"</span><span>;</span>
name<span>.</span><span>toCharArray</span><span>(</span><span>)</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>'E'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Java의 String은 불변 클래스이기 떄문에 위와 같이 String 내부의 char형 배열을 얻어 수정하여도 반영되지 않는다. Java에서는 배열이나 객체 등의 참조(Reference)를 전달한다. 그렇기 때문에 참조를 통해 값을 수정하면 내부의 상태가 변하기 때문에 내부를 복사하여 전달하고 있는데, 이를 방어적 복사(defensive-copy)라고 한다. String의 toCharArray는 다음과 같이 복사하여 전달하고 있다.</p>
<div><pre><code><span>public</span> <span>char</span><span>[</span><span>]</span> <span>toCharArray</span><span>(</span><span>)</span> <span>{</span>
    <span>// Cannot use Arrays.copyOf because of class initialization order issues</span>
    <span>char</span> result<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>char</span><span>[</span>value<span>.</span>length<span>]</span><span>;</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>value<span>,</span> <span>0</span><span>,</span> result<span>,</span> <span>0</span><span>,</span> value<span>.</span>length<span>)</span><span>;</span>
    <span>return</span> result<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="불변-객체-및-final을-사용해야-하는-이유"> [ 불변 객체 및 final을 사용해야 하는 이유 ]</h4>
<blockquote>
<p>Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.</p>
</blockquote>
<ul>
<li>멀티 쓰레드 환경에서 동기화 문제가 발생하는 이유는 공유 자원에 동시에 쓰기(Write) 때문이다. 하지만 만약 공유 자원이 불변이라면 항상 동일한 값을 반환하기 때문에 동기화를 고려하지 않아도 된다. 이는 안정성을 보장할 뿐만 아니라 동기화를 하지 않음으로써 성능상의 이점도 가져다준다.</li>
</ul>
<blockquote>
<p>실패 원자적인(Failure Atomic) 메소드를 만들 수 있다.</p>
</blockquote>
<ul>
<li>가변 객체를 통해 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있고, 불안정한 상태를 갖는 객체는 또 다른 에러를 유발할 수 있다. 하지만 불변 객체라면 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지할 수 있을 것이다. 그리고 예외가 발생하여도 오류가 발생하지 않은 것 처럼 다음 로직을 처리할 수 있다.</li>
</ul>
<blockquote>
<p>Cache나 Map 또는 Set 등의 요소로 활용하기에 더욱 적합하다.</p>
</blockquote>
<ul>
<li>만약 캐시나 Map, Set 등의 원소인 가변 객체가 변경되었다면 이를 갱신하는 등의 부가 작업이 필요할 것이다. 하지만 불변 객체라면 한 번 데이터가 저장된 이후에 다른 작업들을 고려하지 않아도 되므로 사용하는데 용이하게 작용할 것이다.</li>
</ul>
<blockquote>
<p>부수 효과(Side Effect)를 피해 오류가능성을 최소화할 수 있다.</p>
</blockquote>
<ul>
<li>부수 효과란 변수의 값이나 상태 등의 변화가 발생하는 효과를 의미한다. 만약 객체의 수정자(Setter)를 통해 여러 객체들에서 값을 변경한다면 객체의 상태를 예측하기 어려워질 것이다. 바뀐 상태를 파악하기 위해서는 메소드들을 살펴보아야 하고, 이는 유지보수성을 상당히 떨어뜨린다. 그래서 이러한 부수효과가 없는 순수 함수들을 만드는 것이 상당히 중요하다. 불변 객체는 기본적으로 값의 수정이 불가능하기 때문에 변경 가능성이 적으며, 객체의 생성과 사용이 상당히 제한된다. 그렇기 때문에 메소드들은 자연스럽게 순수 함수들로 구성될 것이고, 다른 메소드가 호출되어도 객체의 상태가 유지되기 때문에 안전하게 객체를 다시 사용할 수 있다. 이러한 불변 객체는 오류를 줄여 유지보수성이 높은 코드를 작성하도록 도와줄 것이다.</li>
</ul>
<blockquote>
<p>다른 사람이 작성한 함수를 예측가능하며 안전하게 사용할 수 있다.</p>
</blockquote>
<ul>
<li>일반적으로 개발은 다른 사람들과 협업을 하게 된다. 불변성(Immutability)은 협업 과정에서도 도움을 주는데, 불변성이 보장된 함수라면 다른 사람이 개발한 함수를 위험없이 이용할 수 있다. 마찬가지로 다른 사람도 내가 작성한 메소드를 호출하여도, 값이 변하지 않음을 보장받을 수 있다. 그렇기에 우리는 변경에 대한 불안없이 다른 사람의 코드를 이용할 수 있다. 또한 불필요한 시간을 절약할 수도 있다.</li>
</ul>
<blockquote>
<p>가비지 컬렉션의 성능을 높일 수 있다.</p>
</blockquote>
<ul>
<li>불변성의 많은 이점 중에서 많은 사람들이 놓치는 것이 바로 GC성능을 높여준다는 것이다. 불변의 객체는 한번 생성된 이후에 수정이 불가능한 객체로, Java에서는 final 키워드를 사용하여 불변의 객체를 생성할 수 있다. 이렇게 객체를 생성하기 위해서는 객체를 가지는 또 다른 컨테이너 객체(ImmutableHolder)도 존재한다는 것인데, 당연히 불변의 객체(Object value)가 먼저 생성되어야 컨테이너 객체가 이를 참조할 수 있을 것이다. 즉, 컨테이너는 컨테이너가 참조하는 가장 젊은 객체들보다 더 젊다는 것(늦게 생성되었다는 것)이다. 이를 정리하면 다음과 같다.
<ul>
<li>Object 타입의 value 객체 생성</li>
<li>ImmutableHolder 타입의 컨테이너 객체 생성</li>
<li>ImmutableHolder가 value 객체를 참조</li>
</ul>
</li>
</ul>
<p>이러한 점은 GC가 수행될 때, 가비지 컬렉터가 컨테이너 객체 하위의 불변 객체들은 Skip할 수 있도록 도와준다. 왜냐하면 해당 컨테이너 객체가 살아있다는 것은 하위의 불변 객체들(value) 역시 처음에 할당된 상태로 참조되고 있음을 의미하기 때문이다.</p>
<div><pre><code><span>public</span> <span>class</span> <span>MutableHolder</span> <span>{</span>
    <span>private</span> <span>Object</span> value<span>;</span>
    <span>public</span> <span>Object</span> <span>getValue</span><span>(</span><span>)</span> <span>{</span> <span>return</span> value<span>;</span> <span>}</span>
    <span>public</span> <span>void</span> <span>setValue</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span> value <span>=</span> o<span>;</span> <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>ImmutableHolder</span> <span>{</span>
    <span>private</span> <span>final</span> <span>Object</span> value<span>;</span>
    <span>public</span> <span>ImmutableHolder</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span> value <span>=</span> o<span>;</span> <span>}</span>
    <span>public</span> <span>Object</span> <span>getValue</span><span>(</span><span>)</span> <span>{</span> <span>return</span> value<span>;</span> <span>}</span>
<span>}</span>

<span>@Test</span>
<span>public</span> <span>void</span> <span>createHolder</span><span>(</span><span>)</span> <span>{</span>
    <span>// 1. Object 타입의 value 객체 생성</span>
    <span>final</span> <span>String</span> value <span>=</span> <span>"MangKyu"</span><span>;</span>
    
    <span>// 2. Immutable 생성 및 값 참조</span>
    <span>final</span> <span>ImmutableHolder</span> holder <span>=</span> <span>new</span> <span>ImmutableHolder</span><span>(</span>value<span>)</span><span>;</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>결국 불변의 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체의 수가 줄어서 스캔해야 하는 메모리 영역과 빈도수 역시 줄어들 것이고, GC가 수행되어도 지연 시간을 줄일 수 있을 것이다. 그렇기 때문에 필드값을 수정할 수 있는 MutableHolder보다는 필드값을 수정할 수 없는 ImmutableHolder를 사용하는 것이 좋다.</p>
<h3 id="_2-java에서-불변-객체를-생성하는-법"> 2. Java에서 불변 객체를 생성하는 법</h3>
<h4 id="final-키워드"> [ final 키워드 ]</h4>
<div><pre><code><span>final</span> <span>String</span> name <span>=</span> <span>"Old"</span><span>;</span>
name <span>=</span> <span>"New"</span><span>;</span>  <span>// 컴파일 에러 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>final</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
list<span>.</span><span>add</span><span>(</span><span>"a"</span><span>)</span><span>;</span>      <span>// 가능</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>이를 방지하려면 불변 클래스로 생성해야함</li>
</ul>
<h4 id="불변-클래스-예시"> [ 불변 클래스 예시 ]</h4>
<p>Java에서 불변 객체를 생성하기 위해서는 다음과 같은 규칙에 따라서 클래스를 생성한다.</p>
<ol>
<li>클래스를 final로 선언하라</li>
<li>모든 클래스 변수를 private와 final로 선언하라</li>
<li>객체를 생성하기 위한 생성자 또는 정적 팩토리 메소드를 추가하라</li>
<li>참조에 의해 변경가능성이 있는 경우 방어적 복사를 이용하여 전달하라</li>
</ol>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>ImmutableClass</span> <span>{</span>
    <span>private</span> <span>final</span> <span>int</span> age<span>;</span>
    <span>private</span> <span>final</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list<span>;</span>

    <span>private</span> <span>ImmutableClass</span><span>(</span><span>int</span> age<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>ImmutableClass</span> <span>of</span><span>(</span><span>int</span> age<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ImmutableClass</span><span>(</span>age<span>,</span> name<span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getList</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>Collections</span><span>.</span><span>unmodifiableList</span><span>(</span>list<span>)</span><span>;</span>
    <span>}</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p>클래스들은 가변적이여야 하는 매우 타당한 이유가 있지 않는 한 반드시 불변으로 만들어야 한다. 만약 클래스를 불변으로 &gt; 만드는 것이 불가능하다면, 가능한 변경 가능성을 최소화하라. - Effective Java -</p>
</blockquote>
<h2 id="_1013-configurationpropertiesscan"> 1013 - @ConfigurationPropertiesScan</h2>
<p>@EnableConfigurationProperties에 등록해야 하는 클래스들이 많은 경우에는 일일이 등록하는게 번거로울 수 있다.</p>
<h3 id="enableconfigurationproperties의-한계점"> [ @EnableConfigurationProperties의 한계점 ]</h3>
<p>@EnableConfigurationProperties를 이용해 설정 프로퍼티 클래스(@Configuration Properties)를 사용하는 경우에는 해당 클래스들이 많아질 경우에 코드가 상당히 무거워지는 한계가 있다.</p>
<div><pre><code><span>@Configuration</span>
<span>@EnableConfigurationProperties</span><span>(</span><span>{</span><span>DataSourceProperties</span><span>.</span><span>class</span><span>,</span> <span>InfluxProperties</span><span>.</span><span>class</span><span>,</span> <span>.</span><span>.</span><span>.</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>SpringBootApplication</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>SpringBoot 2.2부터는 이러한 문제점들을 해결하기 위해 @ConfigurationPropertiesScan 이라는 어노테이션을 제공하고 있다.</p>
<h3 id="configurationpropertiesscan의-사용법"> [ @ConfigurationPropertiesScan의 사용법 ]</h3>
<p>@ConfigurationPropertiesScan 어노테이션은 @ComponentScan과 상당히 유사하다.<br>
@ConfigurationPropertiesScan 어노테이션은 패키지를 기반으로 @ConfigurationProperties가 등록된 클래스들을 찾아 값들을 주입하고 빈으로 등록해준다. @ConfigurationPropertiesScan에 스캔을 실행할 패키지 또는 클래스를 지정해줄 수 있으며, 만약 별도로 지정하지 않는다면 해당 어노테이션이 붙은 패키지와 그 하위 패키지에 대해 스캔을 진행한다. @Component나 그 하위 어노테이션(@Configuration 등)이 붙은 클래스들은 @ConfigurationPropertiesScan에 의해 스캔되지 않는다.<br>
일반적으로 Spring Boot의 메인 클래스에 @ConfigurationPropertiesScan 어노테이션을 다음과 같이 추가해주고, 필요한 경우 Base Package를 지정해준다.</p>
<div><pre><code><span>@Configuration</span>
<span>@ConfigurationPropertiesScan</span><span>(</span><span>"com.mang.atdd.membership"</span><span>)</span>
<span>public</span> <span>class</span> <span>SpringBootApplication</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><br>
<h2 id="_1015-인덱스-생성전략"> 1015 - 인덱스 생성전략</h2>
<h4 id="인덱스-선정-기준"> [ 인덱스 선정 기준 ]</h4>
<ul>
<li>모든 액세스 형태와 분석을 토대로이상적인 컬럼 구성과 순서 결정을 통해 최소의 인덱스로 모든 액세스 형태를 만족할 수 있도록 해야한다.</li>
<li>가능한 실측자료(액세스 형태 수집, 분석, 액세스의 빈도, 처리범위의 크기, 분포도, 테이블의 크기, 액세스 유형 등)를 활용하여 종합적으로 전략적인 결정을 해야한다.</li>
<li>여기서 분포도란 쉽게 말해 사용 빈도로 이해를 하면 된다. 즉, 분포도가 좋다는 의미는 한 컬럼에 해당하는 값이 희소성이 높다는 뜻이다.</li>
</ul>
<h4 id="저장용-대형-테이블-적용-기준"> [ 저장용 대형 테이블 적용 기준 ]</h4>
<ul>
<li>로그성 데이터를 관리할 목적으로 생성된 테이블을 저장용 대형 테이블이라고 한다.</li>
<li>이러한 테이블의 특징으로는 대량의 데이터가 지속적으로 입력이 된다는 것이다.</li>
<li>따라서 테이블에서 기본키(PK)를 가지는 것은 입력시 부담이 될 수 있으므로 이를 사용하지 않는 것도 고려해야 한다. 대신 UNIQUE INDEX 생성을 고려해야 한다.</li>
<li>또한, 테이블에 파티션을 만들고 파티션마다 필요한 인덱스를(Local Index)를 생성하는 것이 좋다.</li>
<li>파티션 인덱스 사용시, 사용 파티션의 인덱스만 사용하는 것도 고려해야 한다. =&gt; 즉, 전체 Local Index를 UNUSABLE 상태로 만든 후, 이후 필요한 파티션의 인덱스만 생성하는 방식</li>
</ul>
<h4 id="composite-index-결합-인덱스"> [ Composite index (결합 인덱스) ]</h4>
<ul>
<li>여러 컬럼을 모아 하나의 인덱스로 만드는 방식. 주로 SQL 문장에서 WHERE 절의 조건 컬럼이 2개 이상의 AND로 연결 되어 함께 사용되는 경우에 많이 사용.</li>
<li>단, OR로 조회되는 경우는 결합 인덱스를 만들면 안된다.</li>
<li>특징
<ul>
<li>인덱스의 첫 번째 컬럼이 조건절에 없다면 일반적으로 인덱스가 사용되지 않는다.
<ul>
<li>Equal 연산이 아닌 검색 조건이 들어오는 경우(범위 연산), 처리 범위가 크게 증가하여 효율이 크게 저하될 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="결합-인덱스를-구성하는-컬럼의-순서"> [ 결합 인덱스를 구성하는 컬럼의 순서 ]</h4>
<p>성능을 향상시키기 위해서는 결합 인덱스를 구성하는 컬럼은 반드시 다음의 순서에 맞도록 생성해야 한다.</p>
<ul>
<li>1순위 : 컬럼이 사용한 연산자에 의한 인덱스 컬럼 선정</li>
<li>2순위 : 랜덤 액세스를 고려한 인덱스 컬럼 선정</li>
<li>3순위 : 정렬 제거를 위한 인덱스 컬럼 선정</li>
<li>4순위 : 단일 컬럼의 분포도를 고려한 인덱스 컬럼 선정</li>
</ul>
<p>위 우선 순위를 지키지 않는다면 애당초 해당 인덱스를 이용한 성능 향상은 기대하기 조차 힘들다.</p>
<blockquote>
<p>예시 1</p>
</blockquote>
<div><pre><code><span>SELECT</span> 카드번호<span>,</span> 사용금액 <span>FROM</span> 거래내역 <span>WHERE</span> 카드번호 <span>=</span> <span>'111'</span> <span>AND</span> 거래일자 <span>BETWEEN</span> <span>'20080501'</span> <span>AND</span> <span>'20080510'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>카드번호 컬럼의 분포도는 매우 좋으며 거래일자 컬럼의 분포도는 매우 좋지 않다. 카드번호, 거래일자 순으로 결합 인덱스를 구성했을때, 카드번호 컬럼의 값에 의해 처리 범위는 감소하게 되며 또한 거래일자 컬럼에 의해서라도 처리 범위가 감소하게 되므로 원하는 데이터에 대해 최소의 액세스로 결과를 추출할 수 있게 된다.</li>
</ul>
<blockquote>
<p>예시 2</p>
</blockquote>
<div><pre><code><span>SELECT</span> 카드번호<span>,</span> 사용금액 <span>FROM</span> 거래내역 <span>WHERE</span> 카드번호 <span>BETWEEN</span> <span>'111'</span> <span>AND</span> <span>'555'</span> <span>AND</span> 거래일자 <span>=</span> <span>'20080515'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>컬럼의 분포도만을 생각하여 카드번호 + 거래일자 인덱스를 생성한다면 카드번호 컬럼에 의해서만 처리 범위가 감소하게 되어 성능 저하가 발생한다.</li>
<li>그 이유는 111 카드번호부터 555 카드번호까지 2008년 5월 15일 데이터만을 액세스하는 것이 아니라 '111' 카드번호부터 '555'카드 번호까지 모든 데이터를 액세스하기 때문이다. =&gt; 즉, 거래일자 컬럼은 처리 위를 감소시키지 못한다.</li>
<li>따라서 결합 인덱스를 구성할 경우, 다음과 같은 조건에 따라 결합 인덱스를 구성해야 한다.
<ul>
<li>점 조건(=, IN) + 점 조건(=, IN) : 두 조건에 의해 처리 범위 감소</li>
<li>점 조건(=, IN) + 선분 조건(LIKE, BETWEEN) : 두 조건에 의해 처리 범위 감소</li>
<li>선분 조건(LIKE, BETWEEN) + 선분 조건(LIKE, BETWEEN) : 앞의 선분 조건에 의해 처리 범위 감소</li>
<li>선분 조건(LIKE, BETWEEN) + 점 조건(=, IN) : 앞의 선분 조건에 의해서만 처리 범위 감소</li>
</ul>
</li>
</ul>
<p>: 따라서 위와 같이 연산자에 의해 처리 범위가 결정되며 최소의 처리 범위를 보장받기 위해서는 점 조건 앞에 선분 조건이 존재하면 안된다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>1003 ~ 1009</title>
      <link>ahnjs/TIL/2022/1003/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/1003/</guid>
      <source url="ahnjs/TIL/rss.xml">1003 ~ 1009</source>
      <pubDate>Mon, 03 Oct 2022 14:27:16 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1003-1009"> 1003 ~ 1009</h1>
<h2 id="_1003-db-동시성-문제-해결-방법"> 1003 - DB 동시성 문제 해결 방법</h2>
<h3 id="동시성이란-concurrency"> 동시성이란(Concurrency)?</h3>
<p>사전적 의미는 하나의 CPU 코어에서 시간분할(Time sharing)을 통하여 여러 일을 처리하는 것 처럼 보여지게 하는 기법을 의미한다.<br>
하지만, 대중적으로는 여러 요청이 동시에 동일한 자원(data)에 접근하고 수정하려는 것을 의미한다.</p>
<h3 id="동시성-문제-해결방법"> 동시성 문제 해결방법</h3>
<h4 id="비관적인-방법"> [ 비관적인 방법 ]</h4>
<p>현재 수정하려는 데이터가 언제든 다른 요청에 의해 수정될 가능성을 고려하여 해당 데이터에 Lock을 거는 방식.<br>
장점은 데이터의 무결성을 완벽히 지킬 수 있다. 수정할 데이터에 row level lock을 걸기 때문에 다른 요청에서 수정하려는 것은 불가능하다.<br>
단점은 lock으로 인해 이후의 다른 요청은 대기상태로 빠진다. 기존의 lock의 transaction이 commit 또는 rollback으로 끝나면 대기하고 있떤 요청을 비로소 실행한다.<br>
해당 방법은 서버의 성능에 따라 처리량이 결정되기 때문에 도입하기전 서비스의 최소 처리 tps에 부합하는지 확인해야한다.<br>
이 방법은 세가지 방식으로 적용할 수 있다.</p>
<p>첫 번째는 DB에서 제공하는 데이터 Lock수준을 높이는 것이다. 일반적인 기본수준값인 <code>Repeatable Read</code>를 <code>Serializer</code> 이상의 수준으로 올린다. 강도 높은 락으로 완전한 일관성을 유지할 수 있다. 하지만, 이로인한 다른 요청들이 모두 취소가된다. 취소된 작업들은 재시도를 위한 처리가 반드시 필요하기 때문에 서비스에 적용하는것엔 현실성이 부족하다.</p>
<p>두 번째는 <code>select for update</code> 활용하여 명시적으로 lock을 잡을 수 있다. 하지만 lock을 잡는 구간이 길어져 성능에 심각한 영향을 준다. 극장예매와 같은 서비스가 아니라면 사용하지 않는것이 좋다.</p>
<p>마지막은 Data의 transaction의 write lock을 활용한다. 일반적으로 데이터를 수정할 때 write lock이 걸리고 transaction이 끝나야 lock이 풀리는 것을 이용한다. 데이터의 일관성을 유지할 수 있찌만 DB와 서버 성능에 따라서 서비스의 속도가 좌우된다.</p>
<h4 id="낙관적인-방법"> [ 낙관적인 방법 ]</h4>
<p>수정하려는 데이터는 나만 수정할 것이라는 낙관적인 생각의 방법이다. 테이블에 version이라는 숫자컬럼 또는 updated_at 이라는 시간컬럼을 만들어서 수정될 때마다 1씩 증가하거나, 현재시간으로 갱신하게 해준다. 값을 수정할떄 Version이 동일하면 수정이 가능해지고, 동일하지 않으면 수정에 실패한다.</p>
<p>장점으로는 모델에 컬럼을 하나 추가하면 구현이 비교적으로 쉽지만, 두개의 DB세션이 동일한 버전으로 수정하려고 하면 한 개의 세션에선 version conflict이 발생하여 affected row count가 0이 된다. 따라서 이 경우 요청을 재시도하도록 구현이 필요.</p>
<br>
<h2 id="_1004-java의-버전별-변화-java-se-10-15"> 1004 - JAVA의 버전별 변화(JAVA SE 10 ~ 15)</h2>
<h4 id="java-se-10"> [ Java SE 10 ]</h4>
<p>2018년 3월 20일 발표된 버전. 일반 지원은 2018년 9월에 종료. var 키워드를 이용한 지역 변수 타입추론, 병렬 처리 가비지 컬렉션, 개별 스레드로 분리된 Stop-The-World, 루트 CA 목록 등이 추가. 또한 JDK의 레포지토리가 하나로 통합, JVM 힙 영역을 시스템 메모리가 아닌 다른 종류의 메모리에도 할당할 수 있게 되었다. 실험 기능으로 Java 기반의 JIT 컴파일러가 추가되었고, 이전 버전에서 Deprecated 처리된 API는 Java SE 10에서 모두 삭제되었다.</p>
<h4 id="java-se-11"> [ JAVA SE 11 ]</h4>
<p>2018년 9월 25일에 발표된 버전. 일반 지원은 2023년 9월, 연장 지원은 2026년 9월에 종료 예정. 이클립스 재단으로 넘어간 Java EE가 JDK에서 삭제되고, JavaFX도 JDK에서 분리되어 별도의 모듈로 제공된다. Gloun이라는 업체가 JavaFX를 유지보수 중이므로 이곳에서 다운로드하면 된다. 람다 파라미터에 대한 지역 변수 문법, 엡실론 가비지 컬렉터, HTTP 클라이언트 표준화 등의 기능이 추가.</p>
<p>가장 커다란 변화는 바로 라이선스 부분. Java SE 11부터 Oracle JDK의 독점 기능이 오픈 소스 버전인 OpenJDK에 이식된다. 이는 다시 말해 Oracle JDK와 OpenJDK가 완전히 동일해진다는 뜻이다. Oracle JDK는 Java SE 11부터 LTS(장기 지원)버전으로 3년마다 출시되는데, 출시 후 5년 동안 오라클의 기술 지원이 제공되고 최대 3년까지 지원 기간을 연장할 수 있다. Oracle JDK는 이제 3년에 한 번 출시되니 자바의 실질적인 버전 업을 담당하는 것은 OpenJDK라 할 수 있다. OpenJDK는 기업들을 위한 기술 지원은 없고, 새로운 버전이 나오면 이전 버전에 대한 마이너 업데이트와 보안 업데이트는 중단된다.</p>
<p>Java 11과 함께 발표된 또 다른 소식은 Oracle JDK가 구독형 유료 모델로 전환된다는 점이다. 2019년 1월부터 오라클이 제공하는 모든 Oracle JDK는 유료화되며, 구독권을 구입하지 않으면 Oracle JDK에 접근 자체가 금지된다. 기존의 일반/연장 지원 서비스는 구독권에 포함되므로 별도의 서비스로는 제공되지 않습니다. 개인 사용자는 2021년 1월부터 비용을 지불해야 한다. 이 떄문에 많은 기업들이 Oracle JDK에서 발을 빼고 있으며, OpenJDK를 기반으로 한 다른 서드파티 JDK가 대안으로 떠오르고 있다. 대표적인 예로 Azul Systems에서 개발한 Zulu JDK는 오라클의 TCK(Technology Certification Kit) 인증을 받은 구현체이다. 개인과 기업 모두 무료로 사용 할 수 있고, 기술 지원에 한해서만 유료 서비스가 제공된다. 또 다른 대안으로는 AdoptOpenJDK가 있는데, AdoptOpenJDK는 HotStop VM대신 Eclipse OpenJ9를 탑재한 버전도 같이 제공하고 있다. 다만 아직 TCK 인증을 받지 않았기에 주의가 필요하다.</p>
<h4 id="java-se-12"> [ JAVA SE 12 ]</h4>
<p>2019년 3월 19일 공개된 버전이다. 특징 중 하나로 문법적으로 Switch문을 확장한 것이 있다.</p>
<ul>
<li>AS-IS</li>
</ul>
<div><pre><code><span>switch</span> <span>(</span>day<span>)</span> <span>{</span>  
    <span>case</span> MONDAY<span>:</span>  
    <span>case</span> FRIDAY<span>:</span>  
    <span>case</span> SUNDAY<span>:</span>  
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>6</span><span>)</span><span>;</span>  
        <span>break</span><span>;</span>    <span>case</span> TUESDAY<span>:</span>  
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>7</span><span>)</span><span>;</span>  
        <span>break</span><span>;</span>    <span>case</span> THURSDAY<span>:</span>  
    <span>case</span> SATURDAY<span>:</span>  
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>8</span><span>)</span><span>;</span>  
        <span>break</span><span>;</span>    <span>case</span> WEDNESDAY<span>:</span>  
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>9</span><span>)</span><span>;</span>  
        <span>break</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>
<li>TO-BE</li>
</ul>
<div><pre><code><span>switch</span> <span>(</span>day<span>)</span> <span>{</span>  
    <span>case</span> MONDAY<span>,</span> FRIDAY<span>,</span> SUNDAY <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>6</span><span>)</span><span>;</span>  
    <span>case</span> TUESDAY <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>7</span><span>)</span><span>;</span>  
    <span>case</span> THURSDAY<span>,</span> SATURDAY <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>8</span><span>)</span><span>;</span>  
    <span>case</span> WEDNESDAY <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>9</span><span>)</span><span>;</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>이외에 가비지 컬렉터 개선, 마이크로 벤치마크 툴 추가, 성능 개선의 변경점이 있다.</p>
<h4 id="java-se-13"> [ JAVA SE 13 ]</h4>
<p>2019년 9월 17일 공개된 버전이며, java 12에서의 스위치 개선을 이어 yield라는 예약어가 추가되었다.</p>
<div><pre><code><span>var</span> a <span>=</span> <span>switch</span> <span>(</span>day<span>)</span> <span>{</span>  
    <span>case</span> MONDAY<span>,</span> FRIDAY<span>,</span> SUNDAY<span>:</span>  
        <span>yield</span> <span>6</span><span>;</span>  
    <span>case</span> TUESDAY<span>:</span>  
        <span>yield</span> <span>7</span><span>;</span>  
    <span>case</span> THURSDAY<span>,</span> SATURDAY<span>:</span>  
        <span>yield</span> <span>8</span><span>;</span>  
    <span>case</span> WEDNESDAY<span>:</span>  
        <span>yield</span> <span>9</span><span>;</span>  
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="java-se-14"> [ JAVA SE 14 ]</h4>
<p>2020년 3월 18일 공개된 버전이다. 프리뷰 기능으로 instanceof의 패턴 매칭과 record라는 데이터 오브젝트 선언이 추가되었다. 그 외에 인큐베이터라는 패키징 툴(OS에 맞춘 실행파일 생성 기능) 추가 등이 있다.</p>
<ul>
<li>instanceof 패턴 매칭</li>
</ul>
<div><pre><code><span>if</span> <span>(</span><span>!</span><span>(</span>obj <span>instanceof</span> <span>String</span> s<span>)</span><span>)</span> <span>{</span>
	<span>.</span><span>.</span> s<span>.</span><span>contains</span><span>(</span><span>.</span><span>.</span><span>)</span> <span>.</span><span>.</span>
<span>}</span> <span>else</span> <span>{</span>
	<span>.</span><span>.</span> s<span>.</span><span>contains</span><span>(</span><span>.</span><span>.</span><span>)</span> <span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>record 타입 지원</li>
</ul>
<div><pre><code><span>record</span> <span>Point</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> y<span>)</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="java-se-15"> [ JAVA SE 15 ]</h4>
<p>2020년 9월 15일 공개된 버전.</p>
<ul>
<li>EdDSA 암호화 알고리즘 추가</li>
<li>패턴 매칭 (2차 미리보기, 상단 Java 14 참조)</li>
<li>스케일링 가능한 낮은 지연의 가비지 컬렉터 추가(ZGC)</li>
<li>Solaris 및 SPARC 플랫폼 지원 제거</li>
<li>외부 메모리 접근 API (인큐베이팅)</li>
<li>레코드 (2차 미리보기, 상단 Java 14 참조)</li>
<li>클래스 봉인 (미리 보기)
<ul>
<li>상속 가능한 클래스를 지정할 수 있는 봉인 클래스가 제공</li>
<li>상속 가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해 있어야 한다</li>
</ul>
</li>
</ul>
<div><pre><code><span>package</span> <span>wiki<span>.</span>namu<span>.</span>example<span>.</span>species</span><span>;</span>  
  
<span>public</span> <span>sealed</span> <span>class</span> <span>Animal</span>  
		<span>Dog</span><span>,</span>  
	        <span><span>wiki<span>.</span>namu<span>.</span>example<span>.</span>species<span>.</span>india<span>.</span></span>Monkey</span><span>,</span>  
            <span><span>wiki<span>.</span>namu<span>.</span>example<span>.</span>species<span>.</span>sabana<span>.</span></span>Leopard</span>  
<span>{</span>  
	<span>// ...  </span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>텍스트 블록</li>
</ul>
<div><pre><code><span>String</span> html <span>=</span> <span>""" 
				&lt;html>
					&lt;body> 
						&lt;p>Hello, world&lt;/p>
					&lt;/body>
				&lt;/html> 
			"""</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><br>
<h2 id="_1005-tcp와-udp"> 1005 - TCP와 UDP</h2>
<p>TCP와 UDP는 TCP/IP의 전송계층에서 사용되는 프로토콜이다. 전송계층은 IP에 의해 전달되는 패킷의 오류를 검사하고 재전송 요구 등의 제어를 담당하는 계층이다.</p>
<h3 id="tcp-transmission-control-protocol"> TCP(Transmission Control Protocol)</h3>
<p>전송을 제어하는 프로토콜<br>
인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다. 일반적으로 TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리하게 된다. TCP는 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용한다.</p>
<h4 id="특징"> [ 특징 ]</h4>
<ul>
<li>연결형 서비스로 가상 회선 방식을 제공한다. (패킷 전송을 위한 논리적 경로를 배정)</li>
<li>3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.</li>
<li>흐름 제어 및 혼잡 제어를 한다.</li>
<li>높은 신뢰성을 보장한다. (Sequence Number, Ack)</li>
<li>UDP보다 속도가 느리다.</li>
<li>전이중(Full-Duplex), 점대점(Point to Poin)방식이다.</li>
<li>서버와 클라이언트는 1대 1로 연결된다.</li>
<li>스트리밍 서비스에 불리하다. (손실된 경우, 재전송 요청)</li>
</ul>
<h4 id="장점"> [ 장점 ]</h4>
<ul>
<li>3-way handshaking과정은 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해서 세션을 수립하는 과정이다. TCP는 연결형 서비스로 신뢰성을 보장하기 때문에 3-way handshaking의 과정도 사용하는 것이고, 데이터의 흐름제어나 혼잡 제어와 같은 기능도 한다. 하지만 이러한 기능때문에 UDP보다 속도가 느리다.</li>
<li>통신의 신뢰성이 높다.</li>
</ul>
<h4 id="단점"> [ 단점 ]</h4>
<ul>
<li>데이터로 보내기전에 반드시 연결이 형성되어야 한다.</li>
<li>1:1 통신만 가능하다.</li>
<li>고정된 통신 경로가 최단선이 아닐경우 상대적으로 UDP보다 데이터 전송속도가 느리다.</li>
</ul>
<h3 id="udp-user-datagram-protocol"> UDP(User Datagram Protocol)</h3>
<p>사용자 데이터그램 프로토콜<br>
데이터를 데이터그램 단위로 처리하는 프로토콜이다. 여기서 데이터그램이란 독립적인 관계를 지니는 패킷이다.<br>
TCP와 달리 UDP는 비연결형 프로토콜로 연결을 위해 할당되는 논리적 경로가 없다. 때문에 각각의 패킷은 다른경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 되는데 이렇게 데이터를 독립적인 경로로 독립적으로 처리한다.<br>
즉, UDP는 발신자가 데이터 패킷을 순차적으로 보내더라도 이 패킷들은 서로 다른 통신 선로를 통해 전달될 수 있다. 먼저 보낸 패킷이 느린 선로를 통해 전송될 경우 나중에 보낸 패킷보다 늦게 도착할 수 있으며 최악의 경우 유실될 수도 있다. UDP는 중간에 패킷이 유실이나 변조가 되어도 재전송을 하지 않는다.</p>
<h4 id="특징-및-장점"> [ 특징 및 장점 ]</h4>
<ul>
<li>비연결형 서비스로 데이터크램 방식이다. (연결을 설정하고 해제하는 과정이 존재하지 않는다.)</li>
<li>정보를 주고 받을때 정보를 보내거나 받는다는 신호절차가 없다.</li>
<li>UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.</li>
<li>TCP보다 속도가 빠르다.</li>
<li>신뢰성보다는 연속성이 중요한 서비스(실시간 스트리밍 서비스)에서 자주 사용.</li>
<li>소켓 대신 IP주소를 기반으로 데이터를 전송.</li>
<li>서버와 클라이언트 구분이 없다. (1:1, 1:N, N:M 등으로 연결가능)</li>
</ul>
<h4 id="단점-2"> [ 단점 ]</h4>
<ul>
<li>신뢰성이 낮다.</li>
<li>흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.</li>
</ul>
<br>
<h2 id="_1007-자바에서-동시성-문제를-해결하는-3가지-키워드"> 1007 - 자바에서 동시성 문제를 해결하는 3가지 키워드</h2>
<h3 id="_1-synchronized"> 1. synchronized</h3>
<p><code>synchronized</code> 키워드를 통해 해당 블럭의 액세스를 동기화할 수 있다.<br>
간단히 말해서 <code>synchronized</code>가 선언된 블럭에는 동시에 하나의 스레드만 접근할 수 있다.</p>
<ul>
<li>예제</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>SomeClass</span> <span>{</span>
    <span>// 메서드 전체에 동기화 적용</span>
    <span>public</span> <span>synchronized</span> <span>void</span> <span>foo</span><span>(</span><span>)</span> <span>{</span> 
        <span>/* critical section */</span>
    <span>}</span>

    <span>// 내부에 동기화 블럭 생성</span>
    <span>public</span> <span>void</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>
            <span>/* critical section */</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>// 클래스 내부의 전역 메서드에서 동기화 블럭을 생성하는 방법</span>
<span>public</span> <span>class</span> <span>SomeClass</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>syncMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span><span>SomeClass</span><span>.</span><span>class</span><span>)</span> <span>{</span>
            <span>/* critical section */</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>synchronized method
<ul>
<li>동기화를 시키고 싶은 클래스의 메소드에 synchronized 키워드를 붙이면 되고, synchronized method는 인스턴스 단위의 synchronized 키워드가 붙은 메소드에 대해서만 lock 공유한다.</li>
</ul>
</li>
<li>static synchronized method
<ul>
<li>static synchronized method 는 인스턴스가 아닌 클래스 단위로 lock을 공유하며, synchronized method와 동일하게 함수 간의 동기화가 발생한다. 만약 synchronized method과 함께 사용하게 되면 인스턴스 락과 클래스 락은 공유가 안되기 때문에 동기화 이슈가 발생할 수 있다는 점을 주의해야 한다.</li>
</ul>
</li>
<li>synchronized block
<ul>
<li>synchronized(this) : 여러 스레드가 들어와 서로 다른 block을 호출해도 this를 사용해 자신에 lock을 걸었기 때문에 기다려야 한다.</li>
<li>synchronized(Object) : block마다 서로 다른 lock을 걸리게해 훨씬 효율적인 코드를 작성할 수 있다.</li>
</ul>
</li>
<li>static synchronized block
<ul>
<li>클래스 단위로 lock을 공유하나 lock객체를 지정하고 block으로 범위를 한정지을 수 없다.</li>
</ul>
</li>
</ul>
<h3 id="_2-volatile"> 2. volatile</h3>
<p>JVM에서 스레드는 실행되고 있는 CPU 메모리 영역에 데이터를 캐싱한다(CPU Cache). 따라서 멀티 코어 프로세서에서 다수의 스레드가 변수 a를 공유하더라도 캐싱된 시점에 따라 데이터가 다를 수 있으며, 서로 다른 코어의 스레드는 데이터 값이 불일치하는 문제가 생긴다.<br>
임의의 데이터를 갱신해 주지 않는 이상 캐싱 된 데이터가 언제 갱신되는지 또한 정확히 알 수 없다.<br>
이런 경우 <code>volatile</code>키워드를 사용하여 CPU 메모리 영역에 캐싱된 값이 아니라 항상 최신의 값을 가지도록 메인 메모리 영역에서 값을 참조하도록 할 수 있다. -&gt; 즉, 동일 시점에 모든 스레드가 동일한 값을 가지도록 동기화한다.</p>
<div><pre><code><span>public</span> <span>volatile</span> <span>long</span> count <span>=</span> <span>0</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>하지만 <code>volatile</code>을 통해 모든 동기화 문제가 해결되는건 아니다. 원자성이 보장되지 않는 경우 동시성 문제는 동일하게 발생한다.(단지 멀티 코어에서의 모든 스레드가 캐시 없이 최신의 값을 보게 할뿐)</p>
<h3 id="atomic-클래스"> Atomic 클래스</h3>
<p>앞에서 설명한 두 가지 키워드 <code>synchronized</code>, <code>volatile</code>만으로는 동시성 문제를 깔끔하게 해결할 수 없다.<br>
자바에서는 위 문제들을 해결하기 위해, 비-원자적 연산에서도 동기화를 빠르고 쉽게 이용하기 위한 클래스 모음을 제공한다.</p>
<blockquote>
<p>java.util.concurrent.* (대표적으로 컬렉션, Wrapper 클래스 등이 있다.)</p>
</blockquote>
<ul>
<li>java.util.concurrent.atomic.AtomicLong</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>AtomicLong</span> <span>extends</span> <span>Number</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>
	
    <span>private</span> <span>volatile</span> <span>long</span> value<span>;</span> <span>// volatile 키워드가 적용되어 있다.</span>
	
    <span>public</span> <span>final</span> <span>long</span> <span>incrementAndGet</span><span>(</span><span>)</span> <span>{</span> <span>// value 값을 실제로 증가시키는 메서드</span>
        <span>return</span> <span>U</span><span>.</span><span>getAndAddLong</span><span>(</span><span>this</span><span>,</span> VALUE<span>,</span> <span>1L</span><span>)</span> <span>+</span> <span>1L</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>jdk.internal.misc.Unsafe</li>
</ul>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>Unsafe</span> <span>{</span>
    <span>// 메모리에 저장된 값과 CPU에 캐시된 값을 비교해 동일한 경우에만 update 수행</span>
    <span>public</span> <span>final</span> <span>long</span> <span>getAndAddLong</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span> <span>long</span> delta<span>)</span> <span>{</span>
        <span>long</span> v<span>;</span>
        <span>do</span> <span>{</span>
            v <span>=</span> <span>getLongVolatile</span><span>(</span>o<span>,</span> offset<span>)</span><span>;</span>
        <span>}</span> <span>while</span> <span>(</span><span>!</span><span>weakCompareAndSetLong</span><span>(</span>o<span>,</span> offset<span>,</span> v<span>,</span> v <span>+</span> delta<span>)</span><span>)</span><span>;</span> <span>// CAS 알고리즘 (JNI 코드로 이루어져 있다.)</span>
        <span>return</span> v<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>Non-Blocking 임에도 동시성을 보장하는 이유는 CAS(Compare-and-swap) 알고리즘을 이용하기 때문이다.</p>
<ul>
<li>valatile 키워드를 이용하면서 현재 스레드에 저장된 값과 메인 메모리에 저장된 값을 비교한다.
<ul>
<li>일치하지 않는 경우 새로운 값으로 교체(thread-safe 한 상태이므로 로직 수행)</li>
<li>일치하지 않는 경우 실패 후 재시도(thread-safe 하지 않은 상태였으므로 재시도)</li>
</ul>
</li>
</ul>
<blockquote>
<p>성능비교 및 마무리</p>
</blockquote>
<ul>
<li>Blocking(synchronized)</li>
</ul>
<div><pre><code><span>private</span> <span>static</span> <span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
<span>private</span> <span>static</span> <span>int</span> maxCnt <span>=</span> <span>1000</span><span>;</span>
<span>private</span> <span>static</span> <span>long</span> count <span>=</span> <span>0</span><span>;</span>

<span>@Test</span>
<span>void</span> <span>threadNotSafe</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> maxCnt<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>this</span><span>::</span><span>plus</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span> <span>// 모든 스레드가 종료될때 까지 잠깐 대기</span>
    <span>Assertions</span><span>.</span><span>assertThat</span><span>(</span>count<span>)</span><span>.</span><span>isEqualTo</span><span>(</span>maxCnt<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>synchronized</span> <span>void</span> <span>plus</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>++</span>count <span>==</span> maxCnt<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> startTime<span>)</span><span>;</span>
    <span>}</span>
    <span>try</span> <span>{</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>평균 1300ms 정도 소요되었다. (Blocking 연산에서 1000개의 스레드가 각각 1ms의 추가 딜레이를 가지기 때문)</p>
<ul>
<li>Non-Blocking (AtomicLong)</li>
</ul>
<div><pre><code><span>private</span> <span>static</span> <span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
<span>private</span> <span>static</span> <span>int</span> maxCnt <span>=</span> <span>1000</span><span>;</span>
<span>private</span> <span>static</span> <span>AtomicLong</span> count2 <span>=</span> <span>new</span> <span>AtomicLong</span><span>(</span><span>)</span><span>;</span>

<span>@Test</span>
<span>void</span> <span>threadNotSafe2</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> maxCnt<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>this</span><span>::</span><span>plus2</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span> <span>// 모든 스레드가 종료될때 까지 잠깐 대기</span>
    <span>Assertions</span><span>.</span><span>assertThat</span><span>(</span>count2<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span>maxCnt<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>void</span> <span>plus2</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>count2<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span> <span>==</span> maxCnt<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> startTime<span>)</span><span>;</span>
    <span>}</span>
    <span>try</span> <span>{</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>평균 140ms 정도 소요되었다. (Non-Blocking 연산에서 1ms의 추가 딜레이는 큰 의미가 없다.)</p>
<p><em><strong>임의로 딜레이를 주었기 때문에 드라마틱하게 차이가난다</strong></em></p>
<br>
<h2 id="_1008-자바-설계-결함"> 1008 - 자바 설계 결함</h2>
<h4 id="_1-generics의-타입을-runtime에-활용할-수-없다"> 1. Generics의 타입을 Runtime에 활용할 수 없다.</h4>
<ul>
<li>
<p>제네릭이란?</p>
<ul>
<li>자바의 제네릭이란 클래스와 함수등에 type을 마치 매개변수 값처럼 넣어 줌으로서 컴파일 타임에 미리 타입오류를 검출 할 수 있도록 하는 개념.</li>
</ul>
</li>
<li>
<p>제네릭의 한계</p>
<ul>
<li>제네릭을 활용해 컴파일 타임에 타입 체크를 하고 나면 제네릭 인자로 넘겨져 온 타입은 Type erasure라는 절차를 통해 제거된다. 따라서 인자로 넘겨진 타입은 Runtime에서는 활용 될 수 없다.</li>
</ul>
</li>
</ul>
<div><pre><code><span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> li <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>ArrayList</span><span><span>&lt;</span><span>Float</span><span>></span></span> lf <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Float</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>li<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>==</span> lf<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span> <span>{</span> <span>// evaluates to true</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Equal"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>위와 같은 코드는 제네릭 타입인자 값이 다르지만 같은 클래스로 인정된다. Runtime에는 타입이 지워지기 때문이다.</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>MyClass</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>myMethod</span><span>(</span><span>Object</span> item<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>item <span>instanceof</span> <span>E</span><span>)</span> <span>{</span>  <span>//Compiler error</span>
            <span>.</span><span>.</span><span>.</span>
        <span>}</span>
        <span>E</span> item2 <span>=</span> <span>new</span> <span>E</span><span>(</span><span>)</span><span>;</span>   <span>//Compiler error</span>
        <span>E</span><span>[</span><span>]</span> iArray <span>=</span> <span>new</span> <span>E</span><span>[</span><span>10</span><span>]</span><span>;</span> <span>//Compiler error</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>또한 다음과 같은 코드에서 instanceof. new등의 연산자를 활용할 수 없는 이유도 Type erasure 때문이다.</li>
</ul>
<h4 id="_2-unsigned-integer-types가-없다"> 2. Unsigned integer types가 없다.</h4>
<ul>
<li>자바에는 기본적으로 c, c++등에서 존재하는 unsigned 자료형이 존재하지 않는다.</li>
<li>암호학과 같이 매우 큰 양의 정수를 활용해 다양한 처리를 하는 분야에서 사용하기에 부적합할 수 있다.</li>
<li>2의 보수 표현이나 비트관점에서의 표현을 잘 이해하고 사용하려는 노력을 기울인다면 해결할 수 있는 문제이기는 하지만 개발할 때의 추가적인 노력이 필요하다.</li>
</ul>
<h4 id="_3-operator-everloading을-할-수-없다"> 3. Operator everloading을 할 수 없다.</h4>
<ul>
<li>자바에서는 연산자 오버로딩을 허용하지 않는다.(예외적으로 String의 +, += 연산자만이 유일하게 존재한다.)</li>
<li>수학적인 내용의 객체들에 대해서 가독성을 떨어뜨리고 활용하는데에 불편한 점이 있다.</li>
</ul>
<h4 id="_4-배열-크기가-2-31으로-제한된다"> 4. 배열 크기가 2^31으로 제한된다.</h4>
<ul>
<li>메모리등의 문제가 아니라 배열자체의 크기를 int자료형으로 정의하기로 되어있기 때문에 2^31보다 큰 배열은 정의할 수 없다.</li>
</ul>
<h4 id="_5-primitives-type과-array가-클래스와-다르게-취급됨"> 5. primitives type과 Array가 클래스와 다르게 취급됨.</h4>
<ul>
<li>다른 클래스들과 다르게 원시값과 배열은 다른 방식의 문법이 활용되는데 언어를 익히거나 활용하는점에서 비효율을 생선한다.</li>
</ul>
<br>
<h2 id="_1009-jackson-objectmapper"> 1009 - Jackson ObjectMapper</h2>
<div><pre><code><span>@Getter</span>
<span>@Setter</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>Cat</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>

    <span>public</span> <span>Cat</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>Object to Json</li>
</ul>
<div><pre><code><span>ObjectMapper</span> objectMapper <span>=</span> <span>new</span> <span>ObjectMapper</span><span>(</span><span>)</span><span>;</span>

<span>Cat</span> cat <span>=</span> <span>new</span> <span>Cat</span><span>(</span><span>"kitty"</span><span>)</span><span>;</span>
<span>String</span> catString <span>=</span> objectMapper<span>.</span><span>writeValueAsString</span><span>(</span>cat<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"catString : "</span> <span>+</span> catString<span>)</span><span>;</span>

<span>--</span><span>-</span> output <span>--</span><span>-</span>
catString <span>:</span> <span>{</span><span>"name"</span><span>:</span><span>"kitty"</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>Json to Object</li>
</ul>
<div><pre><code><span>String</span> json <span>=</span> <span>"{\"name\":\"kitty\"}"</span><span>;</span>
<span>Cat</span> cat2 <span>=</span> objectMapper<span>.</span><span>readValue</span><span>(</span>json<span>,</span> <span>Cat</span><span>.</span><span>class</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"cat2 name :  "</span> <span>+</span> cat2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>--</span><span>-</span> output <span>--</span><span>-</span>
cat2 name <span>:</span>  kitty
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>Json to Jackson JsonNode</li>
</ul>
<div><pre><code><span>JsonNode</span> jsonNode <span>=</span> objectMapper<span>.</span><span>readTree</span><span>(</span>json<span>)</span><span>;</span>
<span>String</span> name <span>=</span> jsonNode<span>.</span><span>get</span><span>(</span><span>"name"</span><span>)</span><span>.</span><span>asText</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Tree cat2 name : "</span> <span>+</span> name<span>)</span><span>;</span>

<span>--</span><span>-</span> output <span>--</span><span>-</span>
<span>Tree</span> cat2 name <span>:</span> kitty
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>Json List to List</li>
</ul>
<div><pre><code><span>String</span> jsonList <span>=</span> <span>"[{\"name\":\"kitty\"},{\"name\":\"kitty2\"}]"</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Cat</span><span>></span></span> cats <span>=</span> objectMapper<span>.</span><span>readValue</span><span>(</span>jsonList<span>,</span> <span>new</span> <span>TypeReference</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Cat</span><span>></span><span>></span></span><span>(</span><span>)</span> <span>{</span><span>}</span><span>)</span><span>;</span>
<span>for</span> <span>(</span><span>Cat</span> catElement <span>:</span> cats<span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"catElement : "</span> <span>+</span> catElement<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>--</span><span>-</span> output <span>--</span><span>-</span>
catElement <span>:</span> kitty
catElement <span>:</span> kitty2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0926 ~ 1002</title>
      <link>ahnjs/TIL/2022/0926/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0926/</guid>
      <source url="ahnjs/TIL/rss.xml">0926 ~ 1002</source>
      <pubDate>Sun, 25 Sep 2022 14:29:17 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0926-1002"> 0926 ~ 1002</h1>
<h2 id="_0926-https-동작-과정"> 0926 - HTTPS 동작 과정</h2>
<h3 id="https란"> HTTPS란?</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTIQPl%2Fbtq0kDsepHd%2FUzzv6JatoLtsDsdvXFZmsk%2Fimg.png" alt="image">
HTTPS는 HyperText Transfer Protocol Secure의 약자이며 HTTP의 보안 버전이다.<br>
HTTPS는 TCP 위에 SSL/TLS 층을 추가하여 암호화, 인증 그리고 무결성 보장을 통해 더 안전하게 만들어주는 프로토콜이다.</p>
<h4 id="대칭키"> [ 대칭키 ]</h4>
<p>암호화에 쓰이는 키와 복호화에 쓰이는 키가 동일한 기법<br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FW94Qi%2Fbtq0teEbVJK%2FWKelKm2z3UqPpQOCQ2KKL0%2Fimg.png" alt="image">
만약 클라이언트와 서버가 대칭키 방식으로 통신을 한다면 클라이언트도 키를 가지고 있어야 한다.<br>
클라이언트에게 키를 전달하기도 위험하며 클라이언트의 소스코드는 누구든지 열어볼 수 있으므로 가지고 있기도 굉장히 위험하다.<br>
즉, 원거리에서 대칭키를 안전하게 전달하는 것은 매우 어렵다.</p>
<h4 id="공개키-비대칭키"> [ 공개키(비대칭키) ]</h4>
<p>공개키와 개인키(비밀키)라는 2가지 키를 사용하는 기법이다.<br>
공개키는 말그대로 누구나 획득할 수 있는 공개된 키를 뜻한다. 정보를 보내는쪽(클라이언트)은 이 키를 가지고 데이터를 암호화해서 전송한다.<br>
개인키(비밀키)는 공개키로 암호화된 데이터를 복호화 할 수 있는 키로써 자신(서버)만이 가지고 있는 키다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAGD4h%2Fbtq0pypJPGx%2FkkTh7vd6VMgrbRnJAF8KH0%2Fimg.png" alt="image">
이 방법은 안전하게 데이터를 주고받을 수 있게 만들어주지만 속도가 느리다는 단점이있다.</p>
<h4 id="인증서와-ca-certificate-authority"> [ 인증서와 CA(Certificate authority) ]</h4>
<p>SSL을 적용하기 위해서는 인증서라는 것이 필요하다.<br>
인증서의 내용은 크게 2가지로 구분할 수 있다.</p>
<ol>
<li>서비스의 정보 (CA, 도메인 등등)</li>
<li>서버 측의 공개키 (공개키의 내용, 공개키의 암호화 방식)<br>
이 인증서를 발급해주는 기업을 CA라고 한다. 인증서가 보안에 관련된 것인 만큼 이 CA는 영향력있고 신뢰할 수 있는 기업에서만 가능하다.<br>
그리고 우리의 브라우저는 CA리스트를 미리 가지고 있다. CA목록에 있는 기업을 공인된 CA라고 하며 목록에 없는 기업을 사설 CA라고한다.</li>
</ol>
<h3 id="https-통신과정-및-원리"> HTTPS 통신과정 및 원리</h3>
<p>간단하게 들여다보면 동작방식은 대칭키와 공개키(비대칭키) 방식을 전부 사용하는 하이브리드 방식이다.<br>
데이터 전송을 위해 대칭키 방식을 사용하며 대칭키를 안전하게 전달하기 위해 공개키 방식을 사용한다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbE36KD%2Fbtq0tfDkLaZ%2FazI7Wlmon3eCzE5dQKNCq0%2Fimg.png" alt="image"></p>
<h4 id="_1-client-hello"> 1. Client Hello</h4>
<p>브라우저 마다 지원하는 암호화 알고리즘과 TLS 버전이 다르므로 해당 정보를 전송하며, 난수 값을 생성하여 전송한다.</p>
<h4 id="_2-server-hello"> 2. Server Hello</h4>
<p>사용할 TSL 버전, 사용할 암호화 알고리즘, 난수값을 전송</p>
<h4 id="_3-certificate"> 3. Certificate</h4>
<p>CA로 부터 발급받은 인증서를 전송한다.</p>
<h4 id="_4-server-key-exchange"> 4. Server Key Exchange</h4>
<p>키 교환에 필요한 정보를 제공한다. 만약 필요하지 않으면 이 과정은 생략이 가능한데, 예를 들어 키교환 알고리즘을 Diffie-Hellman으로 사용한다면 소수, 원시근 등이 필요하므로 이것을 전송한다.</p>
<h4 id="_5-certificate-request"> 5. Certificate Request</h4>
<p>서버가 클라이언트를 인증해야할때 인증서를 요구하는 단계이다. 요청하지 않을 수 도 있다.</p>
<h4 id="_6-serverhello-done"> 6. ServerHello Done</h4>
<h4 id="_7-client-key-exchange-change-cipher-spec"> 7. Client Key Exchange, Change Cipher Spec</h4>
<p>pre-master-key 라는 것을 전송한다. 이 키는 1,2 단계에서 생성한 난수를 조합하여 생성하게되며 대칭키로 사용하게될 예정이다. 그러므로 안전한 정송을 위해서 공개키 방식을 사용하여 전송한다.</p>
<h4 id="_8-change-cipher-spec"> 8. Change Cipher Spec</h4>
<p>클라이언트로 부터 전송받은 Pre-master-key를 정상적으로 복호화 후 master-key(대칭키)로 승격 후 보안 파라미터를 적용하거나 변경될때 보내는 알람이다.</p>
<br>
<h2 id="_0927-조회-빈-bean-이-2개-이상일때-동적으로-선택하는-방법"> 0927 - 조회 빈(Bean)이 2개 이상일때 동적으로 선택하는 방법</h2>
<ul>
<li>인터페이스 및 구현체</li>
</ul>
<div><pre><code><span>interface</span> <span>SampleInterface</span> <span>{</span>  
   <span>.</span><span>.</span><span>.</span>  
<span>}</span>

<span>@Repository</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>.</span><span>.</span><span>.</span>  
<span>}</span>

<span>@Repository</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceOtherImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>.</span><span>.</span><span>.</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="모든-인터페이스를-선언해놓고-분기처리"> 모든 인터페이스를 선언해놓고 분기처리</h3>
<div><pre><code><span>@Controller</span>  
<span>public</span> <span>class</span> <span>SampleController</span> <span>{</span>  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceImpl</span> basic<span>;</span>  
  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceOtherImpl</span> other<span>;</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/Basic"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>basic</span><span>(</span><span>)</span> <span>{</span>  
        basic<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/Other"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>other</span><span>(</span><span>)</span> <span>{</span>  
        other<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="인터페이스를-map에-넣어두고-꺼내서-사용"> 인터페이스를 Map에 넣어두고 꺼내서 사용</h3>
<div><pre><code><span>@Controller</span>  
<span>public</span> <span>class</span> <span>SampleController</span> <span>{</span>  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceImpl</span> basic<span>;</span>  
  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceOtherImpl</span> other<span>;</span>  
  
    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SampleInterface</span><span>></span></span> services<span>;</span>  
  
    <span>@PostConstruct</span>  
    <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>  
        services <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span><span>&lt;</span><span>></span></span><span>;</span>  
        services<span>.</span><span>put</span><span>(</span><span>"Basic"</span><span>,</span> basic<span>)</span><span>;</span>  
        services<span>.</span><span>put</span><span>(</span><span>"Other"</span><span>,</span> other<span>)</span><span>;</span>  
    <span>}</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/{service}"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>@PathVariable</span><span>(</span><span>"service"</span><span>)</span> <span>String</span> service<span>)</span><span>{</span>  
        <span>SampleInterface</span> sample <span>=</span> services<span>.</span><span>get</span><span>(</span>service<span>)</span><span>;</span>  
        <span>// remember to handle the case where there's no corresponding service  </span>
        sample<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="applicationcontext를-활용"> ApplicationContext를 활용</h3>
<p>구현체를 bean으로 등록하고</p>
<div><pre><code><span>@Component</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>public</span> <span>void</span> <span>sampleMethod</span><span>(</span><span>)</span> <span>{</span>  
        <span>// ...  </span>
    <span>}</span>  
<span>}</span>  
  
<span>@Component</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceOtherImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>public</span> <span>void</span> <span>sampleMethod</span><span>(</span><span>)</span> <span>{</span>  
        <span>// ...  </span>
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>ApplicationContext의 getBean()으로 구현체를 로딩하여 사용한다.</p>
<div><pre><code><span>@Controller</span>  
<span>public</span> <span>class</span> <span>SampleController</span> <span>{</span>  
    <span>@Autowired</span>  
    <span>private</span> <span>ApplicationContext</span> appContext<span>;</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/{service}"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>@PathVariable</span><span>(</span><span>"service"</span><span>)</span> <span>String</span> service<span>)</span><span>{</span>  
        <span>SampleInterface</span> sample <span>=</span> appContext<span>.</span><span>getBean</span><span>(</span>service<span>,</span> <span>SampleInterface</span><span>.</span><span>class</span><span>)</span><span>;</span>  
        sample<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="spring의-di-활용"> Spring의 DI 활용</h3>
<p>set이나 list, map을 통해 자동으로 등록한다.</p>
<div><pre><code><span>@Autowired</span>  
<span>private</span> <span>List</span><span><span>&lt;</span><span>SampleInterface</span><span>></span></span> <span>SampleInterfaces</span><span>;</span>

<span>--</span><span>-</span>

<span>@Autowired</span>  
<span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SampleInterface</span><span>></span></span> <span>SampleInterfaceMap</span><span>;</span>

<span>--</span><span>-</span>

<span>void</span> <span>excuteSampleMethod</span><span>(</span><span>)</span> <span>{</span>  
    <span>String</span> interfaceName <span>=</span> <span>""</span>  
      
    <span>//enum으로 구분하거나, 조건에 맞게 수동으로분기하거나 서비스에맞게 고른다.  </span>
    <span>if</span> <span>(</span><span>isFirst</span><span>(</span><span>)</span><span>)</span> <span>{</span>  
        interfaceName <span>=</span> <span>"SampleInterfaceImpl"</span>  
    <span>}</span> <span>else</span> <span>{</span>  
        interfaceName <span>=</span> <span>"SampleInterfaceOtherImpl"</span>  
    <span>}</span>  
  
    <span>SampleInterface</span> impl <span>=</span> <span>SampleInterfaceMap</span><span>.</span><span>get</span><span>(</span>interfaceName<span>)</span><span>;</span>  
    impl<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>enum으로 정책 정하기</li>
</ul>
<div><pre><code><span>public</span> <span>enum</span> <span>SampleType</span> <span>{</span>  
    <span>SAMPLE</span><span>(</span><span>"SampleInterfaceImpl"</span><span>)</span><span>,</span>  
    <span>OTHERS</span><span>(</span><span>"SampleInterfaceOtherImpl"</span><span>)</span>  
  
    <span>SampleType</span><span>(</span><span>String</span> implementation<span>)</span> <span>{</span>  
        <span>this</span><span>.</span>implementation <span>=</span> implementation<span>;</span>  
    <span>}</span>  
  
    <span>public</span> <span>String</span> <span>getImplementation</span><span>(</span><span>)</span> <span>{</span>  
        <span>return</span> <span>this</span><span>.</span>implementation<span>;</span>  
    <span>}</span>  
<span>}</span>

<span>--</span><span>-</span> 

<span>void</span> <span>excuteSampleMethod</span><span>(</span><span>SampleType</span> sampleType<span>)</span> <span>{</span>      
  
    <span>SampleInterface</span> impl <span>=</span> <span>SampleInterfaceMap</span><span>.</span><span>get</span><span>(</span>sampleType<span>.</span>getImplementation<span>)</span><span>;</span>  
    impl<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
<span>}</span>

<span>--</span><span>-</span> 

<span>@Component</span>  
<span>@RequiredArgsConstructor</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceRouter</span> <span>{</span>  
  
    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>SampleInterface</span><span>></span></span> sampleInterfaces<span>;</span> <span>//의존성 List로 주입  </span>
  
    <span>public</span> <span>SampleInterface</span> <span>getImplemetationByType</span><span>(</span><span>SampleType</span> sampleType<span>)</span> <span>{</span>  
        <span>return</span> sampleInterfaces<span>.</span><span>stream</span><span>(</span><span>)</span>  
                            <span>.</span><span>filter</span><span>(</span>e <span>-></span> e<span>.</span><span>isAvailableType</span><span>(</span>sampleType<span>)</span><span>)</span> <span>//각 구현체에서 판단  </span>
                            <span>.</span><span>findFirst</span><span>(</span><span>)</span><span>.</span><span>orElseThrow</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>new</span> <span>NotSupportedTypeException</span><span>(</span><span>)</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><br> 
<h2 id="_0929-java-hashmap"> 0929 - Java HashMap</h2>
<h3 id="hash"> Hash</h3>
<p>Hash는 자료를 일정한 형식의 식별 값이다.</p>
<ul>
<li>Key : 고유한 값, Hash function의 input.</li>
<li>Hash function : Key를 Hash로 변경해주는 역할을 한다.</li>
<li>Hash Code(또는 Hash Value) : 해시 함수를 통해 얻는 값으로, 해시를 인덱스 또는 주소로 삼아 Value에 접근이 가능하도록 한다.</li>
<li>Value : Key와 1:1로 매핑되어 있는 값으로 Bucket안에 들어가 있는 실제 값이다.</li>
<li>Bucket : 해시와 매핑되는 값(Value)이 저장되어 있는 공간이다.</li>
</ul>
<h3 id="hashmap"> HashMap</h3>
<ul>
<li>HashMap은 Key-Value가 1:1로 Mapping 되는 자료구조이며, Mapping으로 인해 삽입, 삭제, 검색이 평균적으로 O(1)인 자료구조이다. Key는 중복을 허용하지 않지만, Value는 중복을 허용한다.</li>
<li>Java HashMap의 Key는 Object 형을 지원하기 때문에 완전한 해시 함수가 아니다.</li>
<li>Java HashMap의 index는 <code>hashCode() % M</code>(M = 해시 버킷의 개수)로 산출할 수 있다.</li>
<li>Java HashMap 해시 충돌이 일어날 경우, 충돌 처리방법으로 Worst Case발생 빈도를 줄일 수 있는 Separate Chaining방식을 사용한다.</li>
<li>Java8이상 HashMap에서는 하나의 해시 버킷에 8개의 key-value 쌍이 모이면 링크드리스트를 트리로 변경하고, 데이터가 삭제되어 8개에 이르면 다시 링크드 리스트로 변경한다.</li>
<li>String 클래스의 hashCode() 메서드에서는 성능 향상 도모를 위해 31을 승수로 사용한다.</li>
</ul>
<br>
<h2 id="_0930-maven-package와-install차이"> 0930 - Maven package와 install차이</h2>
<h3 id="maven-빌드-라이프사이클-단계"> Maven 빌드 라이프사이클 단계</h3>
<ul>
<li>validate : 프로젝트가 정확하고 필요한 모든 정보를 사용할 수 있는지 확인</li>
<li>compile : 프로젝트 소스 코드 컴파일</li>
<li>test : 단위 테스트 프레임워크를 사용하여 컴파일된 소스 코드를 테스트</li>
<li>package : 컴파일된 코드를 가져와 JAR와 같은 배포 가능한 형태로 패키징</li>
<li>verify : 품질 기준이 충족되어있는지 확인하기 위해 통합 테스트 결과에 대한 모든 검사 실행</li>
<li>install : 로컬에서 다른 프로젝트에서 종속성으로 사용하기 위해 패키지를 로컬 저장소에 설치</li>
<li>deploy : 빌드 환경에서 완료되면 다른 개발자 및 프로젝트와 공유하기 위해 최종 패키지를 원격 저장소에 복사</li>
</ul>
<h4 id="차이점"> [ 차이점 ]</h4>
<p>package와 install의 가장 큰 차이점은 install의 경우 package 후 만들어진 산출물을 같은 머신의 로컬 저장소에 배포하여 종속성이 있는 다른 프로젝트에서 사용할 수 있게 해준다는 점</p>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTIQPl%2Fbtq0kDsepHd%2FUzzv6JatoLtsDsdvXFZmsk%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0919 ~ 0925</title>
      <link>ahnjs/TIL/2022/0919/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0919/</guid>
      <source url="ahnjs/TIL/rss.xml">0919 ~ 0925</source>
      <pubDate>Sun, 18 Sep 2022 13:56:26 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0919-0925"> 0919 ~ 0925</h1>
<h2 id="_0919-value와-configurationproperties의-사용법-및-차이"> 0919 - @Value와 @ConfigurationProperties의 사용법 및 차이</h2>
<p>Spring에서 프로퍼티에 있는 값을 불러오는 다양한 방법들이 있다. 대표적인 방식으로 @Value와 @ConfigurationProperties가 있다.</p>
<h3 id="value와-configurationproperties의-사용법-및-차이"> @Value와 @ConfigurationProperties의 사용법 및 차이</h3>
<p>스프링의 properties나 yaml에 있는 값들은 애플리케이션이 실행되면서 환경변수로 Environment에 등록이 된다. 그리고 해당 값들을 꺼내서 애플리케이션에서 활용하기 위한 방법으로는 @Value와 @ConfigurationProperties가 있다.</p>
<h4 id="value-어노테이션"> [ @Value 어노테이션 ]</h4>
<p>@Value는 단일 값을 주입받기 위해서 사용된다. 값을 가져오기 위해서는 PropertyPlaceHolderConfigurer를 통해 ${}을 사용하는 방식과 SpEL을 통해 #{}을 이용하는 방식 크게 2가지를 사용할 수 있다.<br>
@Value를 이용해 값을 가져올 때에는 RelaxedBinding이라는 것이 적용되지 않는다. Relaxed Binding이란 프로퍼티 값의 이름이 조금 달라도 유연하게 바인딩을 시켜주는 규칙을 의미한다.</p>
<div><pre><code>server.admin-what-is-real-name=ajs
</code></pre>
<div><span>1</span><br></div></div><p>@Value는 Relaxed Binding이 적용되지 않으므로 완벽히 일치하는 프로퍼티 이름으로만 값을 가져올 수 있따.</p>
<div><pre><code><span>@Value</span><span>(</span><span>"${server.admin-what-is-real-name}"</span><span>)</span>
<span>private</span> <span>String</span> adminName<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>단일 값을 주입받기 위해 사용됨</li>
<li>RelaxedBinding 적용되지 않음</li>
</ul>
<h4 id="configurationproperties-어노테이션"> [ @ConfigurationProperties 어노테이션 ]</h4>
<p>@ConfigurationProperties는 프로퍼티에 있는 값을 클래스로 바인딩하기 위해 사용되는 어노테이션이다. @ConfigurationProperties는 값의 바인딩을 위해 Setter를 필요로 하며 생성자가 바인딩하기 위해서는 ConstructorBinding을 붙여주어야 한다.</p>
<p>@ConfigurationProperties를 사용하기 위해서는 @EnableConfigurationProperties에 해당 클래스를 지정해주거나 @ConfigurationPropertiesScan를 통해 스캐닝의 대상이 되도록 해주어야 한다.</p>
<p>@ConfigurationProperties는 기본적을 RelaxedBinding이 적용된다. 예를 들어 위에서 봤던 프로퍼티 값을 불러오고자 한다면 다음과 같이 바인딩해도 된다.</p>
<div><pre><code><span>@Getter</span>
<span>@Setter</span>
<span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span> <span>"server"</span><span>)</span>
<span>public</span> <span>class</span> <span>ServerInfo</span> <span>{</span>

    <span>private</span> <span>final</span> <span>String</span> adminWhatIsRealName<span>;</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>RelaxedBinding이 적용되는 규칙들로는 다음과 같은 것들이 있다.</p>
<ul>
<li>server.admin-what-is-real-name : properties와 .yml에 권장되는 표기법</li>
<li>server.adminWhatIsRealName : 표준 카멜 케이스 문법</li>
<li>server.admin_what_is_real_name : .properties와 .yml 에서 사용가능한 표기법 ( - 표기법이 더 표준임)</li>
<li>SERVER_ADMIN_WHAT_IS_REAL_NAME : 시스템 환경 변수를 사용할 때 권장되는 표기법</li>
</ul>
<p>위의 4가지 표기법들은 @ConfigurationProperties로 값이 바인딩될 때 RelaxedBinding에 의해 올바르게 바인딩 된다. 또한 @ConfigurationProperties는 클래스로 값을 바인딩하므로 한번에 여러 값을 바인딩 받을 수 있다.<br>
하지만 @ConfigurationProperties에는 spEL이 사용될 수 없다는 단점이 있다.</p>
<h3 id="value와-configurationproperties의-차이-요약"> @Value와 @ConfigurationProperties의 차이 요약</h3>
<h4 id="value와-configurationproperties의-차이-요약-2"> [ @Value와 @ConfigurationProperties의 차이 요약 ]</h4>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FB8NtE%2FbtrqMkNrQtK%2FJ1ZrM4Z9WVvVyHFDcumWS1%2Fimg.png" alt="image"></p>
<p>Spring에서는 여러 값을 바인딩받아야 하는 경우에 @ConfigurationProperties를 사용하도록 권장하고 있다. 또한 @ConfigurationProperties는 RelaxedBinding이 적용되므로 보다 유연하게 값을 바인딩할 수 있다.</p>
<br>
<h2 id="_0920-설정-값-분리의-필요성과-value의-사용법-및-동작과정"> 0920 - 설정 값 분리의 필요성과 @Value의 사용법 및 동작과정</h2>
<h3 id="설정-값-분리의-필요성"> 설정 값 분리의 필요성</h3>
<h4 id="설정-값-분리의-필요성-2"> [ 설정 값 분리의 필요성 ]</h4>
<p>개발을 진행하다 보면 데이터베이스 연결 정보나 외부 API 주소 등과 같은 메타 정보들을 관리해야 한다. 해당 메타정보들을 클래스 파일에 넣을 수 도 있겠지만 다음과 같은 이유로 프로퍼티 파일(properties)나 야믈 파일(yaml, yml)로 분리해서 관리할 것을 권장한다.</p>
<ol>
<li>
<p>환경에 따라 유연하게 값을 설정할 수 있음<br>
일반적으로 로컬 환경이나 알파/스테이지 환경 그리고 운영 환경에 따라 서로 다른 데이터베이스 서버를 가지고 있다. 만약 환경에 따라 다른 값을 자바 코드만으로 설정해주려면 상당히 번거롭고 중복되는 코드가 상당히 많아진다. 그래서 설정값은 별도의 파일(properties 또는 yaml)로 분리하고, 자바 코드에서는 환경 정보에 맞는 설정값을 불러오도록 하면 상당히 유용하다.</p>
</li>
<li>
<p>초기값을 설정할 수 있음<br>
또한 불러오는 설정 값에 초기값을 지정해줄 수 있는데, 이를 통해 설정한 값이 불러지지 않은 경우에 대비할 수 있으며 테스트 작성을 용이하게 할 수 있다. 즉, 초기값을 설정함으로써 테스트 작성에 유연하고 안전하게 개발을 할 수 있는 것이다.</p>
</li>
<li>
<p>불필요한 컴파일을 줄일 수 있음<br>
만약 프로퍼티를 분리하지 않는다면 값이 클래스 안에 있을 것이다. 그럴때 만약 값이 수정되면 소스코드가 변하는 것이므로 다시 컴파일을 해주어야 할 것이다. 하지만 설정 파일을 분리하고 @Value로 참조하게 한다면 불필요한 컴파일없이 주입되는 값을 변경할 수 있다.</p>
</li>
</ol>
<h4 id="value의-사용법과-처리-및-동작-과정"> [ @Value의 사용법과 처리 및 동작 과정 ]</h4>
<p>@Value로 메타 정보를 가져오는 방법으로는 PropertyPlaceHolderConfigurer를 통해 ${}을 사용하는 방식과 SpEL을 통해 #{}을 이용하는 방식 크게 2가지가 있다.</p>
<ol>
<li>PropertyPlaceHolderConfigurer를 통한 수동 변환<br>
PropertyPlaceHolderConfigurer은 빈 팩토리 후처리기로써 매번 빈 오브젝트가 만들어진 직후에 오브젝트의 내용이나 오브젝트 자체를 변경하는 빈 후처리기와 달리 빈 설정 메타정보가 모두 준비됐을 때 빈 메타정보 자체를 조작하기 위해 사용된다.<br>
예를 들어 database.username과 같이 properties에 작성된 키 값을 ${}안에 넣어주면 Spring이 PropertyPlaceHolderConfigurer를 통해 초기화 작업 중에 해당 값을 실제 값으로 치환한다.<br>
예를 들어 다음과 같이 사용할 수 있다.</li>
</ol>
<div><pre><code>database<span>.</span>username <span>=</span> admin
database<span>.</span>className<span>=</span><span><span>org<span>.</span>mariadb<span>.</span>jdbc<span>.</span></span>Driver</span>

<span>@Value</span><span>(</span><span>"${database.username}"</span><span>)</span>
<span>private</span> <span>String</span> userName<span>;</span>

<span>@Value</span><span>(</span><span>"${database.className}"</span><span>)</span>
<span>private</span> <span>String</span> className<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>하지만 이런 방법은 대체할 위치를 치환자로 지정해두고, 별도의 후처리기가 값을 변경해주기를 기대하기 때문에 수동적이다. 그래서 초기 빈 메타정보에는 ${database.username}와 같은 문자열이 등록되어 있다. 그러다가 스프링 컨테이너가 설정 파일에서 대체할 적절한 키 값을 찾지 못하면 해당 문자열이 그대로 남아있게 된다. 그래서 치환자의 값이 변경되지 않더라도 예외가 발생하지 않으므로 SpEL을 통한 능동변환을 권장한다.<br>
초기에는 PropertyPlaceHolderConfigurer를 사용하는 방식을 사용했어야 했지만 Spring3부터 SpEL을 지원하면서 이를 이용하는 방식을 권장하고 있다.<br>
물론 최근 Spring의 버전이 높아지고, 이러한 문제를 개선한 PropertySourcesPlaceholderConfigurer가 등장하면서 적절한 값을 찾기 못하면 에러가 발생하도록 수정되었지만 그래도 수동적인 방법보다는 빈에서 값을 꺼내는 SpEL이 권장된다.</p>
<ol start="2">
<li>SpEL을 통한 능동 변환<br>
SpEL은 스프링 3.0에서 처음 소개된 스프링 전용 표현식 언어로 이를 통해 다른 빈 오브젝트나 프로퍼티에 손쉽게 접근할 수 있다. SpEL은 기본적으로 #{} 안에 표현식을 넣도록 되어있는데, user.name이라는 표현식은 이름의 user인 빈의 name 프로퍼티를 의미한다. SpEL은 일반 프로그래밍 언어 수전에 가까운 강력한 표현식 기능을 지원한다. 다른 빈의 프로퍼티에 접근가능할 뿐만 아니라 메소드 호출도 가능하고 다양한 연산도 지원하며 클래스 정보에도 접근할 수 있다. 심지어 생성자를 호출해서 객체를 생성할 수도 있다.<br>
SpEL(Spring Expression Language)를 이용하는 방법은 프로퍼티의 대체 위치를 설정해두고 빈 팩토리 후처리기가 바꿔주기를 기다리는 수동적인 방법과 달리 다른 빈 오브젝트에 직접 접근할 수 있는 표현식을 이용해 원하는 프로퍼티 값을 능동적으로 가져온다.<br>
별도의 설정이 없다면 다음과 같이 설정 파일에 작성된 값을 사용할 수 있는 것이다.</li>
</ol>
<div><pre><code>database<span>.</span>username <span>=</span> admin
database<span>.</span>className<span>=</span><span><span>org<span>.</span>mariadb<span>.</span>jdbc<span>.</span></span>Driver</span>

<span>@Value</span><span>(</span><span>"#{environment['database.username']}"</span><span>)</span>
<span>private</span> <span>String</span> userName<span>;</span>

<span>@Value</span><span>(</span><span>"#{environment['database.className']}"</span><span>)</span>
<span>private</span> <span>String</span> className<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>이는 environment라는 이름의 빈으로부터 해당 키에 해당하는 값을 읽어오는 것이다. 여기서 가져오는 bean은 Properties 타입 등의 빈이 될 수 있다.<br>
SpEL을 이용하면 오타와 같은 실수가 있을 때 에러 검증이 가능하다는 장점이 있다. 그래서 이름을 잘못 적는 실수가 있어도 예외가 발생하지 않는 ${} 기반의 프로퍼티 치환자 방식보다는 SpEL의 사용을 권장한다.</p>
<p>여기서 참고해야 하는 것은 @Value 어노테이션은 스프링 컨테이너가 참조하는 정보를 의미할 뿐이지 그 자체로 값을 넣어주는 것은 아니라는 것이다. 그래서 Spring 컨테이너 밖에서 사용된다면 @Value 어노테이션이 무시된다.</p>
<h4 id="타입의-변환"> [ 타입의 변환 ]</h4>
<p>설정 파일의 내용들은 모두 텍스트로 작성된다. 값을 넣을 프로퍼티 타입이 스트링이라면 아무런 문제가 없지만 그 외의 타입인 경우라면 타입을 변경하는 과정이 필요하다.<br>
이를 위해 스프링의 다음의 2가지 종류의 타입 변환 서비스를 제공한다.</p>
<ol>
<li>PropertyEditory<br>
디폴트로 사용되는 타입 변환기는 java.beans의 PropertyEditor 인터페이스를 구현한 것이다. PropertyEditor는 원래 GUI 개발 환경을 위해 개발되었지만 이제는 XML에 작성된 내용이나 @Value의 String 값에서 프로퍼티 타입으로 변경하기 위해 사용한다.<br>
PropertyEditory는 boolean, Boolean, int, Interger ... 등의 기본 타입의 변환가 배열의 변환 외에도 Charset, Class, Currency, File, Locale, Pattern, Resource, Timezone, URI, URL 등의 변환을 제공한다.<br>
예를 들어 다음과 같은 String을 URI로 받을 수 있다는 것이다.</li>
</ol>
<div><pre><code>database<span>.</span>url<span>=</span>jdbc<span>:</span>mariadb<span>:</span><span>/</span><span>/</span>localhost<span>/</span>security<span>?</span>characterEncoding<span>=</span>utf<span>-</span><span>8</span>

<span>@Value</span><span>(</span><span>"${database.url}"</span><span>)</span>
<span>private</span> <span>URI</span> url<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>이렇게 다양한 타입으로의 변환이 가능한 이유는 각각의 타입 변환기를 Spring이 구현해두었기 때문이다. 예를 들어 String을 URI로 바꾸는 경우에는 URIEditor, Charset으로 바꾸는 경우에는 CharsetEditor가 사용되는 것이다.<br>
만약 Spring이 지원하지 않는 타입의 오브젝트를 직접 값으로 주입하고 싶다면, PropertyEditory 인터페이스를 구현해서 직접 변환기를 구현할 수도 있다. 물론 권장하는 방법은 아니다. 이러한 방법 대신에 빈을 등록하고 DI 받는 방법이 있기 때문이다.<br>
또한 PropertyEditory는 내부적으로 상태값을 관리하기 때문에 멀티쓰레드 환경에서 사용이 불가능하며 String &lt;-&gt; Object 관계의 변환만 가능하다는 단점이 있다.</p>
<ol start="2">
<li>ConversionService<br>
스프링 3.0부터는 PropertyEditory 대신 사용할 수 있는 ConversionService를 지원하기 시작했다. ConversionService는 자바빈에서 차용해오던 PropertyEditory와 달리 스프링이 직접 제공하는 타입 변한 API이다.<br>
ConversionService는 변환기의 작성이 간편하며 PropertyEditory와 달리 멀티쓰레드 환경에서 공유해 사용될 수 있다는 장점이 있다. 만약 우리가 ConversionService라는 이름의 빈으로 ConversionService 타입의 빈을 등록하면 스프링 컨테이너가 이를 자동인식해서 PropertyEditor를 대신해 사용한다.<br>
예를 들어 String을 int로 바꾸는 경우에 직접 만든 Converter를 사용하려면 다음과 같이 구현할 수 있다.</li>
</ol>
<div><pre><code> <span>@Configuration</span>
 <span>public</span> <span>class</span> <span>ConverterConfig</span> <span>{</span>
 
    <span>@Bean</span>
    <span>public</span> <span>ConversionServiceFactoryBean</span> conversionService <span>(</span><span>)</span> <span>{</span>
        <span>final</span> <span>ConversionServiceFactoryBean</span> conversionServiceFactoryBean <span>=</span> <span>new</span> <span>ConversionServiceFactoryBean</span><span>(</span><span>)</span><span>;</span>
        conversionServiceFactoryBean<span>.</span><span>setConverters</span><span>(</span><span>converters</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> conversionServiceFactoryBean<span>;</span>
    <span>}</span>

    <span>@Bean</span>
    <span>public</span> <span>Set</span><span><span>&lt;</span><span>Converter</span><span>></span></span> <span>converters</span><span>(</span><span>)</span> <span>{</span>
        <span>final</span> <span>Set</span><span><span>&lt;</span><span>Converter</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        set<span>.</span><span>add</span><span>(</span><span>new</span> <span>CustomConverter</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> set<span>;</span>
    <span>}</span>
<span>}</span>

<span>@Component</span>
<span>public</span> <span>class</span> <span>CustomConverter</span> <span>implements</span> <span>Converter</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Integer</span><span>></span></span> <span>{</span>
    <span>public</span> <span>Integer</span> <span>convert</span><span>(</span><span>String</span> username<span>)</span> <span>{</span>
       <span>try</span><span>{</span>
          <span>return</span> <span>Integer</span><span>.</span><span>parseInt</span><span>(</span>username<span>)</span><span>;</span>
       <span>}</span> <span>catch</span> <span>(</span><span>NumberFormatException</span> e<span>)</span> <span>{</span>
           <span>return</span> <span>0</span><span>;</span>
       <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>물론 Spring에서 거의 모든 Conversion 기능을 제공해주기 때문에 거의 사용할 일이 없다. 하지만 특별하게 값을 변환해주어야 하는경우라면 위와 같이 CustomConverter를 만들어 등록하면 된다.</p>
<br>
<h2 id="_0922-requestcontextholder로-httpservletrequest-가져오기"> 0922 - RequestContextHolder로 HttpServletRequest 가져오기</h2>
<p>HttpServletRequest를 메서드 파라미터로 선언하지 않고 가져오는 방법이다.</p>
<p>request를 서비스 레이어까지 전달하지 않더라도 RequestContextHolder를 이용하면 되는데, RequestContextHolder는 Spring 프레임워크 전 구간에서 HttpServletRequest에 접근할 수 있게 도와주는 구현체이다.</p>
<p>RequestContextHolder는 ThreadLocal을 사용해서 sevvlet이 호출되면 thread, HttpServletRequest를 key-value로 보관하고 있다가 요청을 하면 동일한 thread내에서는 어느 곳에서든 같은 HttpServletRequest를 돌려주는 역할을 한다.</p>
<p>RequestContextHolder에서는 HttpServletRequest를 조회하는 메서드가 두 가지 존재한다.</p>
<h3 id="_1-getrequestattributes"> 1. getRequestAttributes</h3>
<blockquote>
<p>@Nullablepublic static RequestAttributes getRequestAttributes()Return the RequestAttributes currently bound to the thread.Returns:the RequestAttributes currently bound to the thread, or null if none bound</p>
</blockquote>
<h3 id="_2-currentrequestattributes"> 2. currentRequestAttributes</h3>
<blockquote>
<p>public static RequestAttributes currentRequestAttributes() throws IllegalStateExceptionReturn the RequestAttributes currently bound to the thread.Exposes the previously bound RequestAttributes instance, if any. Falls back to the current JSF FacesContext, if any.Returns:the RequestAttributes currently bound to the threadThrows:IllegalStateException - if no RequestAttributes object is bound to the current threadSee Also:setRequestAttributes(org.springframework.web.context.request.RequestAttributes), ServletRequestAttributes, FacesRequestAttributes, FacesContext.getCurrentInstance()</p>
</blockquote>
<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>context<span>.</span>request<span>.</span></span><span>RequestContextHolder</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>context<span>.</span>request<span>.</span></span><span>ServletRequestAttributes</span><span>;</span>

<span>public</span> <span>class</span> <span>HttpRequestUtils</span> <span>{</span>

	<span>// (1)</span>
	<span>public</span> <span>static</span> <span>HttpServletRequest</span> <span>getRequest</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> <span>(</span><span>(</span><span>ServletRequestAttributes</span><span>)</span><span>RequestContextHolder</span><span>.</span><span>getRequestAttributes</span><span>(</span><span>)</span><span>)</span><span>.</span><span>getRequest</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
    
	<span>// (2)</span>
	<span>public</span> <span>static</span> <span>HttpServletRequest</span> <span>getCurrentRequest</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> <span>(</span><span>(</span><span>ServletRequestAttributes</span><span>)</span><span>RequestContextHolder</span><span>.</span><span>currentRequestAttributes</span><span>(</span><span>)</span><span>)</span><span>.</span><span>getRequest</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>간단하게 정리하면 GetRequestAttributes()는 RequestAttributes가 없으면 Null을 반환하고, currentRequestAttributes()는 RequestAttributes가 없으면 IllegalStateException을 발생시킨다.</p>
<p>비동기 쓰레드에서는 호출한 쓰레드와 다른 쓰데르이므로 RequestContextHolder에서 HttpServletRequest를 조회하지 못한다. 비동기 호출시 HttpServletRequest에서 값을 조회해야 한다면 비동기 호출 전에 값을 조회하여 해당 값을 전달하는 것이 좋다.</p>
<p>++
https://www.notion.so/Spring-Boot-RequestContext-2d7fea0f4582435a9d9dd273804da9a3</p>
<br>
<h2 id="_0923-git-refs"> 0923 - Git Refs</h2>
<h3 id="refs"> Refs</h3>
<p>git의 커밋은 key-value 형식으로 이루어져 있는데, key 값은 SHA-1으로 만들어진 해쉬값이다. 이를 사라들이 기억하기 어렵기 때문에 외우기 쉬운 이름의 파일에 저장되어 있는데, 이를 저장해 놓은 파일을 <code>References</code> 혹은 <code>Refs</code>라고 한다.</p>
<blockquote>
<p>모든 refs는 .git/refs에 저장된다.</p>
</blockquote>
<h3 id="브랜치"> 브랜치</h3>
<p>git의 브랜치는 어떤 작업 중 마지막 작업을 가르키는 포인터 또는 Refs이다. 브랜치는 직접 가리키는 커밋과 그 커밋으로 따라갈 수 있는 모든 커밋을 포함한다.</p>
<blockquote>
<p>git의 <code>git branch &lt;branch&gt;</code>를 실행하면 내부적으로 <code>update-ref</code>명령을 실행하고, 입력받은 브랜치 이름과 현 브랜치의 마지막 커밋의 SHA-1 값을 가져다 <code>update-ref</code>명령을 실행</p>
</blockquote>
<h3 id="head"> HEAD</h3>
<p>HEAD 파일은 현 브랜치를 가리키는 간접 Refs다. 이 Refs는 다른 Refs를 가르키는 것이라서 SHA-1 값이 없다.</p>
<blockquote>
<p><code>git commit</code>을 실행하면 커밋 개체가 만들어지는데, 지금 HEAD가 가르키고 있던 커밋의 SHA-1 값이 그 커밋 개체의 부모로 사용된다.<br>
HEAD 파일도 손으로 직접 편집할 수 있지만 <code>git symbolic-ref</code>라는 명령어가 있어서 좀 더 안전하게 사용할 수 있다. 이 명령으로 HEAD의 값을 읽고 변경할 수 있다. (다만 refs 형식에 맞춰야 한다.)</p>
</blockquote>
<h3 id="태그"> 태그</h3>
<p>태그는 커밋이랑 매우 비슷하다. 커밋처럼 누가, 언제 태그를 달았는지 태그 메시지는 무엇이고 어떤 커밋을 가리키는지에 대한 정보가 포함된다. 태그는 Tree가 아니라 커밋을 가르킨다.<br>
브랜치처럼 커밋을 가리키지만 옮길 수는 없다. 태그는 늘 그 이름이 뜻하는 커밋만 가리킨다.</p>
<h3 id="리모트"> 리모트</h3>
<p><code>refs/heads</code>에 있는 Refs인 브랜치와 달리 리모트 Refs는 Checkout 할 수 없고 읽기 용도로만 쓸 수 있는 브랜치인 것이다. 이 리모트 Refs는 서버의 브랜치가 가리키는 커밋이 무엇인지 적어둔 일종의 북마크이다.</p>
<blockquote>
<p>리모트를 추가하고 Push하면 Git은 각 브랜치마다 Push 한 마지막 커밋이 무엇인지 <code>refs/remotes</code>디렉토리에 저장한다.</p>
</blockquote>
<br>
<h2 id="_0926-https-동작-과정"> 0926 - HTTPS 동작 과정</h2>
<h3 id="https란"> HTTPS란?</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FTIQPl%2Fbtq0kDsepHd%2FUzzv6JatoLtsDsdvXFZmsk%2Fimg.png" alt="image">
HTTPS는 HyperText Transfer Protocol Secure의 약자이며 HTTP의 보안 버전이다.<br>
HTTPS는 TCP 위에 SSL/TLS 층을 추가하여 암호화, 인증 그리고 무결성 보장을 통해 더 안전하게 만들어주는 프로토콜이다.</p>
<h4 id="대칭키"> [ 대칭키 ]</h4>
<p>암호화에 쓰이는 키와 복호화에 쓰이는 키가 동일한 기법<br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FW94Qi%2Fbtq0teEbVJK%2FWKelKm2z3UqPpQOCQ2KKL0%2Fimg.png" alt="image">
만약 클라이언트와 서버가 대칭키 방식으로 통신을 한다면 클라이언트도 키를 가지고 있어야 한다.<br>
클라이언트에게 키를 전달하기도 위험하며 클라이언트의 소스코드는 누구든지 열어볼 수 있으므로 가지고 있기도 굉장히 위험하다.<br>
즉, 원거리에서 대칭키를 안전하게 전달하는 것은 매우 어렵다.</p>
<h4 id="공개키-비대칭키"> [ 공개키(비대칭키) ]</h4>
<p>공개키와 개인키(비밀키)라는 2가지 키를 사용하는 기법이다.<br>
공개키는 말그대로 누구나 획득할 수 있는 공개된 키를 뜻한다. 정보를 보내는쪽(클라이언트)은 이 키를 가지고 데이터를 암호화해서 전송한다.<br>
개인키(비밀키)는 공개키로 암호화된 데이터를 복호화 할 수 있는 키로써 자신(서버)만이 가지고 있는 키다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAGD4h%2Fbtq0pypJPGx%2FkkTh7vd6VMgrbRnJAF8KH0%2Fimg.png" alt="image">
이 방법은 안전하게 데이터를 주고받을 수 있게 만들어주지만 속도가 느리다는 단점이있다.</p>
<h4 id="인증서와-ca-certificate-authority"> [ 인증서와 CA(Certificate authority) ]</h4>
<p>SSL을 적용하기 위해서는 인증서라는 것이 필요하다.<br>
인증서의 내용은 크게 2가지로 구분할 수 있다.</p>
<ol>
<li>서비스의 정보 (CA, 도메인 등등)</li>
<li>서버 측의 공개키 (공개키의 내용, 공개키의 암호화 방식)<br>
이 인증서를 발급해주는 기업을 CA라고 한다. 인증서가 보안에 관련된 것인 만큼 이 CA는 영향력있고 신뢰할 수 있는 기업에서만 가능하다.<br>
그리고 우리의 브라우저는 CA리스트를 미리 가지고 있다. CA목록에 있는 기업을 공인된 CA라고 하며 목록에 없는 기업을 사설 CA라고한다.</li>
</ol>
<h3 id="https-통신과정-및-원리"> HTTPS 통신과정 및 원리</h3>
<p>간단하게 들여다보면 동작방식은 대칭키와 공개키(비대칭키) 방식을 전부 사용하는 하이브리드 방식이다.<br>
데이터 전송을 위해 대칭키 방식을 사용하며 대칭키를 안전하게 전달하기 위해 공개키 방식을 사용한다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbE36KD%2Fbtq0tfDkLaZ%2FazI7Wlmon3eCzE5dQKNCq0%2Fimg.png" alt="image"></p>
<h4 id="_1-client-hello"> 1. Client Hello</h4>
<p>브라우저 마다 지원하는 암호화 알고리즘과 TLS 버전이 다르므로 해당 정보를 전송하며, 난수 값을 생성하여 전송한다.</p>
<h4 id="_2-server-hello"> 2. Server Hello</h4>
<p>사용할 TSL 버전, 사용할 암호화 알고리즘, 난수값을 전송</p>
<h4 id="_3-certificate"> 3. Certificate</h4>
<p>CA로 부터 발급받은 인증서를 전송한다.</p>
<h4 id="_4-server-key-exchange"> 4. Server Key Exchange</h4>
<p>키 교환에 필요한 정보를 제공한다. 만약 필요하지 않으면 이 과정은 생략이 가능한데, 예를 들어 키교환 알고리즘을 Diffie-Hellman으로 사용한다면 소수, 원시근 등이 필요하므로 이것을 전송한다.</p>
<h4 id="_5-certificate-request"> 5. Certificate Request</h4>
<p>서버가 클라이언트를 인증해야할때 인증서를 요구하는 단계이다. 요청하지 않을 수 도 있다.</p>
<h4 id="_6-serverhello-done"> 6. ServerHello Done</h4>
<h4 id="_7-client-key-exchange-change-cipher-spec"> 7. Client Key Exchange, Change Cipher Spec</h4>
<p>pre-master-key 라는 것을 전송한다. 이 키는 1,2 단계에서 생성한 난수를 조합하여 생성하게되며 대칭키로 사용하게될 예정이다. 그러므로 안전한 정송을 위해서 공개키 방식을 사용하여 전송한다.</p>
<h4 id="_8-change-cipher-spec"> 8. Change Cipher Spec</h4>
<p>클라이언트로 부터 전송받은 Pre-master-key를 정상적으로 복호화 후 master-key(대칭키)로 승격 후 보안 파라미터를 적용하거나 변경될때 보내는 알람이다.</p>
<br>
<h2 id="_0927-조회-빈-bean-이-2개-이상일때-동적으로-선택하는-방법"> 0927 - 조회 빈(Bean)이 2개 이상일때 동적으로 선택하는 방법</h2>
<ul>
<li>인터페이스 및 구현체</li>
</ul>
<div><pre><code><span>interface</span> <span>SampleInterface</span> <span>{</span>  
   <span>.</span><span>.</span><span>.</span>  
<span>}</span>

<span>@Repository</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>.</span><span>.</span><span>.</span>  
<span>}</span>

<span>@Repository</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceOtherImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>.</span><span>.</span><span>.</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="모든-인터페이스를-선언해놓고-분기처리"> 모든 인터페이스를 선언해놓고 분기처리</h3>
<div><pre><code><span>@Controller</span>  
<span>public</span> <span>class</span> <span>SampleController</span> <span>{</span>  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceImpl</span> basic<span>;</span>  
  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceOtherImpl</span> other<span>;</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/Basic"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>basic</span><span>(</span><span>)</span> <span>{</span>  
        basic<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/Other"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>other</span><span>(</span><span>)</span> <span>{</span>  
        other<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="인터페이스를-map에-넣어두고-꺼내서-사용"> 인터페이스를 Map에 넣어두고 꺼내서 사용</h3>
<div><pre><code><span>@Controller</span>  
<span>public</span> <span>class</span> <span>SampleController</span> <span>{</span>  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceImpl</span> basic<span>;</span>  
  
    <span>@Autowired</span>  
    <span>private</span> <span>SampleInterfaceOtherImpl</span> other<span>;</span>  
  
    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SampleInterface</span><span>></span></span> services<span>;</span>  
  
    <span>@PostConstruct</span>  
    <span>void</span> <span>init</span><span>(</span><span>)</span> <span>{</span>  
        services <span>=</span> <span>new</span> <span>HashMap</span><span>(</span><span>)</span><span><span>&lt;</span><span>></span></span><span>;</span>  
        services<span>.</span><span>put</span><span>(</span><span>"Basic"</span><span>,</span> basic<span>)</span><span>;</span>  
        services<span>.</span><span>put</span><span>(</span><span>"Other"</span><span>,</span> other<span>)</span><span>;</span>  
    <span>}</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/{service}"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>@PathVariable</span><span>(</span><span>"service"</span><span>)</span> <span>String</span> service<span>)</span><span>{</span>  
        <span>SampleInterface</span> sample <span>=</span> services<span>.</span><span>get</span><span>(</span>service<span>)</span><span>;</span>  
        <span>// remember to handle the case where there's no corresponding service  </span>
        sample<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="applicationcontext를-활용"> ApplicationContext를 활용</h3>
<p>구현체를 bean으로 등록하고</p>
<div><pre><code><span>@Component</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>public</span> <span>void</span> <span>sampleMethod</span><span>(</span><span>)</span> <span>{</span>  
        <span>// ...  </span>
    <span>}</span>  
<span>}</span>  
  
<span>@Component</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceOtherImpl</span> <span>implements</span> <span>SampleInterface</span> <span>{</span>  
    <span>public</span> <span>void</span> <span>sampleMethod</span><span>(</span><span>)</span> <span>{</span>  
        <span>// ...  </span>
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>ApplicationContext의 getBean()으로 구현체를 로딩하여 사용한다.</p>
<div><pre><code><span>@Controller</span>  
<span>public</span> <span>class</span> <span>SampleController</span> <span>{</span>  
    <span>@Autowired</span>  
    <span>private</span> <span>ApplicationContext</span> appContext<span>;</span>  
  
    <span>@RequestMapping</span><span>(</span>path <span>=</span> <span>"/path/{service}"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>  
    <span>public</span> <span>void</span> <span>method</span><span>(</span><span>@PathVariable</span><span>(</span><span>"service"</span><span>)</span> <span>String</span> service<span>)</span><span>{</span>  
        <span>SampleInterface</span> sample <span>=</span> appContext<span>.</span><span>getBean</span><span>(</span>service<span>,</span> <span>SampleInterface</span><span>.</span><span>class</span><span>)</span><span>;</span>  
        sample<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="spring의-di-활용"> Spring의 DI 활용</h3>
<p>set이나 list, map을 통해 자동으로 등록한다.</p>
<div><pre><code><span>@Autowired</span>  
<span>private</span> <span>List</span><span><span>&lt;</span><span>SampleInterface</span><span>></span></span> <span>SampleInterfaces</span><span>;</span>

<span>--</span><span>-</span>

<span>@Autowired</span>  
<span>private</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>SampleInterface</span><span>></span></span> <span>SampleInterfaceMap</span><span>;</span>

<span>--</span><span>-</span>

<span>void</span> <span>excuteSampleMethod</span><span>(</span><span>)</span> <span>{</span>  
    <span>String</span> interfaceName <span>=</span> <span>""</span>  
      
    <span>//enum으로 구분하거나, 조건에 맞게 수동으로분기하거나 서비스에맞게 고른다.  </span>
    <span>if</span> <span>(</span><span>isFirst</span><span>(</span><span>)</span><span>)</span> <span>{</span>  
        interfaceName <span>=</span> <span>"SampleInterfaceImpl"</span>  
    <span>}</span> <span>else</span> <span>{</span>  
        interfaceName <span>=</span> <span>"SampleInterfaceOtherImpl"</span>  
    <span>}</span>  
  
    <span>SampleInterface</span> impl <span>=</span> <span>SampleInterfaceMap</span><span>.</span><span>get</span><span>(</span>interfaceName<span>)</span><span>;</span>  
    impl<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>enum으로 정책 정하기</li>
</ul>
<div><pre><code><span>public</span> <span>enum</span> <span>SampleType</span> <span>{</span>  
    <span>SAMPLE</span><span>(</span><span>"SampleInterfaceImpl"</span><span>)</span><span>,</span>  
    <span>OTHERS</span><span>(</span><span>"SampleInterfaceOtherImpl"</span><span>)</span>  
  
    <span>SampleType</span><span>(</span><span>String</span> implementation<span>)</span> <span>{</span>  
        <span>this</span><span>.</span>implementation <span>=</span> implementation<span>;</span>  
    <span>}</span>  
  
    <span>public</span> <span>String</span> <span>getImplementation</span><span>(</span><span>)</span> <span>{</span>  
        <span>return</span> <span>this</span><span>.</span>implementation<span>;</span>  
    <span>}</span>  
<span>}</span>

<span>--</span><span>-</span> 

<span>void</span> <span>excuteSampleMethod</span><span>(</span><span>SampleType</span> sampleType<span>)</span> <span>{</span>      
  
    <span>SampleInterface</span> impl <span>=</span> <span>SampleInterfaceMap</span><span>.</span><span>get</span><span>(</span>sampleType<span>.</span>getImplementation<span>)</span><span>;</span>  
    impl<span>.</span><span>sampleMethod</span><span>(</span><span>)</span><span>;</span>  
<span>}</span>

<span>--</span><span>-</span> 

<span>@Component</span>  
<span>@RequiredArgsConstructor</span>  
<span>public</span> <span>class</span> <span>SampleInterfaceRouter</span> <span>{</span>  
  
    <span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>SampleInterface</span><span>></span></span> sampleInterfaces<span>;</span> <span>//의존성 List로 주입  </span>
  
    <span>public</span> <span>SampleInterface</span> <span>getImplemetationByType</span><span>(</span><span>SampleType</span> sampleType<span>)</span> <span>{</span>  
        <span>return</span> sampleInterfaces<span>.</span><span>stream</span><span>(</span><span>)</span>  
                            <span>.</span><span>filter</span><span>(</span>e <span>-></span> e<span>.</span><span>isAvailableType</span><span>(</span>sampleType<span>)</span><span>)</span> <span>//각 구현체에서 판단  </span>
                            <span>.</span><span>findFirst</span><span>(</span><span>)</span><span>.</span><span>orElseThrow</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>new</span> <span>NotSupportedTypeException</span><span>(</span><span>)</span><span>)</span><span>;</span>  
    <span>}</span>  
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><br> 
<h2 id="_0929-java-hashmap"> 0929 - Java HashMap</h2>
<h3 id="hash란"> Hash란?</h3>
<p>Hash는 자료를 일정한 형식의 식별 값이다.</p>
<ul>
<li>Key : 고유한 값, Hash function의 input.</li>
<li>Hash function : Key를 Hash로 변경해주는 역할을 한다.</li>
<li>Hash Code(또는 Hash Value) : 해시 함수를 통해 얻는 값으로, 해시를 인덱스 또는 주소로 삼아 Value에 접근이 가능하도록 한다.</li>
<li>Value : Key와 1:1로 매핑되어 있는 값으로 Bucket안에 들어가 있는 실제 값이다.</li>
<li>Bucket : 해시와 매핑되는 값(Value)이 저장되어 있는 공간이다.</li>
</ul>
<h4 id="요약"> [ 요약 ]</h4>
<ul>
<li>HashMap은 Key-Value가 1:1로 Mapping 되는 자료구조이며, Mapping으로 인해 삽입, 삭제, 검색이 평균적으로 O(1)인 자료구조이다. Key는 중복을 허용하지 않지만, Value는 중복을 허용한다.</li>
<li>Java HashMap의 Key는 Object 형을 지원하기 때문에 완전한 해시 함수가 아니다.</li>
<li>Java HashMap의 index는 <code>hashCode() % M</code>(M = 해시 버킷의 개수)로 산출할 수 있다.</li>
<li>Java HashMap 해시 충돌이 일어날 경우, 충돌 처리방법으로 Worst Case발생 빈도를 줄일 수 있는 Separate Chaining방식을 사용한다.</li>
<li>Java8이상 HashMap에서는 하나의 해시 버킷에 8개의 key-value 쌍이 모이면 링크드리스트를 트리로 변경하고, 데이터가 삭제되어 8개에 이르면 다시 링크드 리스트로 변경한다.</li>
<li>String 클래스의 hashCode() 메서드에서는 성능 향상 도모를 위해 31을 승수로 사용한다</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FB8NtE%2FbtrqMkNrQtK%2FJ1ZrM4Z9WVvVyHFDcumWS1%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0920 - 0926</title>
      <link>ahnjs/TIL/2021/0920/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0920/</guid>
      <source url="ahnjs/TIL/rss.xml">0920 - 0926</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0920-0926"> 0920 - 0926</h1>
<h2 id="_0921-org-assertj-core-api-assertions-assertthat"> 0921 - org.assertj.core.api.Assertions.assertThat</h2>
<h3 id="assertj란"> assertj란?</h3>
<blockquote>
<p>테스트 코드 작성을 쉽게 도와주는 라이브러리<br>
메소드 체이닝 지원 (메서드 체이닝이란 여러 메서드 호출을 연결해 하나의 실행문으로 표현하는 문)</p>
</blockquote>
<h3 id="asertj-사용하기"> asertj 사용하기</h3>
<h4 id="의존성"> 의존성</h4>
<ul>
<li>maven</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
  <span><span><span>&lt;</span>groupId</span><span>></span></span>org.assertj<span><span><span>&lt;/</span>groupId</span><span>></span></span>
  <span><span><span>&lt;</span>artifactId</span><span>></span></span>assertj-core<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
  <span>&lt;!-- use 2.9.1 for Java 7 projects --></span>
  <span><span><span>&lt;</span>version</span><span>></span></span>3.11.1<span><span><span>&lt;/</span>version</span><span>></span></span>
  <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>gradle</li>
</ul>
<div><pre><code>testCompile("org.assertj<span>:</span>assertj<span>-</span>core<span>:</span>3.11.1")
</code></pre>
<div><span>1</span><br></div></div><h4 id="선언"> 선언</h4>
<div><pre><code><span>import</span> <span>static</span> <span>org<span>.</span>assertj<span>.</span>core<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>assertThat<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="사용법"> 사용법</h4>
<ul>
<li>isEqualTo() -&gt; 주소값이 아니다.</li>
</ul>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>eq</span><span>(</span><span>)</span><span>{</span>
    <span>String</span> name <span>=</span><span>"이름"</span><span>;</span>
    <span>assertThat</span><span>(</span>name<span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"이름"</span><span>)</span><span>;</span> <span>// success</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>리스트 필드값 검증</li>
<li>extraction('속성명').containsExactly('필드값1', '필드값2', '필드값3')</li>
</ul>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>list</span><span>(</span><span>)</span><span>{</span>
    <span>User</span> user1 <span>=</span> <span>new</span> <span>User</span><span>(</span><span>"피카츄"</span><span>)</span><span>;</span>
    <span>User</span> user2 <span>=</span> <span>new</span> <span>User</span><span>(</span><span>"파이리"</span><span>)</span><span>;</span>
    <span>User</span> user3 <span>=</span> <span>new</span> <span>User</span><span>(</span><span>"꼬부기"</span><span>)</span><span>;</span>

    <span>List</span><span><span>&lt;</span><span>User</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    list<span>.</span><span>add</span><span>(</span>user1<span>)</span><span>;</span>
    list<span>.</span><span>add</span><span>(</span>user2<span>)</span><span>;</span>
    list<span>.</span><span>add</span><span>(</span>user3<span>)</span><span>;</span>

    <span>assertThat</span><span>(</span>list<span>)</span><span>.</span><span>extracting</span><span>(</span><span>"name"</span><span>)</span>
            <span>.</span><span>containsExactly</span><span>(</span><span>"피카츄"</span><span>,</span><span>"파이리"</span><span>,</span><span>"꼬부기"</span><span>)</span><span>;</span><span>//success</span>
    
    <span>assertThat</span><span>(</span>list<span>)</span><span>.</span><span>extracting</span><span>(</span><span>"name"</span><span>)</span>
            <span>.</span><span>containsExactly</span><span>(</span><span>"피카츄"</span><span>)</span><span>;</span> <span>//fail</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>오브젝트 객체 검증</li>
<li>객체에 hashCode(), equals() 구현</li>
</ul>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>objectValue</span><span>(</span><span>)</span><span>{</span>
    <span>assertThat</span><span>(</span>피카츄<span>User</span><span>)</span><span>.</span><span>contains</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>"피카츄"</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>예외 테스트</li>
</ul>
<div><pre><code><span>@ParameterizedTest</span>
<span>@ValueSource</span><span>(</span>strings <span>=</span> <span>{</span><span>""</span><span>,</span> <span>"spring"</span><span>}</span><span>)</span>
<span>@DisplayName</span><span>(</span><span>"이름 길이가 0 이하 또는 5 이상일 때 에러 확인"</span><span>)</span>
<span>void</span> <span>car_name_exception</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
  <span>assertThatThrownBy</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>new</span> <span>Car</span><span>(</span>name<span>)</span><span>)</span>
      <span>.</span><span>isInstanceOf</span><span>(</span><span>IllegalStateException</span><span>.</span><span>class</span><span>)</span>
      <span>.</span><span>hasMessageContaining</span><span>(</span><span>"이름 길이는 0이하 또는 5이상이어야 합니다."</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><br>
<h2 id="_0922-git-flow"> 0922 - git flow</h2>
<h3 id="git-flow란"> git-flow란</h3>
<blockquote>
<p>git으로 개발할 때 거의 표준과 같이 사용되는 방법론<br>
각자 개발 환경에 따라 수정하고 변형해서 사용</p>
</blockquote>
<h4 id="git-flow-전략"> git-flow 전략</h4>
<ul>
<li>master : 제품으로 출시 될 수 있는 브랜치</li>
<li>develop : 다음 출시 버전을 개발하는 브랜치</li>
<li>feature : 기능을 개발하는 브랜치</li>
<li>release : 이번 출시 버전을 준비하는 브랜치</li>
<li>hotfix : 출시 버전에서 발생한 버그를 수정하는 브랜치</li>
</ul>
<br>
<h2 id="_0924-merge-squash-and-merger-rebase-and-merge"> 0924 - Merge, Squash and Merger, Rebase and Merge</h2>
<blockquote>
<p>Github의 새버전에서 merge, squash and merge, rebse and merge 세 종류의 merge를 모두 지원하기 시작했다. 각 머지 방식에 따라 커밋 히스토리가 달라지기 떄문에 어떤 경우에 어떤 머지를 사용하는 것이 좋은지 확인.</p>
</blockquote>
<h3 id="merge"> Merge</h3>
<ul>
<li>a, b, c를 refer 하는 m 커밋 노드 생성, m은 parent로 init, c를 가짐</li>
<li>커밋 m에서부터 뒤로 되돌아가면서 부모를 모두 찾아 브렌치를 구성. 커밋 m은 부모로 c, Init을 가지고 있으며, c는 b를, b는 a를, a는 Init을 다시 부모로 가짐, 이 형상을 모두 backtrace 하여, Init-&gt;a-&gt;b-&gt;c-&gt;m이라는 구조를 만들고 이 구조가 모두 히스토리에 남음.</li>
<li>htfix - develop, hotfix - master 브렌치간의 머지에 유용</li>
</ul>
<h3 id="squash-and-merge"> Squash and Merge</h3>
<ul>
<li>a, b, c를 합쳐서 새로운 커밋으로 만들고, 머지 대상 브렌치에 추가, 'a,b,c'커밋은 parent를 Init 하나만 가짐</li>
<li>커밋 'a,b,c'는 Init만을 부모로 가진 단일 커밋. 작업했던 브렌치의 a, b, c커밋들은 머지 후의 메인 브렌치 커밋 Init, 'a,b,c'와 아무런 연관을 가지지 않음.</li>
<li>develop - feature, htfix - develop, hotfix - master 브렌치간의 머지에 유용</li>
</ul>
<h3 id="rebase-and-merge"> Rebase and Merge</h3>
<ul>
<li>a, b, c 를 심리스(Seamless 는 Seam (겹친부분)이 less (없는) 것)하게 머지 대상 브렌치로 추가, 각 커밋들은 모두 parent를 하나씩만 가짐.</li>
<li>커밋 a, b, c의 관계를 그대로 유지한 채, 메인 브렌치에 그대로 추가. 커밋 a는 부모로 커밋 e를 가짐. Rebase and Merge 작업 후에는, 작업했던 브렌치의 a, b, c커밋들은 머지 후의 메인 브렌치의 Init, d, e, a, b, c 커밋들과 연관 관계를 가지지 않음.</li>
<li>master - develop 브렌치간의 머지에 유용</li>
</ul>
<br>
<h2 id="_0925-프레임워크과-라이브러리"> 0925 - 프레임워크과 라이브러리</h2>
<h3 id="framework-프레임워크"> framework(프레임워크)</h3>
<p>프레임워크는 뼈대나 기반구조를 뜻하는데, Application 개발 시 필수적인 코드, 알고리즘, 데이터베이스 연동 등과 같은 기능들을 위해 어느정도 뼈대(구조)를 제공해주는 것. 그러므로 그러한 뼈대 위에 프로그래머가 코드를 작성하여 Application을 완성시켜야 한다. 어느정도 뼈대를 제공해 주기 때문에, 객체 지향 개발을 하면서 일관성 부족 등의 문제를 해결해 준다. 그래서 소프트웨어에서는 프레임워크를 아래와 같이 정의하곤 한다.<br>
<code>소프르웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합</code></p>
<h3 id="libreay-라이브러리"> Libreay(라이브러리)</h3>
<p>Library는 특정 기능에 대한 도구 or 함수들을 모은 집합이다. 즉, 프로그래머가 개발하는데 필요한 것들을 모아둔 것. Library는 프로그래머라면 누구나 한번쯤은 써봤을 것이며, 스스로 써보지 않았다라고 생각하는 사람도 라이브러리가 무엇인지 몰라서 그렇게 얘기하는 것일 뿐, 자기도 모르게 써보았을 것이다. Library 역시도 아래와 같이 간단하게 정의할 수 있다.<br>
<code>단순 활용이 가능한 도구들의 집합</code></p>
<h3 id="차이"> 차이</h3>
<p>Framework와 Library의 차이는 Flow(흐름)에 대한 제어 권한이 어디에 있느냐의 차이이다. 프레임워크는 전체적인 흐름을 자체적으로 가지고 있으며, 프로그래머가 그 안에 필요한 코드를 작성하는 반면에 라이브러리는 사용자가 흐름에 대해 제어를 하며 필요한 상황에 가져다 쓰는것.</p>
<ul>
<li>프레임워크에는 분명한 <code>제어의 역전</code> 개념이 적용되어 있어야 한다.</li>
<li>제어의 역전이란 어떠한 일을 하도록 만들어진 프레임워크에 제어의 권한을 넘김으로써 클라이언트 코드가 신경 써야 할 것을 줄이는 전략</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0927 - 1003</title>
      <link>ahnjs/TIL/2021/0927/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0927/</guid>
      <source url="ahnjs/TIL/rss.xml">0927 - 1003</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0927-1003"> 0927 - 1003</h1>
<h2 id="_0927-er-다이어그램과-클래스-다이어그램의-차이"> 0927 - ER 다이어그램과 클래스 다이어그램의 차이</h2>
<blockquote>
<p>ER(엔티티-관계)다이어그램과 클래스 다이어그램은 소프트웨어 개발자가 일반적으로 소프트웨어 엔지니어링 라이프 사이클의 디자인 단계에서 만드는 두 가지 디자인 다이어그램이다.</p>
</blockquote>
<h3 id="erd"> ERD</h3>
<ul>
<li>ERD는 데이터베이스 모델링을 위한 ERM(Entity-Relationship Modeling) 기술의 산물이다.</li>
<li>엔티티-관계 모델링은 데이터의 추상적이고 개념적인 표현을 만드는 과정이다.</li>
<li>ER다이어그램은 궁극적으로 데이터베이스를 모델링한다.</li>
</ul>
<h3 id="클래스-다이어그램"> 클래스 다이어그램</h3>
<ul>
<li>클래스 다이어그램(보다 정확하게 UML 클래스 다이어그램이라고 함)은 UML(Unified Modeling Language)을 사용하여 정의 된 시스템의 정적 구조 및 동작을 나타내는 디자인 다이어그램이다.</li>
</ul>
<h3 id="차이점"> 차이점</h3>
<ul>
<li>ER다이어그램은 데이터 모델의 추상적인 표현을 나타내고 클래스 다이어그램은 제안 된 시스템의 정적 구조와 동작을 나타낸다.</li>
<li>ER다이어그램의 기본 빌딩 블록은 엔티티, 관계 및 속성이지만 클래스 다이어그램의 기본 빌딩 블록은 클래스, 관계 및 속성이다.</li>
<li>클래스 다이어그램은 실제 개체에 매핑 될 가능성이 더 높은 반면 ER다이어그램은 가장 자주 데이터베이스의 테이블에 매핑된다.</li>
</ul>
<br>
<h2 id="_0929-poc-prototype-mvp차이"> 0929 - POC, Prototype, MVP차이</h2>
<h3 id="poc-proof-of-concept"> POC(Proof-of-Concept)</h3>
<ul>
<li>개념 증명(POC, Proof of Concept)는 기존 시장에 없었던 신기술을 도입하기 전에 이를 검증하기 위해 사용한다.</li>
<li>특정 방식이나 아이디어를 실체화하여 타당성을 증명하는 것을 의미한다.</li>
<li>의미 : 새로 도입되는 기술이나 제품이 도입 목적에 부합되는지 검증</li>
<li>검증 : 그 기술이 생각한대로 동작되는지? 도입해도 되는지?</li>
<li>MVP와 차이점 : 실사용자인 고객이 사용/피드백 을 안함</li>
</ul>
<h3 id="prototype-프로토타입"> Prototype(프로토타입)</h3>
<ul>
<li>프로토타입은 시제품이 나오기 전에 제품의 원형이며, 개발검증과 양산 검증을 거쳐야 시제품이 될 수 있다.</li>
<li>프로토타입은 정보시스템의 미완성 버전 또는 중요한 기능들이 포함되어 있는 시스템의 초기모델</li>
<li>프로토타입은 사용자의 모든 요구사항이 정확하게 반영될때까지 계속해서 개선/보완 된다.</li>
<li>실제로 많은 애플리케이션들이 지속적인 프로토타입의 확장과 보강을 통해 최종 승인되고 개발에 들어간다.</li>
<li>의미 : 시스템이나 저품들의 중요한 기능들이 포함된 초기모델(SW 개발 착수전 검증/승인)</li>
<li>검증 : 이렇게 설계하여 개발/생산 해도되는지?</li>
<li>MVP와 차이점 : 실사용자인 고객이 사용/피드백 안할 수도 있음.</li>
</ul>
<h3 id="pilot-시범-적용"> Pilot(시범 적용)</h3>
<ul>
<li>Pilot은 전체 확대 적용하기전에 소규모로 테스트해서 추후 발생할 수 있는 여러 문제의 원인을 미리 파악하고 수정 보완하기 위해 모의로 시행해 보는 활동.</li>
<li>의미 : 새로운 정책 또는 서비스 확산의 첫 번째 시범 적용</li>
<li>검증 : 더 넙ㄹ은 그룹으로 확장해서 적용해도 되는지?</li>
<li>MVP와 차이점 : 실사용자인 고객이 사용/피드백은 유사하나 성공 또는 실패를 확인하기 위해 사용하며 지속적으로 검증하며 사용하지는 않음</li>
</ul>
<h3 id="mvp-최소-실행가능-제품-minimum-viable-product"> MVP(최소 실행가능 제품,Minimum Viable Product)</h3>
<ul>
<li>최소 실행 가능 제품은 고객에게 가치를 제공해야하며, 고객 피드백을 받아 생존하기 위한 최소한의 노력을 들여 만든 기능(features)을 구현한 제품이다.</li>
<li>최소 실행 가능 제품은 신제품 개발에서 학습의 영향을 강조하는 Lean Startup의 개념이다.</li>
<li>최소한의 노력으로 고객에 대한 검증된 정보를 최대한 수집 할 수 있는 새로운 제품 버전</li>
<li>의미 : 출시 후 제품이 생존하기 위해 최소한의 노력(개발범위, 시간)으로 고객에 대한 검증 된 정보를 최대한 수집 할 수있는 제품 버전</li>
<li>검증 : 고객에게 Value를 주는가? 고객이 원하는것이 맞는가? 가설대로 고객이 변화 되는가?</li>
<li>PoC, Prototype과 차이점 : 실사용자인 고객이 사용/피드백 해야함</li>
<li>Pilot과 차이점 : 성공/실패 확인 보다는 지속적인 실험/개선 목적</li>
<li>MVP는 최소한의 노력으로 고객에게 Value를 주며 가설을 검증하며 개선</li>
</ul>
<br>
<h2 id="_1001-메시지큐-message-queue-mq"> 1001 - 메시지큐(Message Queue / MQ)</h2>
<h3 id="메시지-큐-message-queue-이하-mq"> 메시지 큐(Message Queue 이하 MQ)</h3>
<blockquote>
<p>프로세스(프로그램) 간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나로 더 큰 개념으로는 MOM(Message Oriented Middleware : 메시지 지향 미들웨어 이하 MOM)을 의미한다. MOM이란 비동기 메시지를 사용하는 프로그램 간의 데이터 송수신을 의미하는데 MOM을 구현한 시스템을 MQ라고 한다. MQ는 작업을 늦출 수 있는 유연성을 제공한다.</p>
</blockquote>
<blockquote>
<p>메시지를 교환할 떄 AMQP(Advanced Message Queuing Protocol 이하 AMQP)를 이용한다. AMQP는 ISO 응용 계층의 MOM 표준으로 JMS(Java Message Service)와 비교되는데 JMS는 MOM을 자바에서 지원하는 표준 API이다. JMS는 다른 Java Application 간에 통신은 가능하지만 다른 MOM(AMQP, SMTP 등)끼리는 통신할 수 없다. 그에 반해 AMQP는 protocol만 일치한다면 다른 AMQP를 사용한 Aplication과도 통신이 가능하다. AMQP는 wire-protocol을 제공하는데 이는 octet stream을 이용해서 다른 네트워크 사이에 데이터를 전송할 수 있는 포맷이다.</p>
</blockquote>
<h3 id="메시지큐의-장점"> 메시지큐의 장점</h3>
<ul>
<li>비동기 : Queue에 넣기 때문에 나중에 처리할 수 있다.</li>
<li>비동조 : Application과 분리할 수 있다.</li>
<li>탄력성 : 일부가 실패 시 전체는 영향을 받지 않는다.</li>
<li>과잉 : 실패할 경우 재실행이 가능.</li>
<li>확장성 : 다수의 프로세스들이 큐에 메시지를 보낼 수 있다.</li>
</ul>
<h3 id="메시지-큐-사용처"> 메시지 큐 사용처</h3>
<p>메시지 큐는 다음과 같이 다양한 곳에 사용이 가능하다.</p>
<ul>
<li>다른 곳의 API로부터 데이터 송수신</li>
<li>다양한 Application에서 비동기 통신 가능</li>
<li>이메일 발송 및 문서 업로드 가능</li>
<li>많은 양의 프로세스 처리</li>
</ul>
<h3 id="메시지-큐-종류"> 메시지 큐 종류</h3>
<p>대표적인 메시지 큐 종류의 3가지</p>
<ul>
<li>Kafka</li>
<li>RabbitMQ</li>
<li>ActiveMQ</li>
</ul>
<p>공통적으로 3가지 모두 비동기 통신을 제공하고 보낸 사람과 받는 사람을 분리한다. 하지만 업무에 따라서 다른 목적을 가지고 있다.</p>
<p>성격상 Kafaka(Apache)와 RabbitMQ, ActiveMQ(Apache)로 나눌 수 있는데 Kafka는 처리량이 많은 분산 메시징 시스템에 적합하고 RabbitMQ, ActiveMQ는 신뢰성 있는 메시지 브로커가 필요한 경우 적합하다. 여기서 신뢰성은 Kafka에 비해 높은 것이지 Kafka가 신뢰성이 없다는 것은 아니다.</p>
<h4 id="rabbitmq"> RabbitMQ</h4>
<p>RabbitMQ는 AMQT 프로토콜을 구현해 놓은 프로그램으로써 빠르고 쉽게 구성할 수 있으며 직관적이다.</p>
<p>장점</p>
<ul>
<li>신뢰성, 안정성</li>
<li>유연한 라우팅 (Message Queue가 도착하기 전에 라우팅 되며 플로그인을 통해 더 복잡한 라우팅도 가능)</li>
<li>클러스터링 (로컬네트워크에 있느 여러 RabbitMQ 서버를 논리적으로 클러스터링할 수 있고 논리적인 브로커도 가능)</li>
<li>관리 UI의 편리성 (관리자 페이지 및 모니터링 페이지가 제공됨)</li>
<li>거의 모든 언어 및 운영체제를 지원</li>
<li>오픈소스로 상업적 지원 가능</li>
</ul>
<h4 id="kafka"> Kafka</h4>
<p>Kafaka는 확장성과 고성능 및 높은 처리량을 내세운 제품. 특화된 시스템이기 때문에 범용 메시징 시스템에서 제공하는 다양한 기능들은 제공되지 않는다. 분산 시스템을 기본으로 설계되었기 때문에 기존 메시징 시스템에 비해 분산 및 복제 구성을 손쉽게할 수 있다.</p>
<p>장점</p>
<ul>
<li>대용량 실시간 로그 처리에 특화</li>
<li>AMQP 프로토콜이나 JSM API를 사용하지 않고 단순한 메시지 헤더를 지닌 TCP 기반 프로토콜을 사용함으로써 오버헤드가 비교적 작다.</li>
<li>노드 장애에 대한 대응성을 가지고 있다.</li>
<li>프로듀서는 각 메시지를 배치로 브로커에게 전달하여 TCP/IP 라운드 트립을 줄였다.</li>
<li>메시지를 기본적으로 파일 시스템에 저장하여 별도의 설정을 하지 않아도 오류 발생 시 오류 지점부터 복구가 가능하다 (기존 메시징 시스템은 메시지를 메모리에 저장)</li>
<li>메시지를 파일시스템에 저장하기 때문에 메시지가 많이 쌓여도 기존 메시징 시스템에 비해 성능이 크게 감소하지 않는다.</li>
<li>window 단위의 데이터를 넣고 꺼낼 수 있다.</li>
</ul>
<h4 id="activemq"> ActiveMQ</h4>
<p>ActiveMQ는 자바로 만든 오픈소스 메시지 브로커. JMS 1.1을 통해 자바 뿐만 아니라 다른 언어를 사용하는 클라이언트를 지원한다.</p>
<p>장점</p>
<ul>
<li>다양한 언어와 프로토콜 지원</li>
<li>OpenWire를 통해 고성능의 Java, C, C++, C# 클라이언트 지원</li>
<li>stomp를 통해 C, Ruby, Perl, Python, PHP 클라이언트가 다른 인기있는 메시지 브로커들과 마찬가지로 ActiveMQ에 접근 가능</li>
<li>Message Groups, Virtual Destinations, Wildcards와 Composite Destination을 지원</li>
<li>Spring 지원으로 ActiveMQ는 Spring Application에 매우 쉽게 임베딩될 수 있으며, Spring의 XML 설정 메커니즘에 의해 쉽게 설정 가능</li>
<li>Geronimo, JBoss4, GlassFish, WebLogic과 같은 인기있는 J2EE 서버들과 함께 테스트됨</li>
<li>고성능의 저널을 사용할 때에 JDBC를 사용하여 매우 빠른 Persistence를 지원</li>
<li>REST API를 통해 웹기반 메시징 API를 지원</li>
<li>웹 브라우저가 메시징 도구과 될 수 있도록, Ajax를 통해 순수한 DHTML을 사용한 웹 스트리밍 지원</li>
</ul>
<br>
<h2 id="_1002-javascript-자주-사용하는-es6-문법-정리"> 1002 - JavaScript 자주 사용하는 ES6 문법 정리</h2>
<h3 id="es6-ecmascript6-란"> ES6(ECMAScript6)란?</h3>
<blockquote>
<p>ECMScript 2015로도 알려져 있는 ECMScript6는 ECMScript 포준의 가장 최신 버전이다. ES6은 새로운 언어 기능이 포함된 주요업데이트며, 2009년도에 표준화된 ES5 이후로 언어 기능에 대한 첫 업데이트이기도 하다.</p>
</blockquote>
<p>ES6는 아래의 새로운 기능들을 포함</p>
<ul>
<li>const and let</li>
<li>Arrow functions (화살표 함수)</li>
<li>Template Literals (템플릿 리터럴)</li>
<li>Default parameters (기본 매개 변수)</li>
<li>Array and object destructing (배열 및 객체 비구조화)</li>
<li>Import and export (가져오기 내보내기)</li>
<li>Promises (프로미스)</li>
<li>Rest parameter and Spread operator (나머지 매개 변수 및 확산 연산자)</li>
<li>Classes (클래스)</li>
</ul>
<h3 id="es6-문법"> ES6 문법</h3>
<h4 id="const-and-let"> const and let</h4>
<p>const는 변수 선언을 위한 ES6의 새로운 키워드. const는 var보다 강력하고 일단 사용되면 변수를 다시 할당 할 수 없다. 즉, 객체와 함께 사용할 떄를 제외하고는 변경 불가능한 변수.</p>
<h4 id="arrow-functions"> Arrow functions</h4>
<ul>
<li>기본</li>
</ul>
<div><pre><code><span>const</span> <span>func</span> <span>=</span> <span>(</span><span>name</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>...</span><span>;</span>
<span>}</span>

<span>const</span> <span>func</span> <span>=</span> <span>(</span><span>name</span><span>)</span> <span>=></span> <span>...</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>map, filter, reduce 내장 함수 사용</li>
</ul>
<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span>

<span>let</span> arr1 <span>=</span> arr<span>.</span><span>map</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> item<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="template-literals"> Template Literals</h4>
<div><pre><code><span>const</span> <span>func</span> <span>=</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span><span>`</span><span>안녕 </span><span><span>${</span>name<span>}</span></span><span>, 너의 나이는 </span><span><span>${</span>age<span>}</span></span><span>살 이다!</span><span>`</span></span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="default-parameters"> Default parameters</h4>
<div><pre><code><span>const</span> <span>func</span> <span>=</span> <span>(</span><span>name<span>,</span> age <span>=</span> <span>22</span></span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span><span>`</span><span>안녕 </span><span><span>${</span>name<span>}</span></span><span>, 너의 나이는 </span><span><span>${</span>age<span>}</span></span><span>살 이다!</span><span>`</span></span><span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>func</span><span>(</span><span>'철수'</span><span>)</span><span>)</span><span>;</span>
<span>// 출력 안녕 철수, 너의 나이는 22살 이다!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="array-and-object-destructing"> Array and object destructing</h4>
<div><pre><code><span>const</span> contacts <span>=</span> <span>{</span>
    famillyName<span>:</span> <span>'이'</span><span>,</span>
    name<span>:</span> <span>'영희'</span><span>,</span>
    age<span>:</span> <span>22</span>
<span>}</span>

<span>let</span> <span>{</span> famillyName<span>,</span> name<span>,</span> age <span>}</span> <span>=</span> contacts<span>;</span>

console<span>.</span><span>log</span><span>(</span>famillyName<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>name<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>age<span>)</span><span>;</span>
<span>// 이</span>
<span>// 영희</span>
<span>// 22</span>

<span>let</span> <span>{</span> famillyName<span>,</span> name<span>:</span> otherName<span>,</span> age <span>}</span> <span>=</span> contacts<span>;</span>

console<span>.</span><span>log</span><span>(</span>otherName<span>)</span><span>;</span>
<span>// 영희</span>

<span>// 배열</span>
<span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>

<span>let</span> <span>[</span>value1<span>,</span> value2<span>,</span> value3<span>]</span> <span>=</span> arr<span>;</span>
console<span>.</span><span>log</span><span>(</span>value1<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>value2<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>value3<span>)</span><span>;</span>
<span>// 1</span>
<span>// 2</span>
<span>// 3 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><h4 id="import-and-export"> Import and export</h4>
<ul>
<li>가져오기 및 내보내기</li>
</ul>
<div><pre><code><span>export</span> <span>default</span> <span>function</span> <span>detail</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
    <span>return</span> <span><span>`</span><span>안녕 </span><span><span>${</span>name<span>}</span></span><span>, 너의 나이는 </span><span><span>${</span>age<span>}</span></span><span>살 이다!</span><span>`</span></span><span>;</span>
<span>}</span>

<span>--</span><span>-</span>

<span>import</span> detail <span>from</span> <span>'./detailComponet'</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>detail</span><span>(</span><span>'영희'</span><span>,</span> <span>20</span><span>)</span><span>)</span><span>;</span>
<span>// 안녕 영희, 너의 나이는 20살 이다!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>둘 이상의 모듈을 가져오기</li>
</ul>
<div><pre><code><span>import</span> <span>{</span> detail<span>,</span> userProfile<span>,</span> getPosts <span>}</span> <span>from</span> <span>'./detailComponent'</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="promises"> Promises</h4>
<blockquote>
<p>비동기 코드를 쓰는 방법</p>
</blockquote>
<div><pre><code><span>const</span> <span>promise</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
        <span>resolve</span><span>(</span><span>'Promise가 성공적으로 실행됐습니다.'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>proise</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// Promise {&lt;resolved>: "Promise가 성공적으로 실행됐습니다."}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>const</span> url <span>=</span> <span>'https://jsonplaceholder.typicode.com/posts'</span><span>;</span>

<span>// fetch함수는 Promise자체를 반환</span>
<span>const</span> <span>getData</span> <span>=</span> <span>(</span><span>url</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>fetch</span><span>(</span>url<span>)</span><span>;</span>
<span>}</span>

<span>getData</span><span>(</span>url<span>)</span><span>.</span><span>then</span><span>(</span><span>data</span> <span>=></span> data<span>.</span><span>json</span><span>(</span><span>)</span><span>)</span><span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="rest-parameter-and-spread-operator"> Rest parameter and Spread operator</h4>
<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>]</span>

<span>const</span> <span>[</span> val1<span>,</span> val2<span>,</span> val3<span>,</span> <span>...</span>rest <span>]</span> <span>=</span> arr<span>;</span>

<span>const</span> <span>func</span> <span>=</span> <span>(</span><span>restOfArr</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> restOfArr<span>.</span><span>filter</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> <span>{</span><span>return</span> item<span>}</span><span>)</span><span>.</span><span>join</span><span>(</span><span>" "</span><span>)</span><span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>func</span><span>(</span>rest<span>)</span><span>)</span><span>;</span>
<span>// 4 5 6 7</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>]</span>

<span>const</span> <span>func</span> <span>=</span> <span>(</span><span><span>...</span>anArray</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> anArray<span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>func</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
<span>// [1, 2, 3, 4, 5, 6, 7]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="classes"> Classes</h4>
<div><pre><code><span>class</span> <span>myClass</span> <span>{</span>
    <span>constructor</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>syaHello</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>안녕 </span><span><span>${</span><span>this</span><span>.</span>name<span>}</span></span><span> 너의 나이는 </span><span><span>${</span><span>this</span><span>.</span>age<span>}</span></span><span>살이다</span><span>`</span></span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>--</span><span>-</span> <span>// 상속</span>

<span>class</span> <span>UserProfile</span> <span>extends</span> <span>myClass</span> <span>{</span>
    <span>userName</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>const</span> user <span>=</span> <span>new</span> <span>myClass</span><span>(</span><span>'영희'</span><span>,</span> <span>22</span><span>)</span><span>;</span>
<span>const</span> profile <span>=</span> <span>new</span> <span>UserProfile</span><span>(</span><span>'영희'</span><span>,</span> <span>22</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><br>
<h2 id="_1003-행-hang-프리징-freezing-데드락-deadlock"> 1003 - 행(hang), 프리징(freezing), 데드락(deadlock)</h2>
<h3 id="행"> 행</h3>
<p>어떠한 프로그램이 수행 중에 멈추게 된 현상</p>
<h3 id="프리징"> 프리징</h3>
<p>행과 똑같은 의미로 정의되어 있지만 쓰이는 용도가 조금다름. 보통 프리징 현상이라함은 어떠한 프로그램이 렉이걸려 그 해당프로그램은 멈춰서 돌아가지 않지만 마우스는 움직일 수 있는 상황을 표현</p>
<p>행은 보통 네트워크장비에서 프로세스가 어떠한 이유로 정상적인 활동을 하지 못하여 시스템 운영이 불가한 상태일떄 행이 걸렸다 라고 표현한다. 쉽게 설명하여 프리징과 행은 둘다 &quot;먹통되다&quot;, &quot;렉걸렸다&quot;라고 말할 수 있다.</p>
<h3 id="데드락"> 데드락</h3>
<p>데드락은 둘 이상의 프로세스가 한정된 자원을 같이 요청하는 현상으로 모든 프로세스들이 진전 하지 못하고 대기상태가 되는 현상을 말한다.</p>
<p>데드락이 발생하기 위해서는 아래와 같은 조건들이 충족해야 한다.</p>
<ul>
<li>상호배재 - 특정 자원은 하나의 프로세스밖에 못가진다.</li>
<li>점유와대기 - 프로세스가 자원을 가지고 있으면서 다른 자원을 기다린다.</li>
<li>비선점 - 프로세스가 어떤 자원의 사용을 끝내기 전에 다른 프로세스가 강제로 그 자원을 뺏을 수 없다.</li>
<li>순환대기 - 각각의 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있따.</li>
</ul>
<p>=&gt; 위 4가지 조건 중 하나라도 만족한다면 데드락 현상이 발생하며, 아닐 경우 데드락은 발생하지 않는다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>1004 - 1010</title>
      <link>ahnjs/TIL/2021/1004/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1004/</guid>
      <source url="ahnjs/TIL/rss.xml">1004 - 1010</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1004-1010"> 1004 - 1010</h1>
<h2 id="_1005-동기와-비동기-블럭과-넌블럭"> 1005 - 동기와 비동기, 블럭과 넌블럭</h2>
<blockquote>
<p>동기(Synchronous)와 비동기(Asynchronous), 그리고 블럭(Blocking)과 넌블럭(Non-blocking)</p>
</blockquote>
<h3 id="blocking-non-blocking"> Blocking / Non-blocking</h3>
<p>행위자가 취한 행위 자체가, 또는 그 행위로 인해 다른 무엇이 <em><strong>막혀버린, 제한된, 대기하는 상태</strong></em>. 대개의 경우에는 나 이외의 대상으로 하여금 내가 Block 당하겠지만(Blocked), 어찌 되었든 문자 자체로는 나라는 ***단일 개체 스스로의 상태***를 나타낸다.</p>
<ul>
<li>호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 돌려주지 않으면 Block</li>
<li>호출된 함수가 자신이 할 일을 채 마치지 않았더라도 바로 제어권을 건네주어(return) 호출한 함수가 다른 일을 진행할 수 있도록 해주면 Non-block</li>
</ul>
<h3 id="synchronous-asynchronous"> Synchronous / Asynchronous</h3>
<p>***동시에 발생하는***것들. 동시라는 것은 즉, 시(time)라는 단일계(system)에서 <em><strong>같이, 함께</strong></em> 무언가가 이루어지는 두 개 이상의 개체 혹은 이벤트를 의미한다고 볼 수 있다.</p>
<ul>
<li>호출된 함수의 수행 결과 및 종료를 호출한 함수가(호출된 함수뿐 아니라 호출한 함수도 함께) 신경 쓰면 Synchronous</li>
<li>호출된 함수의 수행 결과 및 종류를 호출된 함수 혼자 직접 신경 쓰고 처리한다면(as a callback function) Asynchronus</li>
</ul>
<h3 id="예제"> 예제</h3>
<h4 id="blocking-synchronous"> Blocking &amp; Synchronous</h4>
<div><pre><code>나 : 대표님, 개발자 좀 더 뽑아주세요..
대표님 : 오케이, 잠깐만 거기 계세요!
나 : …?!!
대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
나 : (과정 지켜봄.. 궁금함.. 어차피 내 일 하러는 못 가고 계속 서 있음)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="blocking-asynchronous"> Blocking &amp; Asynchronous</h4>
<div><pre><code>나 : 대표님, 개발자 좀 더 뽑아주세요..
대표님 : 오케이, 잠깐만 거기 계세요!
나 : …?!!
대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
나 : (안 궁금함.. 지나가는 말로 여쭈었는데 붙잡혀버림.. 딴 생각.. 못 가고 계속 서 있음)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="non-blocking-synchronous"> Non-blocking &amp; Synchronous</h4>
<div><pre><code>나 : 대표님, 개발자 좀 더 뽑아주세요..
대표님 : 알겠습니다. 가서 볼 일 보세요.
나 : 넵!
대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
나 : 채용하셨나요?
대표님 : 아직요.
나 : 채용하셨나요?
대표님 : 아직요.
나 : 채용하셨나요?
대표님 : 아직요~!!!!!!
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="non-blocking-asynchronous"> Non-blocking &amp; Asynchronous</h4>
<div><pre><code>나 : 대표님, 개발자 좀 더 뽑아주세요..
대표님 : 알겠습니다. 가서 볼 일 보세요.
나 : 넵!
대표님 : (채용 공고 등록.. 지원자 연락.. 면접 진행.. 연봉 협상..)
나 : (열일중..)
대표님 : 한 분 모시기로 했습니다~!
나 : 😍
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><br>
<h2 id="_1006-spring5-webclient"> 1006 - Spring5 WebClient</h2>
<h3 id="webclient란"> WebClient란?</h3>
<blockquote>
<p>Spring WebClient란? 웹으로 API를 호출하기 위해 사용되는 Non-Blocking 방식의 Http Client 모듈 중 하나이다.</p>
</blockquote>
<p>Java에서 가장 많이 사용하는 Http Clent는 RestTemplate이다. 차이점은 RestTemplate는 Blocking방식이고, WebClient는 Non-Blocking방식이다.</p>
<h3 id="간단한예제"> 간단한예제</h3>
<h4 id="building-with"> Building with</h4>
<ul>
<li>maven</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-webflux<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>gradle</li>
</ul>
<div><pre><code>dependencies <span>{</span>
    compile 'org.springframework.boot<span>:</span>spring<span>-</span>boot<span>-</span>starter<span>-</span>webflux'
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="instance-생성"> Instance 생성</h4>
<div><pre><code><span>WebClient</span> client1 <span>=</span> <span>WebClient</span><span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
<span>// or</span>
<span>WebClient</span> client1 <span>=</span> <span>WebClient</span><span>.</span><span>create</span><span>(</span><span>"http://localhost:8080"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>WebClient</span> client3 <span>=</span> <span>WebClient</span>
                    <span>.</span><span>builder</span><span>(</span><span>)</span>
                    <span>.</span><span>baseUrl</span><span>(</span><span>)</span>
                    <span>.</span><span>defaultCookie</span><span>(</span><span>)</span>
                    <span>.</span><span>defaultHeader</span><span>(</span><span>)</span>
                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="webclient-java-config"> WebClient Java Config</h4>
<div><pre><code><span>@Configuration</span>
<span>@Slf4j</span>
<span>public</span> <span>class</span> <span>WebClientConfig</span> <span>{</span>

    <span>@Bean</span>
    <span>public</span> <span>WebClient</span> <span>webClient</span><span>(</span><span>)</span> <span>{</span>
        <span>// ExchangeStrategies HTTP 메세지 reader/writer 커스텀</span>
        <span>ExchangeStrategies</span> exchangeStrategies <span>=</span> <span>ExchangeStrategies</span><span>.</span><span>builder</span><span>(</span><span>)</span>
                                                                  <span>.</span><span>codecs</span><span>(</span>configurer <span>-></span> configurer<span>.</span><span>defaultCodecs</span><span>(</span><span>)</span><span>.</span><span>maxInMemorySize</span><span>(</span><span>1024</span><span>*</span><span>1024</span><span>*</span><span>50</span><span>)</span><span>)</span>
                                                                  <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
        exchangeStrategies
            <span>.</span><span>messageWriters</span><span>(</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span>
            <span>.</span><span>filter</span><span>(</span><span>LoggingCodecSupport</span><span>.</span><span>class</span><span>::</span><span>isInstance</span><span>)</span>
            <span>.</span><span>forEach</span><span>(</span>writer <span>-></span> <span>(</span><span>(</span><span>LoggingCodecSupport</span><span>)</span>writer<span>)</span><span>.</span><span>setEnableLoggingRequestDetails</span><span>(</span><span>true</span><span>)</span><span>)</span><span>;</span>

        <span>return</span> <span>WebClient</span><span>.</span><span>builder</span><span>(</span><span>)</span>
                <span>.</span><span>clientConnector</span><span>(</span>
                    <span>new</span> <span>ReactorClientHttpConnector</span><span>(</span>
                        <span>HttpClient</span>
                            <span>.</span><span>create</span><span>(</span><span>)</span>
                            <span>.</span><span>secure</span><span>(</span>
                                <span>ThrowingConsumer</span><span>.</span><span>unchecked</span><span>(</span>
                                    sslContextSpec <span>-></span> sslContextSpec<span>.</span><span>sslContext</span><span>(</span>
                                        <span>SslContextBuilder</span><span>.</span><span>forClient</span><span>(</span><span>)</span><span>.</span><span>trustManager</span><span>(</span><span>InsecureTrustManagerFactory</span><span>.</span>INSTANCE<span>)</span><span>.</span><span>build</span><span>(</span><span>)</span>
                                    <span>)</span>
                                <span>)</span>
                            <span>)</span>
                            <span>// timeout 설정</span>
                            <span>.</span><span>tcpConfiguration</span><span>(</span>
                                client <span>-></span> client<span>.</span><span>option</span><span>(</span><span>ChannelOption</span><span>.</span>CONNECT_TIMEOUT_MILLIS<span>,</span> <span>120_000</span><span>)</span>
                                                <span>.</span><span>doOnConnected</span><span>(</span>conn <span>-></span> conn<span>.</span><span>addHandlerLast</span><span>(</span><span>new</span> <span>ReadTimeoutHandler</span><span>(</span><span>180</span><span>)</span><span>)</span>
                                                                           <span>.</span><span>addHandlerLast</span><span>(</span><span>new</span> <span>WriteTimeoutHandler</span><span>(</span><span>180</span><span>)</span><span>)</span>
                                                <span>)</span>
                            <span>)</span>
                    <span>)</span>
                <span>)</span>
                <span>.</span><span>exchangeStrategies</span><span>(</span>exchangeStrategies<span>)</span>
                <span>// request 로그</span>
                <span>.</span><span>filter</span><span>(</span><span>ExchangeFilterFunction</span><span>.</span><span>ofRequestProcessor</span><span>(</span>
                    clientRequest <span>-></span> <span>{</span>
                        log<span>.</span><span>debug</span><span>(</span><span>"Request: {} {}"</span><span>,</span> clientRequest<span>.</span><span>method</span><span>(</span><span>)</span><span>,</span> clientRequest<span>.</span><span>url</span><span>(</span><span>)</span><span>)</span><span>;</span>
                        clientRequest<span>.</span><span>headers</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span>name<span>,</span> values<span>)</span> <span>-></span> values<span>.</span><span>forEach</span><span>(</span>value <span>-></span> log<span>.</span><span>debug</span><span>(</span><span>"{} : {}"</span><span>,</span> name<span>,</span> value<span>)</span><span>)</span><span>)</span><span>;</span>
                        <span>return</span> <span>Mono</span><span>.</span><span>just</span><span>(</span>clientRequest<span>)</span><span>;</span>
                    <span>}</span>
                <span>)</span><span>)</span>
                <span>// response 로그</span>
                <span>.</span><span>filter</span><span>(</span><span>ExchangeFilterFunction</span><span>.</span><span>ofResponseProcessor</span><span>(</span>
                    clientResponse <span>-></span> <span>{</span>
                        clientResponse<span>.</span><span>headers</span><span>(</span><span>)</span><span>.</span><span>asHttpHeaders</span><span>(</span><span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span>name<span>,</span> values<span>)</span> <span>-></span> values<span>.</span><span>forEach</span><span>(</span>value <span>-></span> log<span>.</span><span>debug</span><span>(</span><span>"{} : {}"</span><span>,</span> name<span>,</span> value<span>)</span><span>)</span><span>)</span><span>;</span>
                        <span>return</span> <span>Mono</span><span>.</span><span>just</span><span>(</span>clientResponse<span>)</span><span>;</span>
                    <span>}</span>
                <span>)</span><span>)</span>
                <span>.</span><span>defaultHeader</span><span>(</span><span>"user-agent"</span><span>,</span> <span>"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.87 Safari/537.3"</span><span>)</span>
                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><ul>
<li>
<p>MaxInMemorySize<br>
ExchageStrategies.builder()를 통해 in-memory buffer값을 변경 (기본256KB)</p>
</li>
<li>
<p>Logging<br>
ExchageStrateges와 logging level설정</p>
</li>
</ul>
<h4 id="사용"> 사용</h4>
<ul>
<li>@Bean으로 등록된 WebClient는 다음과 같이 사용</li>
</ul>
<div><pre><code><span>@Service</span>
<span>@RequiredArgsConstructor</span>
<span>@Slf4j</span>
<span>public</span> <span>class</span> <span>SomeService</span> <span>implements</span> <span>SomeInterface</span> <span>{</span>

    <span>private</span> <span>final</span> <span>WebClient</span> webClient<span>;</span>
    <span>public</span> <span>Mono</span><span><span>&lt;</span><span>SomeData</span><span>></span></span> <span>getSomething</span><span>(</span><span>)</span> <span>{</span>
  
    <span>return</span> webClient<span>.</span><span>mutate</span><span>(</span><span>)</span>
                    <span>.</span><span>build</span><span>(</span><span>)</span>
                    <span>.</span><span>get</span><span>(</span><span>)</span>
                    <span>.</span><span>uri</span><span>(</span><span>"/resource"</span><span>)</span>
                    <span>.</span><span>retrieve</span><span>(</span><span>)</span>
                    <span>.</span><span>bodyToMono</span><span>(</span><span>SomeData</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="retrieve-exchange"> retrieve(), exchange()</h4>
<p>HTTP 호출 결과를 가져오는 두 가지 방법으로 retrieve()와 exchange()가 있다. Spring에서는 exchange를 이용하게 되면 Response 컨텐츠에 대한 모든 처리를 직접 하면서 발생할 수 있는 memory leak 가능성 떄문에 가급적 retrieve를 사용하기를 권고한다.</p>
<div><pre><code><span>Mono</span><span><span>&lt;</span><span>Person</span><span>></span></span> result <span>=</span> webClient<span>.</span><span>get</span><span>(</span><span>)</span>
                               <span>.</span><span>uri</span><span>(</span><span>"/persons/{id}"</span><span>,</span> id<span>)</span>
                               <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span> 
                               <span>.</span><span>retrieve</span><span>(</span><span>)</span> 
                               <span>.</span><span>bodyToMono</span><span>(</span><span>Person</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="_4xx-and-5xx처리"> 4xx and 5xx처리</h4>
<div><pre><code>webClient<span>.</span><span>mutate</span><span>(</span><span>)</span>
         <span>.</span><span>baseUrl</span><span>(</span><span>"https://some.com"</span><span>)</span>
         <span>.</span><span>build</span><span>(</span><span>)</span>
         <span>.</span><span>get</span><span>(</span><span>)</span>
         <span>.</span><span>uri</span><span>(</span><span>"/resource"</span><span>)</span>
         <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
         <span>.</span><span>retrieve</span><span>(</span><span>)</span>
         <span>.</span><span>onStatus</span><span>(</span>status <span>-></span> status<span>.</span><span>is4xxClientError</span><span>(</span><span>)</span> 
                          <span>||</span> status<span>.</span><span>is5xxServerError</span><span>(</span><span>)</span>
             <span>,</span> clientResponse <span>-></span>
                           clientResponse<span>.</span><span>bodyToMono</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span>
                           <span>.</span><span>map</span><span>(</span>body <span>-></span> <span>new</span> <span>RuntimeException</span><span>(</span>body<span>)</span><span>)</span><span>)</span>
         <span>.</span><span>bodyToMono</span><span>(</span><span>SomeData</span><span>.</span><span>class</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="get-예제"> GET 예제</h4>
<div><pre><code><span>public</span> <span>Mono</span><span><span>&lt;</span><span>SomeData</span><span>></span></span> <span>getData</span><span>(</span><span>Integer</span> id<span>,</span> <span>String</span> accessToken<span>)</span> <span>{</span>
    <span>return</span>
        webClient<span>.</span><span>mutate</span><span>(</span><span>)</span>
                 <span>.</span><span>baseUrl</span><span>(</span><span>"https://some.com/api"</span><span>)</span>
                 <span>.</span><span>build</span><span>(</span><span>)</span>
                 <span>.</span><span>get</span><span>(</span><span>)</span>
                 <span>.</span><span>uri</span><span>(</span><span>"/resource?id={ID}"</span><span>,</span> id<span>)</span>
                 <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
                 <span>.</span><span>header</span><span>(</span><span>HttpHeaders</span><span>.</span>AUTHORIZATION<span>,</span> <span>"Bearer "</span> <span>+</span> accessToken<span>)</span>
                 <span>.</span><span>retrieve</span><span>(</span><span>)</span>
                 <span>.</span><span>bodyToMono</span><span>(</span><span>SomeData</span><span>.</span><span>class</span><span>)</span>
        <span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="post-예제"> POST 예제</h4>
<ul>
<li>form 데이터 전송</li>
</ul>
<div><pre><code>webClient<span>.</span><span>mutate</span><span>(</span><span>)</span>
         <span>.</span><span>baseUrl</span><span>(</span><span>"https://some.com/api"</span><span>)</span>
         <span>.</span><span>build</span><span>(</span><span>)</span>
         <span>.</span><span>post</span><span>(</span><span>)</span>
         <span>.</span><span>uri</span><span>(</span><span>"/login"</span><span>)</span>
         <span>.</span><span>contentType</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_FORM_URLENCODED<span>)</span>
         <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
         <span>.</span><span>body</span><span>(</span><span>BodyInserters</span><span>.</span><span>fromFormData</span><span>(</span><span>"id"</span><span>,</span> idValue<span>)</span>
                            <span>.</span><span>with</span><span>(</span><span>"pwd"</span><span>,</span> pwdValue<span>)</span>
         <span>)</span>
         <span>.</span><span>retrieve</span><span>(</span><span>)</span>
         <span>.</span><span>bodyToMono</span><span>(</span><span>SomeData</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>JSON body 데이터 전송</li>
</ul>
<div><pre><code>webClient<span>.</span><span>mutate</span><span>(</span><span>)</span>
         <span>.</span><span>baseUrl</span><span>(</span><span>"https://some.com/api"</span><span>)</span>
         <span>.</span><span>build</span><span>(</span><span>)</span>
         <span>.</span><span>post</span><span>(</span><span>)</span>
         <span>.</span><span>uri</span><span>(</span><span>"/login"</span><span>)</span>
         <span>.</span><span>contentType</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
         <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
         <span>.</span><span>bodyValue</span><span>(</span>loginInfo<span>)</span>
         <span>.</span><span>retrieve</span><span>(</span><span>)</span>
         <span>.</span><span>bodyToMono</span><span>(</span><span>SomeData</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="delete"> DELETE</h4>
<div><pre><code>webClient<span>.</span><span>mutate</span><span>(</span><span>)</span>
         <span>.</span><span>baseUrl</span><span>(</span><span>"https://some.com/api"</span><span>)</span>
         <span>.</span><span>build</span><span>(</span><span>)</span>
         <span>.</span><span>delete</span><span>(</span><span>)</span>
         <span>.</span><span>uri</span><span>(</span><span>"/resource/{ID}"</span><span>,</span> id<span>)</span>
         <span>.</span><span>retrieve</span><span>(</span><span>)</span>
         <span>// Void 반환</span>
         <span>.</span><span>bodyToMono</span><span>(</span><span>Void</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><br>
<h2 id="_1010-inner-class에-static을-붙이는-이유"> 1010 - Inner class에 Static을 붙이는 이유</h2>
<h3 id="nested-class"> Nested Class</h3>
<div><pre><code>- Nested classes
    - Inner classes
        - Inner classes
        - Method local Inner classes
        - Anonymous Inner classes (익명클래스)
    - Static Nested classes
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>자바는 일반적인 클래스를 제외하고 일반적으로 클래스의 중첩을 이렇게 나눈다.</p>
<h4 id="nested-class-2"> Nested Class</h4>
<ul>
<li>패키지가 되는 클래스가 아닌 나머지 클래스</li>
<li>하나의 패키지에 대해 여러 클래스를 사용할 수 있고, 서로간 결합만이 존재하는 클래스의 경우 가독성이 좋고 관리하기 편하다.</li>
</ul>
<blockquote>
<p>클래스가 다른 클레스에만 유용 할 경우 해당 클래스에 클래스를 포함시키고 두 클래스를 핢께 유지하는 것이 논리적이다. 이러한 &quot;헬퍼 클래스&quot;를 중첩하면 패키지가 더욱 간소화된다.</p>
</blockquote>
<ul>
<li>중첩 클래스들은 패키지 클래스 내부에 숨겨져있으므로 캡슐화에 도움이 된다.</li>
</ul>
<blockquote>
<p>A와 B라는 두 가지 최상위 클래스를 고려한다. 여기서 B는 선언 될 A의 멤버에 액세스해야한다. 클래스 A 내에 클래스 B를 숨기면 A의 구성원을 비공개로 선언하고 B가 액세스 할 수 있다. 또한 B 자체는 외부 세계에서 숨길 수 있다.</p>
</blockquote>
<h4 id="non-static-nested-class"> non-static nested class</h4>
<ul>
<li>Inner class라고 하며 외부 인스턴스에 대한 참조가 유지된다.</li>
<li>외부 인스턴스는 내부 클래스를 new를 통한 인스턴스 할당으로 멤버변수러첢 사용할 수 있다.</li>
<li>외부에 대한 참조가 유지되므로 내부 클래스도 외부 클래스의 자원을 사용할 수 있다.</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>
	<span>class</span> <span>Inner</span> <span>{</span>
    <span>}</span>
  <span>}</span>
  
<span>Outer</span> outer <span>=</span> <span>new</span> <span>Outer</span><span>(</span><span>)</span><span>;</span>
<span>Outer<span>.</span>Inner</span> inner <span>=</span> <span>new</span> <span>Outer<span>.</span>Inner</span><span>(</span><span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="static-nested-class"> static nested class</h4>
<ul>
<li>static이 붙는 중첩 클래스</li>
<li>동일한 static 멤버들을 사용 가능</li>
<li>static의 특징에 따라 외부 인스턴스 멤버의 직접참조가 불가능</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Outer</span> <span>{</span>
	<span>static</span> <span>class</span> staticNasted <span>{</span>
    <span>}</span>
  <span>}</span>
  
<span>Outer<span>.</span>Inner</span> staticNasted <span>=</span> <span>new</span> <span>Outer<span>.</span>Inner</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="차이"> 차이</h4>
<ul>
<li>외부 참조의 여부</li>
<li>외부 참조가 유지된다는 것은 메모리에 대한 참조가 유지되고 있다는 뜻으로 GC가 메모리를 회수할 수없다. 당연히 이는 메모리 누수를 부르는 치명적인 단점.</li>
<li>항상 외부 인스턴스의 참조를 통해야 하므로 성능 상 비효율적.</li>
<li>결국 외부 인스턴스에 대한 참조가 필요하지 않다면 static nested class가 낫다.</li>
<li>여기서의 staitc의 의미는 외부 인스턴스 없이 내부 클래스르의 인스턴스를 바로 생성할 수 있다는 뜻으로 사용 된다.</li>
</ul>
<h3 id="spring-boot에서-dto관리를-위한-static-nested-class"> Spring Boot에서 DTO관리를 위한 static nested class</h3>
<ul>
<li>DTO 예제</li>
</ul>
<div><pre><code><span>import</span> <span>lombok<span>.</span></span><span>AllArgsConstructor</span><span>;</span>
<span>import</span> <span>lombok<span>.</span></span><span>Builder</span><span>;</span>
<span>import</span> <span>lombok<span>.</span></span><span>Getter</span><span>;</span>
<span>import</span> <span>lombok<span>.</span></span><span>Setter</span><span>;</span>

<span>public</span> <span>class</span> <span>User</span> <span>{</span>

    <span>@Getter</span>
    <span>@AllArgsConstructor</span>
    <span>@Builder</span>
    <span>public</span> <span>static</span> <span>class</span> <span>Info</span> <span>{</span>
        <span>private</span> <span>int</span> id<span>;</span>
        <span>private</span> <span>String</span> name<span>;</span>
        <span>private</span> <span>int</span> age<span>;</span>
    <span>}</span>

    <span>@Getter</span>
    <span>@Setter</span>
    <span>public</span> <span>static</span> <span>class</span> <span>Request</span> <span>{</span>
        <span>private</span> <span>String</span> name<span>;</span>
        <span>private</span> <span>int</span> age<span>;</span>
    <span>}</span>

    <span>@Getter</span>
    <span>@AllArgsConstructor</span>
    <span>public</span> <span>static</span> <span>class</span> <span>Response</span> <span>{</span>
        <span>private</span> <span>Info</span> info<span>;</span>
        <span>private</span> <span>int</span> returnCode<span>;</span>
        <span>private</span> <span>String</span> returnMessage<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><ul>
<li>Controller</li>
</ul>
<div><pre><code><span>import</span> <span>com<span>.</span>parksh<span>.</span>demo<span>.</span>dto<span>.</span></span><span>DefaultResponse</span><span>;</span>
<span>import</span> <span>com<span>.</span>parksh<span>.</span>demo<span>.</span>dto<span>.</span>user<span>.</span></span><span>User</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>*</span><span>;</span>

<span>@RestController</span>
<span>@RequestMapping</span><span>(</span>“user”<span>)</span>
<span>public</span> <span>class</span> <span>UserController</span> <span>{</span>

    <span>@GetMapping</span><span>(</span>“<span>/</span><span>{</span>user_id<span>}</span>”<span>)</span>
    <span>public</span> <span>User<span>.</span>Response</span> <span>getUser</span><span>(</span><span>@PathVariable</span><span>(</span>“user_id”<span>)</span> <span>String</span> userId<span>)</span> <span>{</span>

        <span>return</span> <span>new</span> <span>User<span>.</span>Response</span><span>(</span><span>new</span> <span>User<span>.</span>Info</span><span>(</span><span>)</span><span>,</span> <span>200</span><span>,</span> “success”<span>)</span><span>;</span>
    <span>}</span>

    <span>@PostMapping</span>
    <span>public</span> <span>DefaultResponse</span> <span>addUser</span><span>(</span><span>@RequestBody</span> <span>User<span>.</span>Info</span> info<span>)</span> <span>{</span>

        <span>return</span> <span>new</span> <span>DefaultResponse</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1018 - 1024</title>
      <link>ahnjs/TIL/2021/1018/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1018/</guid>
      <source url="ahnjs/TIL/rss.xml">1018 - 1024</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1018-1024"> 1018 - 1024</h1>
<h2 id="_1018-junit의-assertthat-assertj의-assertthat"> 1018 - JUnit의 assertThat, assertj의 assertThat</h2>
<p>테스트 코드는 크게 <code>실행 단계</code>, <code>검증 단계</code>로 나눌 수 있다.</p>
<ul>
<li>실행 단계에서는 사용자 입력을 모방하여 테스트할 로직을 실행</li>
<li>검증 단계에서는 실행 단계가 예상한 대로 동작하는지 검증
JUnit에서 검증 단계를 도와주는 메소드가 바로 assertThat이라는 메소드다.</li>
</ul>
<h3 id="org-junit-assert-assertthat"> org.junit.Assert.assertThat</h3>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>void</span> <span>assertThat</span><span>(</span><span>T</span> actual<span>,</span> <span>Matcher</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> matcher<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>org.junit.Assert.assertThat의 기본 형태</li>
<li>actual 인자에 검증대상(실행 단계의 결과)을 넣고, 이와 비교하는 로직(matcher)을 주입받아 검증 단계를 수행한다.</li>
</ul>
<blockquote>
<p>개발자가 matcher를 직접 구현하는것은 비효율적이고, 구현한 matcher에서 오류가 발생할 수 도 있다. matcher에서 오류가 발생하면 테스트가 실패하는데, 외부 요인에 영향을 받는 것은 좋은 테스트라고 할 수 없다. 따라서 JUnit의 assertThat은 hamcrest에 구현된 matcher을 사용하도록 강제하고 있다.</p>
</blockquote>
<h4 id="org-junit-assert-assertthat-예제-코드"> org.junit.Assert.assertThat 예제 코드</h4>
<ul>
<li>0보다 커야한다</li>
</ul>
<div><pre><code><span>import</span> <span>static</span> <span>org<span>.</span>junit<span>.</span></span><span>Assert</span><span>.</span>assertThat<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>Matchers</span><span>.</span>greaterThan<span>;</span>

<span>.</span><span>.</span><span>.</span>
<span>@Test</span>
<span>public</span> <span>void</span> <span>number_test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>int</span> number <span>=</span> <span>3</span><span>;</span>

    <span>int</span> result <span>=</span> mathService<span>.</span><span>add</span><span>(</span>number<span>,</span> <span>3</span><span>)</span><span>;</span>

    <span>assertThat</span><span>(</span>result<span>,</span> <span>greaterThan</span><span>(</span><span>0</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>0보다 크고 10보다는 작야야 한다.</li>
</ul>
<div><pre><code><span>import</span> <span>static</span> <span>org<span>.</span>junit<span>.</span></span><span>Assert</span><span>.</span>assertThat<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>Matchers</span><span>.</span>greaterThan<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span></span><span>Matchers</span><span>.</span>lessThan<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>hamcrest<span>.</span>core<span>.</span></span><span>AllOf</span><span>.</span>allOf<span>;</span>

<span>.</span><span>.</span><span>.</span>
<span>@Test</span>
<span>public</span> <span>void</span> <span>number_test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>int</span> number <span>=</span> <span>3</span><span>;</span>

    <span>int</span> result <span>=</span> mathService<span>.</span><span>add</span><span>(</span>number<span>,</span> <span>3</span><span>)</span><span>;</span>

    <span>assertThat</span><span>(</span>result<span>,</span> <span>allOf</span><span>(</span>
        <span>greaterThan</span><span>(</span><span>0</span><span>)</span><span>,</span>
        <span>lessThan</span><span>(</span><span>10</span><span>)</span>
    <span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="org-junit-assert-assertthat-단점"> org.junit.Assert.assertThat 단점</h4>
<ul>
<li>
<p>자동완성<br>
allOf, greaterThan, lessThan 등의 메소드들을 미리 import 해놓지 않으면, IDE에서 자동완성을 해주지 못하기 때문에 필요한 메소드를 공식문서에서 찾거나, 이름을 외워서 작성해야 한다.</p>
</li>
<li>
<p>Assertion 분류(matcher)<br>
위 로직에서는 int 타입에 대한 matcher만 필요한데, org.hamcrest.Matchers 클래스에는 여러 타입에 대한 matcher가 함께 들어있다. 그래서 원하는 matcher를 찾기가 힘들다.</p>
</li>
<li>
<p>확장성<br>
추가된 조건도 같이 검증하기 위해서 allOf라는 메소드로 기존 조건과 묶어줘야 했다. assertj에서는 이런 불편함을 해결하고 메소드 체이닝 패턴형식으로 사용 가독성을 향상시킨 assertThat을 제공한다.</p>
</li>
</ul>
<h3 id="org-assertj-core-api-assertions-assertthat"> org.assertj.core.api.Assertions.assertThat</h3>
<div><pre><code><span>public</span> <span>static</span> <span>AbstractAssert</span><span><span>&lt;</span>SELF<span>,</span> <span>T</span><span>></span></span> <span>assertThat</span><span>(</span><span>T</span> actual<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>assertj의 assertThat은 인자로 actual(검증대상)만 받는다. 그리고 actual의 타입에 따라 AbstractAssert라는 추상클래스를 상속한 Assert 상속한 Assert 클래스를 반환한다.</li>
</ul>
<div><pre><code><span>public</span> <span>static</span> <span>AbstractIntegerAssert</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>assertThat</span><span>(</span><span>int</span> actual<span>)</span>
<span>public</span> <span>static</span> <span>AbstractDateAssert</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>assertThat</span><span>(</span><span>Date</span> actual<span>)</span>
<span>public</span> <span>static</span> <span>AbstractUriAssert</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>assertThat</span><span>(</span><span>URI</span> actual<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>타입에 따라 각 Assert 클래스를 반환하고 각 클래스들은 타입에 맞는 Assertion 메소드를 제공한다.</p>
<ul>
<li>AbstractIntegerAssert (java.long.Integer)
<ul>
<li>isGreaterThan(int other)</li>
<li>isLessThan(int other)</li>
<li>...</li>
</ul>
</li>
<li>AbstractDateAssert (java.util.Date)
<ul>
<li>hasTime(long timestamp)</li>
<li>hasYear(int year)</li>
<li>isAfter(Date other)</li>
<li>isBefore(Date other)</li>
<li>...</li>
</ul>
</li>
<li>AbstractUriAssert (java.net.URI)
<ul>
<li>hasNoParameters()</li>
<li>hasNoQuery()</li>
<li>hasNoPort()</li>
<li>...</li>
</ul>
</li>
</ul>
<p>=&gt; 각 Assertion 메소드는 반환 타입이 SELF 이기 때문에 메소드 체이닝 패턴으로 테스트 로직을 작성할 수 있다.</p>
<h4 id="org-assertj-core-api-assertions-assertthat-예제-코드"> org.assertj.core.api.Assertions.assertThat 예제 코드</h4>
<div><pre><code><span>import</span> <span>static</span> <span>org<span>.</span>assertj<span>.</span>core<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>assertThat<span>;</span>

<span>.</span><span>.</span><span>.</span>
<span>@Test</span>
<span>public</span> <span>void</span> <span>number_test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>int</span> number <span>=</span> <span>3</span><span>;</span>

    <span>int</span> result <span>=</span> mathService<span>.</span><span>add</span><span>(</span>number <span>,</span><span>3</span><span>)</span><span>;</span>

    <span>assertThat</span><span>(</span>result<span>)</span>
                <span>.</span><span>isGreaterThan</span><span>(</span><span>0</span><span>)</span>
                <span>.</span><span>isLessThan</span><span>(</span><span>10</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="정리"> 정리</h3>
<p>JUnit, AssertJ가 제공하는 assertThat 메소드를 비교한 결과
자동완성, Assertion분류, 확장성 세가지의 이유로 AssertJ의 assertThat을 사용해야 한다고 생각한다.</p>
<br>
<h2 id="_1019-정적-멤버-static-정적-키워드"> 1019 - 정적 멤버 static (정적 키워드)</h2>
<h3 id="static-키워드"> static 키워드</h3>
<blockquote>
<p>클래스 멤버(변수, 메소드)에 붙이는 키워드<br>
멤버변수는 클래스가 객체로 생성될 때 메모리에 로딩하지만, static 키워드가 붙은 멤버는 프로그램이 실행 될 때 메모리에 로드된다.<br>
클래스 멤버이긴 하지만 자기가 로드되기 위한 공간으로써만 클래스안에 선언하는 의미가 있다.</p>
</blockquote>
<ol>
<li>멤버변수</li>
<li>멤버 메소드</li>
</ol>
<ul>
<li>메소드 내에서 사용 불가</li>
</ul>
<h3 id="멤버변수"> 멤버변수</h3>
<ul>
<li>static 변수, 정적변수, 공용변수</li>
<li>인스턴스를 생성하지 않고 바로 <code>클래스명.메소드()</code> 또는 <code>클래스명.변수명</code>으로 접근이 가능하다.
<ul>
<li>Util Class : java.uitl.Math</li>
</ul>
</li>
<li>멤버변수는 메모리에 한번 할당되어 프로그램이 종료될 떄 해제되는 변수로, 메모리에 한번 할당되므로 여러 객체가 해당 메모리를 공유하게 된다.</li>
<li>멤버 메소드를 호출하는 메소드 또한 멤버 메소드로 선언되어야 한다.</li>
</ul>
<h3 id="사용"> 사용</h3>
<ul>
<li>static 변수 : 일반적으로 상수들만 모아서 사용하며 상수의 변수명은 대문자와 _를 조합하여 이름짓고, 또한 상속을 방지하기 위해 final class로 선언을 한다.</li>
<li>static 메소드 : 상속을 방지하기 위해 final class로 선언을 하고, 유틸 관련된 함수들을 모아둔다.</li>
</ul>
<br>
<h2 id="_1020-트랜잭션-격리-수준-isolation-level"> 1020 - 트랜잭션 격리 수준(isolation level)</h2>
<h3 id="트랜잭션-격리수준이란"> 트랜잭션 격리수준이란?</h3>
<blockquote>
<p>트랜잭션 격리수준(isolation level)이란 동시에 여러 트랜잭션이 처리될 떄, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나태내는 것이다.<br>
즉, 간단하게 말해 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.</p>
</blockquote>
<p>데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.</p>
<p>하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 된다. 하지만, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생 할 수 있다.</p>
<p>따라서 최대한 효율적인 Locking 방법이 필요하다.</p>
<h3 id="lock"> Lock</h3>
<ul>
<li>Lock : 트랜잭션 처리의 순차성을 보장하기 위한 방법(동시성 제어)<br>
DBMS 마다 Lock을 구현하는 방식이 다르기 때문에 DBMS를 효과적으로 이용하기 위해서 해당 DB의 Lock에 대한 이해가 요구된다.
<ul>
<li>공유(shared) lock : 데이터를 읽을 때 사용되어 지는 lock.
<ul>
<li>공유락은 공유락끼리 동시에 접근이 가능하다. 하지만, 공유락이 설정된 데이터에 배타락을 사용할 수는 없다.</li>
</ul>
</li>
<li>배타(Exclusive) lock : 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 떄까지 유지된다.
<ul>
<li>Lock이 해제될 떄까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다.</li>
<li>해당 Lockdms 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함꼐 Lock을 설정할 수 없다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="격리-수준"> 격리 수준</h3>
<ul>
<li>READ UNCOMMITTED (레벨 0)
<ul>
<li>SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층</li>
<li>트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함</li>
<li>데이터베이스의 일관성을 유지하는 것이 불가능함</li>
<li>Dirty Read 발생 =&gt; 데이터 정합성에 문제발생</li>
</ul>
</li>
<li>READ COMMITTED (레벨 1)
<ul>
<li>SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층</li>
<li>트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨</li>
<li>Commit이 이루어진 트랜잭셔만 조회 가능</li>
<li>Non-Repeatable Read 발생</li>
</ul>
</li>
<li>REPEATABLE READ (레발 2)
<ul>
<li>트랜잭션이 완료될 때까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸리는 계층</li>
<li>트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함</li>
<li>다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능</li>
<li>Non-Repeatable Read 부정합이 발생하지 않음</li>
<li>자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된) 것만 보게 된다.</li>
<li>Phantom Read 발생</li>
</ul>
</li>
<li>SERIALIZABLE (레발 3)
<ul>
<li>트랜잭션이 완료될 떄까지 SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸리는 계층</li>
<li>가장 엄격한 격리 수준으로 완벽한 읽기 일관성 모드를 제공함</li>
<li>다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능</li>
</ul>
</li>
</ul>
<p>아래로 내려갈수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이다.<br>
일반적인 온라인 서비스에서는 <code>READ COMMITTED</code>나 <code>REPEATABLE READ</code> 중 하나를 사용한다.<br>
(oracle = READ COMMITTED, mysql = REPEATABLE READ)</p>
<h3 id="선택-시-고려사항"> 선택 시 고려사항</h3>
<p>Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있다.</p>
<div><pre><code>동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 된다.
=&gt; 트레이드 오프
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><br>
<h2 id="_1022-이분-탐색"> 1022 - 이분 탐색</h2>
<ul>
<li>이진 탐색(이분 탐색) 알고리즘은 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법이다.</li>
<li>이진 탐색은 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘이다.</li>
<li>변수 3개(start, end, mid)를 사용하여 탐색한다. 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 것이 이진 탐색의 과정이다.</li>
<li>시간 복잡도는 O(logN) 이다.</li>
</ul>
<h3 id="자바-구현"> 자바 구현</h3>
<ul>
<li>일반적인 이분 탐색 구현</li>
</ul>
<div><pre><code><span>private</span> <span>static</span> <span>boolean</span> <span>find</span><span>(</span><span>int</span> num<span>,</span> <span>int</span><span>[</span><span>]</span> arr<span>)</span> <span>{</span>
    <span>// left</span>
    <span>int</span> l <span>=</span> <span>0</span><span>;</span>
    <span>// right</span>
    <span>int</span> r <span>=</span> arr<span>.</span>length<span>-</span><span>1</span><span>;</span>

    <span>while</span><span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
        <span>int</span> mid <span>=</span> <span>(</span>l<span>+</span>r<span>)</span> <span>/</span> <span>2</span><span>;</span>
        <span>if</span><span>(</span>arr<span>[</span>mid<span>]</span> <span>==</span> num<span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>            
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>arr<span>[</span>mid<span>]</span> <span>></span> num<span>)</span> <span>{</span>
            r <span>=</span> mid<span>-</span><span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> mid<span>+</span><span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ul>
<li>Lower Bound, Upper Bound 구현</li>
</ul>
<div><pre><code><span>private</span> <span>static</span> <span>int</span> <span>lowerBound</span><span>(</span><span>int</span> num<span>)</span><span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>;</span>
    <span>int</span> r <span>=</span> arr<span>.</span>length<span>;</span>

    <span>while</span><span>(</span>l<span>&lt;</span>r<span>)</span><span>{</span>
        <span>int</span> mid <span>=</span> <span>(</span>l<span>+</span>r<span>)</span><span>/</span><span>2</span><span>;</span>

        <span>if</span><span>(</span>arr<span>[</span>mid<span>]</span> <span>>=</span> num<span>)</span><span>{</span>
            r <span>=</span> mid<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>return</span> l<span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>int</span> <span>upperBound</span><span>(</span><span>int</span> num<span>)</span><span>{</span>
    <span>int</span> l <span>=</span> <span>0</span><span>;</span>
    <span>int</span> r <span>=</span> arr<span>.</span>length<span>;</span>

    <span>while</span><span>(</span>l<span>&lt;</span>r<span>)</span><span>{</span>
        <span>int</span> mid <span>=</span> <span>(</span>l<span>+</span>r<span>)</span><span>/</span><span>2</span><span>;</span>
        <span>if</span><span>(</span>arr<span>[</span>mid<span>]</span> <span>&lt;=</span> num<span>)</span><span>{</span>
            l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            r <span>=</span> mid<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> l<span>;</span>
<span>}</span>   
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><br>
<h2 id="_1023-백엔드-기본-버전관리-시스템과-버전-관리-웹호스팅-서비스-결정"> 1023 - [백엔드 기본]버전관리 시스템과 버전 관리 웹호스팅 서비스 결정</h2>
<h3 id="버전-관리-시스템"> 버전 관리 시스템</h3>
<ul>
<li>사용이유 : 시스템의 도움을 받아 협업을 원활이 하는 것</li>
<li>변경을 쉽게 되돌릴 수 있다.</li>
<li>git, svn, mercurial</li>
</ul>
<h3 id="버전관리-웹호스팅-서비스"> 버전관리 웹호스팅 서비스</h3>
<ul>
<li>코드를 저장할 서버</li>
<li>hook을 통해 테스트실행 및 자동화 배포</li>
<li>pull request</li>
<li>github, gitlab, bitbucket</li>
<li>github : 이슈 트래커(GitHub Issues), Projects, ZenHub플러그인
<ul>
<li>특정 브랜치를 향한 pull request에 대해 n개 이상의 리뷰를 받아야 merge할 수 있는 기능</li>
<li>Organization에서 팀을 만들어 사용자를 포함시키고, 팀단위로 저장소에 각각에 read/write/admin 권한부여, 서브 팀을 만들어 더 세부적인 위계</li>
</ul>
</li>
</ul>
<h3 id="git-gui"> Git GUI</h3>
<ul>
<li>github desktop</li>
<li>source tree</li>
<li>gitkraken</li>
</ul>
<br>
<h2 id="_1024-백엔드-기본-개발-프로세스-정립"> 1024 - [백엔드 기본]개발 프로세스 정립</h2>
<h3 id="개발-프로세스-정립이란"> 개발 프로세스 정립이란?</h3>
<ul>
<li>개발 프로세스는 어떻게 이슈를 관리하고, 어떤 방식으로 작업을 진행하고, 완료된 작업은 어떤 과정을 거쳐서 실제 제품에 반영시킬지와 같은 것들을 규칙화 시킨 것이다.
<ul>
<li>작업들이 어떤 상태인지(준비 중/진행 중/완료)</li>
<li>이슈를 실제로 처리하는 입장에서, 개발 프로세스에 따라 작업을 진행하면 어느 브랜치에서 어떤 이름으로 브랜치를 생성할지/어느 브랜치로 pull request를 올리며 리뷰를 받아야 할지/master merge 후 어떤 후속 작업을 진행해야 하는지와 같은 고민을 줄일 수 있따. 실제로 작성하는 코드에만 집중하는 환경을 만들 수 있다.</li>
<li>잘 정립된 개발 프로세스는 생산성을 높이는 것에 기여하며, 작업의 진행을 매끄럽게 만들고, 결과물의 퀄리티를 높인다.</li>
</ul>
</li>
</ul>
<h3 id="이슈-관리-도구"> 이슈 관리 도구</h3>
<ul>
<li>작업자를 assign</li>
<li>이슈에 대해 커뮤니케이션</li>
<li>태그/라벨 등으로 이슈의 종류를 구분</li>
<li>이슈의 상태를 통해 시각화</li>
<li>되도록 GitHub 내에서 해결</li>
<li>Asana, Jira, Trello, GitHub Issues &amp; Projects</li>
<li>GitHub Issues &amp; Projects
<ul>
<li>assign, issue conversation, customized label, filter by label, projects에 issues 연동, projects의 automation 기능을 통해 이슈 구분과 이슈 상태 자동 갱신</li>
<li>GitHub Issues에서 이슈를 등록하면 해당 이슈에 대한 번호가 매겨지고, 커밋 메시지에 #123 같이 번호를 명시에 두면 자동으로 해당 이슈가 링크</li>
<li>Projects, Issues</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1011 - 1017</title>
      <link>ahnjs/TIL/2021/1011/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1011/</guid>
      <source url="ahnjs/TIL/rss.xml">1011 - 1017</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1011-1017"> 1011 - 1017</h2>
<h2 id="_1011-일급콜렉션-first-class-collection"> 1011 - 일급콜렉션(First Class Collection)</h2>
<h3 id="일급콜렉션이란"> 일급콜렉션이란</h3>
<blockquote>
<p>Collection으ㄹ Wrapping하면서, Wrapping한 Collection 외 다른 멤버 변수가 없는 상태를 일급 컬렉션이라 한다.</p>
</blockquote>
<ul>
<li>콜렉션을 포함한 클래스는 반드시 다른 멤버 변수가 없어야 한다.</li>
<li>각 콜렉션은 그 자체로 포장돼 있으므로 이제 콜렉션과 관련된 동작은 근거지가 마련된다.</li>
<li>새 클래스는 두 그룹을 같이 묶는다는가 그룹의 각 원소에 규칙을 적용하는 등의 동작을 처리할 수 있다. 이는 인스턴스 변수에 대한 규칙의 확실한 확장이지만 그 자체를 위해서도 중요하다.</li>
<li>콜렉션은 실로 매우 유용한 원시 타입이다.</li>
<li>많은 동작이 있지만 후임 프로그래머나 유지보수 담당자에 의미적 의도나 단초는 거의 없다.</li>
</ul>
<h3 id="일급컬렉션-예제"> 일급컬렉션 예제</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Car</span><span>></span></span> cars<span>;</span>
    <span>// ...</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Car</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> oil<span>;</span>
    <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>일급컬렉션으로 변환</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>Cars</span> cars<span>;</span>
    <span>// ...</span>
<span>}</span>

<span>// List&lt;Car> cars를 Wrapping</span>
<span>// 일급 컬렉션</span>
<span>public</span> <span>class</span> <span>Cars</span> <span>{</span>
    <span>// 멤버변수가 하나</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Car</span><span>></span></span> cars<span>;</span>
    <span>// ...</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Car</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> oil<span>;</span>
    <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>다음과 같이 List<T> collection 외 다른 멤버 변수가 없다.</li>
</ul>
<h3 id="장점"> 장점</h3>
<ul>
<li>컬렉션에게 상태와 로직 관리를 위임하여 로직이 사용되는 클래스의 부담을 줄일 수 있고, 중복코드를 줄일 수 있다.</li>
<li>컬렉션의 불변성을 보장한다.</li>
</ul>
<br>
<h2 id="_1012-모든-원시값과-문자열을-포장"> 1012 - 모든 원시값과 문자열을 포장</h2>
<h3 id="원시값과-문자열의-포장이란"> 원시값과 문자열의 포장이란</h3>
<blockquote>
<p>모든 원시값과 문자열을 포장하라 라는 말은 객체지향 체조 원칙에서 나온말로 Primitive Obsession Anti Pattern(도메인의 객체를 나타내기 위해 primitvie타입을 쓰는 나쁜 습관)을 피하기 위해 필요하다.<br>
즉, 원시값 포장은 원시 유형의 값(변수명)을 이용해 의미를 나타내지 않고, 의미있는 객체로 포장한다는 개념.</p>
</blockquote>
<p>int 값 하나 자체는 그냥 아무 의미 없는 스칼라(수치만으로 완전히 표시되는 양) 값일 뿐이다. 어떤 메서드가 int 값을 매개변수로 받는다면 그 메서드 이름은 해당 매개변수의 의도를 나타내기 위해 모든 수단과 방법을 가리지 않아야 한다. 만약 똑같은 메서드가 시간을 매개변수로 받을 경우, 무슨 일이 생기는지는 훨씬 자명하다. 이런 작은 객체가 프로그램의 유지보수성을 높일 수 있는 것은 시간 값을 매개변수로 받는 매서드에게 연도 값을 넘길 수 는 없기 때문이다. 원시형 변수로는 컴파일러가 의미적으로 맞는 프로그래 작성을 안내할 수 없다. 객체로라면 아주 사소하더라도 컴파일러와 프로그래머에게 그 값이 어떤 값이며, 왜 쓰고 있는지에 대한 정보를 전하는 셈이다.
또한 시간이나 돈과 같은 작은 객체는 행위를 놓을 분명한 곳을 마련해 주서, 그렇지 않았다면 다른 클래스의 주위를 겉돌았을지도 모르는 상태를 방지한다. 이는 특히 게터와 세터에 관련된 규칙을 적용하고 그런 작은 객체많이 값에 접근할 수 있을 때 그렇다.</p>
<h3 id="원시값-포장-예제"> 원시값 포장 예제</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Lotto</span> <span>{</span>
    <span>int</span> number <span>=</span> <span>1</span><span>;</span>    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>해당 코드로는 number가 숫자라는 것 이상의 이야기를 할 수 없다.</li>
<li>또한 변수명으로 의미를 부여한다.</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Lotto</span> <span>{</span>
    <span>LottoNumber</span> number <span>=</span> <span>1</span><span>;</span>    
<span>}</span>

<span>public</span> <span>class</span> <span>LottoNumber</span> <span>{</span>
    <span>int</span> value<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>클래스를 사용해 int타입의 원시값을 감싸서 표현. 명확한 의미를 전달</li>
<li>이처럼 원시값을 포장한다는 규칙은 의견이 분분하게 나뉠 수 있느 해석의 단초를 잘 꿰어주는 동시에 값을 의미적으로 사용할 수 있게 해주는 규칙이 된다.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1025 - 1031</title>
      <link>ahnjs/TIL/2021/1025/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1025/</guid>
      <source url="ahnjs/TIL/rss.xml">1025 - 1031</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1025-1031"> 1025 - 1031</h1>
<h2 id="_1025-백엔드-기본-api-설계-원칙과-직렬화-포맷-결정"> 1025 - [백엔드 기본]API 설계 원칙과 직렬화 포맷 결정</h2>
<p>API 설계 원칙과 직렬화 포맷을 결정 → '당연히 REST랑 JSON아님?'이라 하며 관례적으로 결정하지말고 항상 의사결정 과정에 끼워 둬야한다. 현재로선 일잔적으로 사용되는 HTTP/1.1을 사용하는 것으로 진행(HTTP/2)도 고려</p>
<h3 id="api-설계-원칙"> API 설계 원칙</h3>
<p>우리는 결론적으로 웹 어플리케이션 서버를 개발하고 운영하는 것이 목적이므로, '이렇게 HTTP 요청을 보내면, 이렇게 응답해준다'라는 스펙을 기능에 따라 설계해야 한다. API 설계 원칙은 웹 서버의 API스펙을 어떤 규칙에 따라 정의할 것인지를 나타낸다.</p>
<ul>
<li>'GET /post 는 게시글 목록을 불러오고, GET /poest/{id} 는 특정 게시글의 내용을 불러온다' 같은 설계는 다 아키텍처 기반으로 결정하는 것이 좋다. 아키텍처가 없다고 API 디자인을 못하는 것은 아니지만, 의사결정의 기반이 있는 것이 좋기 때문.</li>
<li>잘 디자인된 API는 불필요한 커뮤니케이션 비용을 줄인다.</li>
</ul>
<h4 id="종류"> 종류</h4>
<ul>
<li>HTTP API</li>
<li>REST API</li>
<li>GraphQL
HTTP API 선택 이유</li>
<li>REST API가 명시하는 모든 원칙을 만족하는 API를 작성하는 것은 쉽지않다. 결국은 '느슨한 REST' 느낌의 HTTP API가 되기 마련이다. 따라서 괜히 RESTful API 이러면서 깝치다가 정의구현 당하는 수가 있다. 제약조건을 따ㅓ르던지 다른 단어를 쓰도록 하자. REST의 self-descriptive와 HATEOAS 원칙은 만족하기 정말 어렵다.</li>
<li>REST는 HATEOAS(hypermedia as the engine of application state) 라는 원칙을 지켜야 하는데, 이는 '어플리케이션의 상태가 Hyperlink를 이용해 전이되어야 한다'라는 의미다. 우리는 API는 미디어 타입이 JSON일텐데, HATEOAS를 지키기 어렵다.</li>
<li>API가 꼭 REST API여야 할 필요가 없다.</li>
<li>GraphQL도 충분히 도전해볼만한것.</li>
<li><a href="https://slides.com/eungjun/rest#/" target="_blank" rel="noopener noreferrer">https://slides.com/eungjun/rest#/<i>Content not supported</i></a> 그런 REST API로 괜찮은가 참고</li>
<li></li>
</ul>
<h3 id="직렬화-포맷"> 직렬화 포맷</h3>
<p>직렬화 포맷에 대해 예를 들면, '게시글'을 나타내는 '제목'과 '내용' 데이터를 표현하기 위해 아래와 같은 방법들을 사용할 수 있다.</p>
<div><pre><code><span>{</span>
    <span>"title"</span><span>:</span> <span>"..."</span><span>,</span>
    <span>"content"</span><span>:</span> <span>"..."</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>syntax <span>=</span> <span>"proto3"</span><span>;</span>

message Post <span>{</span>
  required string title <span>=</span> <span>1</span><span>;</span>
  required string content <span>=</span> <span>2</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span><span><span>&lt;</span>title</span><span>></span></span><span>...</span><span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;</span>content</span><span>></span></span><span>...</span><span><span><span>&lt;/</span>content</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>title<span>:</span> <span>...</span>
content<span>:</span> <span>...</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>데이터를 어떤 방식으로 표현할 지를 결정해 두어야, 클라이언트와 서버 간의 데이터 교환에서 혼란을 줄일 수 있다.</p>
<p>예를 들어, Kotlin으로 이루어진 안드로이드 어플리케이션이 HashMap 객체를 문자열과 같이 특별한 형태로 가공해서 보내면, Node.js로 구성된 WAS가 이를 JavaScript 고유의 Object 타입으로 해석해 사용할 수 있어야 한다. 이를 위해 표준화된 직렬화 포맷이 여럿 존재하며, 그들 중 어떤 포맷을 사용할 것인지를 결정하도록 하자.</p>
<h4 id="종류-2"> 종류</h4>
<ul>
<li>XML</li>
<li>JSON</li>
<li>YAML</li>
<li><a href="https://developers.google.com/protocol-buffers/?hl=ko" target="_blank" rel="noopener noreferrer">Protocol buffer(Protobuf)<i>Content not supported</i></a></li>
</ul>
<h4 id="json"> JSON</h4>
<ul>
<li>비교적 더 잘 경량화되어 있고 가독성도 좋다.</li>
<li>YAML은 관례 상 직렬화 포맷으로 잘 사용하지 않고, 역직렬화 속도도 느리다.</li>
<li>Protobuf는 구글에서 개발한 data exchange format이다. 직렬화/역직렬화 속도가 빨라 성능상의 이점이 있고, .proto 파일을 정의하는 것만으로 validation rule들을 정리하고, 비교적 적은 노력으로 API 문서화에도 응요할 수 있으며, 클라이언트 단은 proto 컴파일을 통해 이들에 대응되는 클래스(DTO)들을 자동으로 정의 할 수 도 있어서 시도해볼 가치가 충분</li>
<li>JSON(JavaScript Object Notation)는 JavaScript나 TypeScript등 로직 처리를 하게 될 프로튼에게 JSON만큼 편한 구조가 없으며, 모바일 앱과 웹을 포함해 대부분 프론트엔드 엔지니어들은 이미 JSON에 익숙해져 있다.</li>
</ul>
<h4 id="참고"> 참고</h4>
<ul>
<li><a href="https://stackoverflow.com/questions/383692/what-is-json-and-what-is-it-used-for/383699#383699" target="_blank" rel="noopener noreferrer">Stackoverflow의 'What is JSON and why would I use it?<i>Content not supported</i></a></li>
<li><a href="https://www.json.org/json-en.html" target="_blank" rel="noopener noreferrer">json.org의 JSON 개요 문서<i>Content not supported</i></a></li>
</ul>
<br>
<h2 id="_1026-백엔드-기본-사용자-인증-방식-결정"> 1026 - [백엔드 기본]사용자 인증 방식 결정</h2>
<h3 id="사용자-인증-방식"> 사용자 인증 방식</h3>
<p>HTTP는 연결 지향 프로토콜인 TCP 기반임에도 불구하고, 대표적인 비연결 지향 프로토콜이다. 따라서 한 번의 요청-응답 사이클이 완료되면 연결을 종료하기 떄문에, 동일한 클라이언트가 요청을 아무리 많이 하더라도 프토콜은 이를 모두 독립적인 요청으로 인지한다. 이 떄문에 클라이언트는 매 HTTP 요청마다 본인이 누구인지를 인지시킬 수 있는 인증 정보(credential)를 요청의 어딘가에 포함시켜야 하며, 서버 또한 클라이언트의 자원 접근을 허용하기 전에 이러한 인증 정보를 기반으로 인증 과정을 일차적으로 거처야 한다. 사용자 A가 작성한 게시글을, 다른 사용자가 마음대로 수정/삭제 할 수 없게 만들어야 하기 때문이다.</p>
<h4 id="인증-정보의-위치"> 인증 정보의 위치</h4>
<ul>
<li>모든 형태의 HTTP 요청에 다 사용 가능해야 한다. 예를 들어, GET 요청에서 사용할 수 없으면 안된다.</li>
<li>HTTP 표준에 맞춰지면 더좋다.</li>
<li>클라이언트 사이드에서, 쉽게 저장하고 HTTP 요청 단에서 쉽게 데이터를 실어줄 수 있어야 한다.</li>
<li>request body, 요청의 query parameter, Cookie 헤더, Authorization 헤더</li>
</ul>
<p><strong>⇒ Authorization</strong></p>
<ul>
<li>인증 데이터는 메타데이터 성격이 강하다. request body와 어울리지 않는다.</li>
<li>request body를 사용할 수 없는 메소드가 있다. GET, HEAD, DELETE, TRACE가 그렇다.</li>
<li>url의 ? 뒤에 붙는 query parameter는 고려해볼만 하지만, 사용자 인증 하라고 Authorization 헤더가 표준화되어 있는데 굳이 query string을 써서 얻을 매트가 없다.</li>
<li>Cookie는 헤더를 사용한다는 점에서 Authorization과 비교해볼만 하다. 하지만 이것도 위에도 query parameter를 걸렀던 이유와 비슷하게, 인증이라는 맥락은 Authorization이 더 어울린다.</li>
<li>모바일 클라이언트들이 쿠키 기반의 인증을 기피 → cookie store를 별도로 구현</li>
</ul>
<p><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Authorization" target="_blank" rel="noopener noreferrer">MDN의 Authorization 헤더 문서<i>Content not supported</i></a></p>
<h4 id="인증-스키마"> 인증 스키마</h4>
<p>이제 사용자가 로그인을 했을 때, 서버는 그 사용자를 나타내는 특별한 값을 만들어서 전달해 권한을 부여하고, 사용자는 나중에 Authorization 헤더로 그 인증 데이터를 보내준다는 것까지 결정이 되었다. '사용자를 나타내는 값'을 어떻게 만들어낼 지는 표준이 결정. Authorization 헤더에는 값에 대한 표준도 있다.</p>
<p>Authorization 헤더의 value는 <code>&lt;type&gt; &lt;credentials&gt;</code>처럼 표준이 있다. <code>Bearer xmp98-cb35.potn6jz.zorj15gmb-</code>이 한가지 예다 . 인증 타입에 따라 credential을 만들어내는 방식이 정해져 있기 때문에 맘대로 할 수 있는 부분이 아니며, 표준을 따르지 않더라도 이유는 있어야 한다. 그러니 인증 스키마에 대한 선택이 필요하다.</p>
<ul>
<li>표준을 따르지 않아도 괜찮지만, 충분한 이유와 대안이 있어야 한다.</li>
<li>추후 확장 가능성을 위해 토큰 기반 인증 시스템이면 좋다. <a href="https://velopert.com/2350" target="_blank" rel="noopener noreferrer">토큰 기반 인증에 대한 소개<i>Content not supported</i></a></li>
<li>충분히 암호화된 상태로 주고받을 수 있거나, 비밀번호와 같이 critical한 데이터를 값 내부에 포함시키지 않는 방식이어야 한다.</li>
</ul>
<p>표준상 Authorization 헤더의 값에는 RFC에 의해 표준화된 인증 스키마를 사용할 수 있게 되어 있다.</p>
<p><strong>종류</strong></p>
<ul>
<li>Basic</li>
<li>[비표준] OAuth 1.0a를 사용하는 Bearer</li>
<li>OAuth 2.0을 사용하는 Bearer</li>
<li>[비표준] JWT, 또는 JWT를 사용하는 Bearer</li>
<li>Digest</li>
<li>HOBA</li>
</ul>
<p><strong>⇒ JWT를 사용하는 Bearer</strong></p>
<ul>
<li>Basic은 ID와 비밀번호를 base64 인코딩하는 방식이다. base64는 별도의 key 없이도 복호화가 가능한 인코딩이므로, 안전하지 않다,</li>
<li>OAuth 1.0는 Bearer 인증 표준이 아니다.</li>
<li>Bearer에서 사용하는 OAuth 2.0 방식의 인증은 확장성이 매우 높다. 'Facebook 계정으로 로그인'과 같은 기능이 OAuth로 구현되었다. 되도록 이런 흐름에 낄 수 있다면 좋겠지만, OAuth 2.0은 자체 암호화를 지원하지 않기 때문에 HTTPS를 쓰는 것을 권고하고 있고, 돈이 들어가야 하는 부분이다. 인증정책은 나중에 HTTPS관련 비용 문제를 해결하고 나서 변경해도 괜찮을 것 같다는 판단. 또한, 스펙자체에서 명확하게 정의하지 않는 부분이 꽤 있어서 그만큼 고민이 깊어진다고 한다.</li>
<li>Bearer에 JWT를 사용하거나, JWT라는 타입을 쓰는 것도 표준이 아니다. 그러나 HTTPS 문제로 OAuth 2.0을 보류하게 되니, 대신 쓸 토큰 기반 인증 시스템으로 JWT가 가장 쓸만하다.</li>
<li>'보호된 리소스에 대한 접근 권한을 부여받기 위해 제시하는 유일한 작업이 토큰을 전달하는 것 뿐' 일 때, 이 토큰을 bearer token이라고 부를 수 있다. 따라서 JWT를 사용하는 인증 방식도 사실상 bearer라는 문맥에서 벗어나지 않으며, 단지 bearer token을 생성하기 위해 OAuth 2.0 관련 사양을 사용하지 않는 것 뿐. Authorization 헤더를 사용하고, 디지털 방식으로 서명(sign)된 토큰을 사용한다면, 이정도 사이즈의 프로젝트에서는 비용을 들이면서까지 OAuth 2.0을 완전히 수행하려 하지 않아도 된다고 생각.</li>
<li>JWT는 사용 사례가 많고, 거인의 어깨(잘 만들어진 라이브러리, 예제 등)가 잘 준비되어 있다.</li>
</ul>
<p><a href="https://velopert.com/2389" target="_blank" rel="noopener noreferrer">JSON Web Token 소개 및 구조<i>Content not supported</i></a></p>
<br>
<h2 id="_1027-백엔드-기본-api-스펙-설계와-문서화-방식-결정"> 1027 - [백엔드 기본]API 스펙 설계와 문서화 방식 결정</h2>
<ul>
<li>HTTP API 설계 원칙을 기반으로 API 스펙을 디자인</li>
<li>JSON을 직렬화 포맷으로 결정</li>
<li>Authorization 헤더로 인증 정보를 명시</li>
<li>인증 스키마에 JWT 기반의 Bearer를 사용하기로 했다.</li>
</ul>
<h3 id="api-스펙-설계"> API 스펙 설계</h3>
<p><strong>스펙설계 필요성</strong></p>
<ul>
<li>
<p>개발에 착수하기 전에 구조에 대한 고민할 시간이 생긴다.</p>
</li>
<li>
<p>프론트엔드 개발자와의 소통을 위해 API스펙을 문서화 해야한다.</p>
</li>
<li>
<p>실제로 로직을 작성하기 전에 스펙을 리뷰하는 단계가 생기고, 아직 코드를 작성하지 않았으니 변경사항을 빠르게 반영할 수 있다.</p>
</li>
<li>
<p>문서를 착실하게 작성해 두면, 커뮤니케이션으로 낭비하는 시간이 줄어든다.</p>
</li>
<li>
<p>예제</p>
</li>
</ul>
<div><pre><code><span>// 엔드 포인트 = HTTP method + URI</span>
<span>GET</span> <span>/</span>user<span>/</span>account<span>/</span>check<span>-</span>duplicate<span>/</span>id<span>/</span><span>{</span>id<span>}</span> <span>:</span> <span>ID</span> 중복체크 <span>API</span>
<span>POST</span> <span>/</span>user<span>/</span>account<span>/</span>signup <span>:</span> 회원가입 <span>API</span><span>.</span> <span>ID</span><span>/</span>비밀번호<span>/</span>닉네임을 받는다<span>.</span>
<span>POST</span> <span>/</span>user<span>/</span>account<span>/</span>auth <span>:</span> 로그인 <span>API</span><span>.</span> <span>JWT</span> 포맷으로 인코딩된 access token과 refresh token을 발급한다<span>.</span>
<span>GET</span> <span>/</span>user<span>/</span>account<span>/</span>refresh <span>:</span> access token refresh <span>API</span><span>.</span> refresh token의 expire가 얼마 남지 않았다면 refresh token도 새로 만들어서 발급해 준다<span>.</span>
<span>POST</span> <span>/</span>board<span>/</span>categories <span>:</span> 카테고리 생성 <span>API</span>
<span>GET</span> <span>/</span>board<span>/</span>categories <span>:</span> 카테고리 목록 <span>API</span>
<span>POST</span> <span>/</span>board<span>/</span>posts <span>:</span> 게시글 작성 <span>API</span>
<span>GET</span> <span>/</span>board<span>/</span>posts <span>:</span> 게시글 목록 <span>API</span><span>.</span> category <span>ID</span>를 요청으로 optional하게 받아서<span>,</span> 카테고리별 필터링도 가능하게 할 생각이다<span>.</span>
<span>GET</span> <span>/</span>board<span>/</span>posts<span>/</span><span>{</span>post_id<span>}</span> <span>:</span> 게시글 내용 <span>API</span>
<span>PATCH</span> <span>/</span>board<span>/</span>posts<span>/</span><span>{</span>post_id<span>}</span> <span>:</span> 게시글 수정 <span>API</span>
<span>DELETE</span> <span>/</span>board<span>/</span>posts<span>/</span><span>{</span>post_id<span>}</span> <span>:</span> 게시글 삭제 <span>API</span>
<span>GET</span> <span>/</span>board<span>/</span>posts<span>/</span><span>{</span>post_id<span>}</span><span>/</span>comments <span>:</span> 게시글의 댓글 목록 <span>API</span>
<span>POST</span> <span>/</span>board<span>/</span>posts<span>/</span><span>{</span>post_id<span>}</span><span>/</span>comments <span>:</span> 댓글 작성 <span>API</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="http-api-설계-원칙"> HTTP API 설계 원칙</h3>
<p>일반적인 프로젝트라면 기획서, 기본적인 와이어프레임, UI처럼 기능 명세를 살펴볼 수 있을만한 산출물이 나오고 난 상태여야 한다. 상황이나 여건이 되지 않을 시, 필요할만한 기능들을 떠올려서 설계해보도록 한다. HTTP API 설계 원칙에 따라 진행할텐데, 표준은 정해져있지 않고 조직마다 설계 원칙이 다르다. 따라서 <a href="https://github.com/interagent/http-api-design" target="_blank" rel="noopener noreferrer">Heroku 플랫폼 API를 개발한 조직이 정리한 디자인 가이드<i>Content not supported</i></a> (<a href="https://github.com/yoondo/http-api-design/tree/master/ko" target="_blank" rel="noopener noreferrer">한국어 버전<i>Content not supported</i></a>)를 참고한다.</p>
<h3 id="api-문서화-방식"> API 문서화 방식</h3>
<p>HTTP API의 문서화 방식을 표준화시키기 위해, yaml 파일로 작성하는 형태의 <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/examples/v3.0/petstore.yaml" target="_blank" rel="noopener noreferrer">OpenAPI<i>Content not supported</i></a>라는 스펙이 존재하며 거의 모든 API 문서화 도구들은 이런 OpenAPI 스펙에 대응되어 있다. 따라서, OpenAPI 스펙에 따라 작성한 API 문서를 시각해줄 도구를 선택해야 한다. 간소화된 문법으로 작성한 문서를 OpenAPI 포맷으로 convert해주는 도구라면 더 좋고, 또는 OpenAPI 신경 안쓰고 GUI 방식으로 문서를 작성하는 자체적인 문서화 서비스일 수도 있다.</p>
<h4 id="선택조건"> 선택조건</h4>
<ul>
<li>변경을 추적하기 쉬워야(버전 관리가 가능해야)한다. Git으로 관리할 수 있는 것이라면 좋다.</li>
<li>문서를 작성하는 일이 고통스럽지 않아야 한다. raw한 OpenAPI 3.0 spec은 유지보수하기 정말 쉽지 않다.</li>
<li>UI가 예뻐야 한다.</li>
<li>Private로 관리할 수 있어야 한다.</li>
</ul>
<h4 id="선택지"> 선택지</h4>
<ul>
<li>Excel</li>
<li><a href="https://swagger.io/tools/swaggerhub/" target="_blank" rel="noopener noreferrer">SwaggerHub<i>Content not supported</i></a>(<a href="https://app.swaggerhub.com/apis/singlasarvesh/demo/1.0.0#/" target="_blank" rel="noopener noreferrer">Example<i>Content not supported</i></a>)</li>
<li>소스코드에 문서 임베딩</li>
<li><a href="https://github.com/Rebilly/ReDoc" target="_blank" rel="noopener noreferrer">ReDoc<i>Content not supported</i></a>을 직접 관리</li>
<li>ReDoc을 GitHub Pages(github.io)에서 관리(<a href="http://rebilly.github.io/ReDoc/" target="_blank" rel="noopener noreferrer">Example<i>Content not supported</i></a>)</li>
<li><a href="https://github.com/lord/slate" target="_blank" rel="noopener noreferrer">Slate<i>Content not supported</i></a>를 직접 관리</li>
<li>Slate를 GitHub Pages(github.io)에서 관리(<a href="https://lord.github.io/slate" target="_blank" rel="noopener noreferrer">Example<i>Content not supported</i></a>)</li>
<li><a href="https://www.gitbook.com/?t=1" target="_blank" rel="noopener noreferrer">GitBook<i>Content not supported</i></a></li>
<li>Spring REST Docs</li>
</ul>
<h4 id="장단점"> 장단점</h4>
<ul>
<li>SwaggerHub는 <strong>OpenAPI 스펙 그대로 문서를 정의</strong>해야 한다. 따라서 모든 API를 한 페이지(파일)에서 관리해야 하는데, API 한 대여섯개만 넣어도 가볍게 1000줄이 넘어가서 관리가 힘들다.</li>
<li>소스코드에 임베딩하는 방식은, 라이브러리 단에서 <strong>HTML+CSS 리소스 + 소스코드에서 추출한 문서 정보</strong>를 가지고 있다가 <code>/docs</code> 같은 uri에서 문서를 웹으로 서빙하는 형태다. 유명한 것으로는 Flask 기반의 <a href="https://github.com/rochacbruno/flasgger" target="_blank" rel="noopener noreferrer">flasgger<i>Content not supported</i></a>가 있다. <strong>소스코드에 문서가 포함</strong>되어 있으니, 리뷰 과정에서 <strong>API 스펙이 변경되었을 때 이를 문서에도 반영했는지</strong> 볼 수 있어서 좋고 대부분 <strong>API 각각에 문서가 주입</strong>되는 형태라서 가독성도 괜찮다. 그러나 API 문서의 수정이 필요할 때마다 <strong>어플리케이션 전체를 다시 빌드하고 배포</strong>해야 해서 리스크가 크다. 따로 분리하는 것이 좋겠다고 생각했다.</li>
<li>ReDoc과 Slate는 OpenAPI 스펙에 맞춰진 문서를 조금 더 간소화된 문법으로 작성할 수 있어서 좋은데, 직접 관리하는 경우 조금 귀찮다. Amazon S3 website같이 <strong>스토리지 서비스에서 정적 웹사이트를 호스팅</strong>하는 형태로 관리하게 될텐데, 변경을 자동으로 배포하기 위해 <strong>배포 자동화</strong>를 설정해야 할테고, API가 외부로 공개되어야 한다면 <strong>status check</strong>도 붙어야 하고, 상황에 따라 ReDoc이나 Slate에서 제공하는 <strong>React App을 커스텀</strong>하기도 해야 한다. 관리 포인트가 늘어나기 때문에 보류.</li>
<li>관리 포인트가 감당 가능하다 하더라도, ReDoc과 Slate가 간소화한 문법을 쓰는 것이 사실 경험 상 <strong>문서를 작성하는 데에 생산성이 그렇게 비교될 정도로 좋지는 않았고 썩 즐겁지도 않았다.</strong></li>
<li>관리 포인트를 줄인답시고 ReDoc과 Slate를 GitHub Pages에 올리는 경우, <strong>문서를 private로 관리할 수 없다.</strong></li>
<li>GitBook은 <strong>문서 작성에 대한 스트레스가 비교적 적다.</strong> GUI로 작성하기 때문. 내부적으로 OpenAPI 스펙으로 관리하고 있지는 않고 그냥 자체적인 API 문서화 툴이다. 과거에도 여기저기서 GUI 기반의 API 문서화 플랫폼을 개발하고자 하는 시도가 많았지만 조잡했어서 안 썼는데, 최근에 들어가 본 GitBook은 괜찮았던 것 같다.</li>
</ul>
<p>OpenAPI에는 <code>$ref</code>라는 문법으로 중복을 관리할 수 있어서 좋은데, GitBook은 그렇지 않다. 하지만 편히 문서를 작성할 수 있으니 트레이드오프 한다고 생각하자.
<strong>⇒ 최근엔 Spring REST Docs로 관리한다.</strong></p>
<br>
<h2 id="_1030-제네릭"> 1030 - 제네릭</h2>
<blockquote>
<p>제네릭(Generic)은 직연하면 '일반적인'이라는 뜻이다. 자세히 설명하면 '데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있또록 하는 방법'이다.</p>
</blockquote>
<p>자바에서 제네릭(Generic)은 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것을 의미한다. 한마디로 특정(Specific) 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반(Generic) 타입이라는 것이다.<br>
(정확히 말하자면 지정된다는 것 보다는 타입의 경계를 지정하고, 컴파일 떄 해당 타입으로 캐스팅하여 매개변수화 된 유형을 삭제하는 것이다.)</p>
<h3 id="제네릭의-장점"> 제네릭의 장점</h3>
<ul>
<li>제네릭을 사용하면 잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다.</li>
<li>클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다. 즉, 관리하기가 편하다.</li>
<li>비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다.</li>
</ul>
<h3 id="제네릭-사용방법"> 제네릭 사용방법</h3>
<ul>
<li>예제</li>
</ul>
<div><pre><code><span>class</span> <span>MyArray</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>T</span> element<span>;</span>

    <span>void</span> <span>setElement</span><span>(</span><span>T</span> element<span>)</span> <span>{</span> <span>this</span><span>.</span>element <span>=</span> element<span>;</span> <span>}</span>

    <span>T</span> <span>getElement</span><span>(</span><span>)</span> <span>{</span> <span>return</span> element<span>;</span> <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>위의 예제에서 사용된 'T'를 타입 변수(type variable)라고 하며, 임의의 참조형 타입을 의미한다. 꼭 'T'뿐만 아니라 어떠한 문자를 사용해도 상관없으며, 여러 개의 타입 변수는 쉼표(,)로 구분하여 명시할 수 있다. 타입 변수는 클래스에서뿐만 아니라 메소드의 매개변수나 반환값으로도 사용할 수 있다.</p>
<ul>
<li>위와 같이 선언된 제네릭 클래스를 생성할 때에는 타입 변수자리에 사용할 실제 타입을 명시해야 한다.</li>
</ul>
<div><pre><code><span>MyArray</span><span><span>&lt;</span><span>Integer</span><span>></span></span> myArr <span>=</span> <span>new</span> <span>MyArray</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>위처럼 제네릭 클래스를 생성할 때 사용할 실제 타입을 명시하면, 내부적으로는 정의된 타입 변수가 명시된 실제 타입으로 변환되어 처리된다.</p>
<ul>
<li>또한, 자바7부터 인스턴스 생성 시 타입을 추정할 수 있는 경우에는 타입을 생략할 수 있다.</li>
</ul>
<div><pre><code><span>MyArray</span><span><span>&lt;</span><span>Integer</span><span>></span></span> myArr <span>=</span> <span>new</span> <span>MyArray</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// Java SE 7부터 가능함.</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>제네릭에서 적용되는 타입 변수의 다형성을 보여주는 예</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>*</span><span>;</span>

<span>class</span> <span>LandAnimal</span> <span>{</span> <span>public</span> <span>void</span> <span>crying</span><span>(</span><span>)</span> <span>{</span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"육지동물"</span><span>)</span><span>;</span> <span>}</span> <span>}</span>
<span>class</span> <span>Cat</span> <span>extends</span> <span>LandAnimal</span> <span>{</span> <span>public</span> <span>void</span> <span>crying</span><span>(</span><span>)</span> <span>{</span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"냐옹냐옹"</span><span>)</span><span>;</span> <span>}</span> <span>}</span>
<span>class</span> <span>Dog</span> <span>extends</span> <span>LandAnimal</span> <span>{</span> <span>public</span> <span>void</span> <span>crying</span><span>(</span><span>)</span> <span>{</span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"멍멍"</span><span>)</span><span>;</span> <span>}</span> <span>}</span>
<span>class</span> <span>Sparrow</span> <span>{</span> <span>public</span> <span>void</span> <span>crying</span><span>(</span><span>)</span> <span>{</span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"짹짹"</span><span>)</span><span>;</span> <span>}</span> <span>}</span>

 
<span>class</span> <span>AnimalList</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>

    <span>ArrayList</span><span><span>&lt;</span><span>T</span><span>></span></span> al <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>T</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>add</span><span>(</span><span>T</span> animal<span>)</span> <span>{</span> al<span>.</span><span>add</span><span>(</span>animal<span>)</span><span>;</span> <span>}</span>

    <span>T</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span> <span>return</span> al<span>.</span><span>get</span><span>(</span>index<span>)</span><span>;</span> <span>}</span>

    <span>boolean</span> <span>remove</span><span>(</span><span>T</span> animal<span>)</span> <span>{</span> <span>return</span> al<span>.</span><span>remove</span><span>(</span>animal<span>)</span><span>;</span> <span>}</span>

    <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span> <span>return</span> al<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> <span>}</span>
<span>}</span>

 

<span>public</span> <span>class</span> <span>Generic01</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>

        <span>AnimalList</span><span><span>&lt;</span><span>LandAnimal</span><span>></span></span> landAnimal <span>=</span> <span>new</span> <span>AnimalList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span> <span>// Java SE 7부터 생략가능함.</span>

        landAnimal<span>.</span><span>add</span><span>(</span><span>new</span> <span>LandAnimal</span><span>(</span><span>)</span><span>)</span><span>;</span>

        landAnimal<span>.</span><span>add</span><span>(</span><span>new</span> <span>Cat</span><span>(</span><span>)</span><span>)</span><span>;</span>

        landAnimal<span>.</span><span>add</span><span>(</span><span>new</span> <span>Dog</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>// landAnimal.add(new Sparrow()); // 오류가 발생함.</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> landAnimal<span>.</span><span>size</span><span>(</span><span>)</span> <span>;</span> i<span>++</span><span>)</span> <span>{</span>
            landAnimal<span>.</span><span>get</span><span>(</span>i<span>)</span><span>.</span><span>crying</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
<span>}</span>

<span>// 육지동물</span>
<span>// 냐옹냐옹</span>
<span>// 멍멍</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>위의 예제에서 Cat과 Dog 클래스는 LandAnimal 클래스를 상속받는 자식 클래스이므로, AnimalList<LandAnimal>에 추가할 수 있다.
하지만 Sparrow 클래스는 타입이 다르므로 추가할 수 없다.</p>
<h3 id="제네릭의-제거-시기"> 제네릭의 제거 시기</h3>
<p>자바 코드에서 선언되고 사용된 제네릭 타입은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환되고, 코드 내의 모든 제네릭 타입은 제거되어, 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함되지 않게 된다. 이런 식으로 동작하는 이유는 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위해서 이다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>1101 - 1107</title>
      <link>ahnjs/TIL/2021/1101/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1101/</guid>
      <source url="ahnjs/TIL/rss.xml">1101 - 1107</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1101-1107"> 1101 - 1107</h1>
<h2 id="_1101-http-api와-rest-api"> 1101 - HTTP API와 REST API</h2>
<p>HTTP API와 REST API는 사실 거의 같은 의미로 사용된다.<br>
하지만 디테일하게 들어가면 차이가 있다.</p>
<ul>
<li>HTTP API는 HTTP를 사용해서 서로 정해둔 스펙으로 데이터를 주고 받으면 통신하는 것, 상당히 넓은 의미로 사용</li>
<li>반면, REST API는 HTTP API에 여러가지 제약 조건이 추가된다.
<ul>
<li>자원의 식별</li>
<li>메세지를 통한 리소스 조작</li>
<li>자기서술적 메세지</li>
<li>애플리케이션의 상태에 대한 엔진으로서 하이퍼미디어</li>
</ul>
</li>
</ul>
<p>여러가지가 있지만 대표적으로 구현하기 어려운 부분이 마지막 부분이다. 이것은 HTML처럼 하이퍼링크가 추가되어서 다음에 어떤 API를 호출해야 하는지를 해당 링크를 통해서 받을 수 있어야 한다.</p>
<p>그리고 이런 부분을 완변하게 지키면서 개발하는 것을 <code>RESTful API</code>라고 한다. 실무에서 이런 방법으로 갭라하는 것은 현실적으로 어렵고, 또 추가 개발 비용대비 효과가 부족하다.</p>
<p>그런데 이미 많은 사람들이 해당 조건을 지키지 않아도 REST API라고 하기 때문에, HTTP API나 REST API를 거의 같은 의미로 사용하고 있다. 하지만 앞서 이야기한 것 처럼 엄격하게 위의 내용들을 모두 지켜야 RESTful한 API라고 할 수 있다.</p>
<br>
<h2 id="_1102-자바-var-키워드"> 1102 - 자바 var 키워드</h2>
<p>Java 10에서 도입된 var는 변수를 선언할 때 타입을 생략할 수 있으며, 컴파일러가 타입을 추론한다.</p>
<p>다음과 같이 변수를 선언하면 컴파일러가 String 타입을 추론하여 번수에 타입을 지정해 준다. Kotlin과 같이 타입 출론을 지원하는 언어와 같이 지원한다.</p>
<div><pre><code><span>var</span> string <span>=</span> <span>"Hello, World"</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>컴파일 타임에 추론하는 것이기 때문에, Runtime에 추가 연산을 하지 않아 성능에 영향을 주지는 않는다.</li>
<li>Java에서 var는 지역 변수에서만 사용할 수 있따. 또한 컴파일러가 타입을 추론할 수 없는 애매한 상황일 때 컴파일 에러가 발생한다.</li>
</ul>
<h3 id="var로-변수-선언"> var로 변수 선언</h3>
<ul>
<li>Java 9이하</li>
</ul>
<div><pre><code><span>String</span> str <span>=</span> <span>"Hello, World"</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>Java 10</li>
</ul>
<div><pre><code><span>var</span> str <span>=</span> <span>"Hello, World"</span><span>;</span>

<span>if</span><span>(</span>str <span>instanceof</span> <span>String</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"This is a String : "</span> <span>+</span> str<span>)</span><span>;</span>
<span>}</span>

<span>// This is a String : Hello, World</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>다른 클래스들도 var로 변수를 선언할 수 있다.</p>
<div><pre><code><span>var</span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>if</span> <span>(</span>list <span>instanceof</span> <span>ArrayList</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"This is a ArrayList"</span><span>)</span><span>;</span>
<span>}</span>

<span>// This is a ArrayList</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>여기서 list는 ArrayList<String>타입으로 선언되며, var list = new ArrayList();로 선언하면 타입은 ArrayList<Object>가 된다.</p>
<h4 id="반복문에서-사용"> 반복문에서 사용</h4>
<div><pre><code><span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>

<span>for</span> <span>(</span><span>var</span> n <span>:</span> arr<span>)</span> <span>{</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"n : "</span> <span>+</span> n<span>)</span><span>;</span>
<span>}</span>

<span>// n : 1</span>
<span>// n : 2</span>
<span>// n : 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="제약-사항"> 제약 사항</h3>
<ul>
<li>지역 변수에서만 사용</li>
<li>초기화 필요</li>
<li>null로 초기화할 수 없음</li>
<li>배열에 사용할 수 없음</li>
<li>Lambda에 사용할 수 없음</li>
</ul>
<br>
<h2 id="_1103-bigdecimal"> 1103 - BigDecimal</h2>
<p>자바는 <code>IEEE 754</code> 부동 소수점 방식을 사용하기 떄문에<br>
정확한 실수를 저장하지 않고 최대한 완벽에 가깝기를 바라는 근사치 값을 저장한다.</p>
<p>따라서 금융권에서 달러를 다루는 개발자가 double을 이용한다면 문제가 발생할 수 있다.</p>
<p>이러한 문제를 해결하기위해 부동 소숫점 방식이 아닌, 정수를 이용해 실수를 표현하는 <code>java.math.BigDecimal</code>클래스를 사용한다.</p>
<h3 id="bigdecimal이란"> BigDecimal이란?</h3>
<ul>
<li>BigDecimal은 Java 언어에서 숫자를 정밀하게 저장하고 표현할 수 있는 유일한 방법이다.</li>
<li>소수점을 저장할 수 있는 가장 크기가 큰 타입인 double은 소수점의 정밀도에 한계까 있어 값이 유실될 수 있다.</li>
<li>Java 언어에서 돈과 소수점을 다룬다면 BigDecimal은 선택이 아니라 필수이다.</li>
<li>BigDecimal의 유일한 단점은 느린 속도와 기본 타입보다 조금 불편한 사용법 이다.</li>
</ul>
<h3 id="double-무엇이-문제인가"> double, 무엇이 문제인가?</h3>
<ul>
<li>소수점 이하의 수를 다룰 때 double 타입은 사칙연산시 기대 값과 다른 값을 출력한다. 이유는 double 타입이 내부적으로 수를 저장할 때 이진수의 근사치를 저장하기 때문이다. 저장된 수를 다시 십진수로 표현하면서 아래와 같은 문제가 발생한다. BigDecimal 타입은 내부적으로 수를 십진수로 저장하여 아주 작은 수와 큰 수의 연산에 대해 거의 무한한 정밀도를 보장한다.</li>
</ul>
<div><pre><code><span>double</span> a <span>=</span> <span>10.0000</span><span>;</span>
<span>double</span> b <span>=</span> <span>3.0000</span><span>;</span>

<span>// 기대값: 13</span>
<span>// 실제값: 13.000001999999999</span>
a <span>+</span> b<span>;</span>

<span>// 기대값: 7</span>
<span>// 실제값: 6.999999999999999</span>
a <span>-</span> b<span>;</span>

<span>// 기대값: 30</span>
<span>// 실제값: 30.000013000000997</span>
a <span>*</span> b<span>;</span>

<span>// 기대값: 3.33333...</span>
<span>// 실제값: 3.333332555555814</span>
a <span>/</span> b<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="bigdecimal-사용"> BigDecimal 사용</h3>
<h4 id="bigdecimal-기본-용어"> BigDecimal 기본 용어</h4>
<ul>
<li>precision : 숫자를 구성하는 전체 자리수라고 생각하면 편하나, 정확하게 풀이하면 왼쪽부터 0이 아닌 수가 시작하는 위치부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 자리수이다. unscale과 동의어이다. (ex: 012345.67890의 precision은 11이 아닌9이다.)</li>
<li>scale : 전체 소수점 자리수라고 생각하면 편하나, 정확하게 풀이하면 소수점 첫쨰 자리부터 오른쪽부터 0이 아닌 수로 끝나는 위치까지의 총 소수점 자리수이다. fraction과 동의어이다. (ex: 012345.67890의 scale은 4이다. 하지만 0.00, 0.0의 scale은 모두 1이다.) BigDecimal은 32bit의 소수점 크기를 가진다.</li>
<li>DECIMAL128: IEEE 754-2008에 의해 표준화된, 부호와 소수점을 수용하며, 최대 34자리까지 표현 가능한 10진수를 저장할 수 있는 형식이다. 2018년 미국 정부의 총 부채액이 15조 7천 500억 달러로 총 14자리 임을 감안하면, 금융권에서 처리되는 대부분의 금액을 수용할 수 있는 크기이다. Java에서는 BigDecimal 타입을 통해 공식적으로 지원한다.</li>
</ul>
<h4 id="bigdecimal-기본-상수"> BigDecimal 기본 상수</h4>
<ul>
<li>float, double 타입과 다르게 BigDecimal 타입은 초기화가 장황한 편이다. 그래서, 자주 쓰는 0, 1, 100은 쓰기 편하게 미리 상수로 정의되어 있다.</li>
</ul>
<div><pre><code><span>// 흔히 쓰이는 값은 상수로 정의</span>
<span>// 0</span>
<span>BigDecimal</span><span>.</span>ZERO

<span>// 1</span>
<span>BigDecimal</span><span>.</span>ONE

<span>// 10</span>
<span>BigDecimal</span><span>.</span>TEN
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="bigdecimal-초기화"> BigDecimal 초기화</h4>
<ul>
<li>double 타입으로 부터 BigDecimal 타입을 초기화하는 방법으로 가장 안전한 것은 문자열의 형태로 생성자에 전달하여 초기화 하는 것이다. double 타입의 값을 그대로 전달할 경우 앞서 사칙연산 결과에서 본 것과 같이 이진수의 근사치를 가지게 되어 예상과 다른 값을 얻을 수 있다.</li>
</ul>
<div><pre><code><span>// double 타입을 그대로 초기화하면 기대값과 다른 값을 가진다.</span>
<span>// 0.01000000000000000020816681711721685132943093776702880859375</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>0.01</span><span>)</span><span>;</span>

<span>// 문자열로 초기화하면 정상 인식</span>
<span>// 0.01</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"0.01"</span><span>)</span><span>;</span>

<span>// 위와 동일한 결과, double#toString을 이용하여 문자열로 초기화</span>
<span>// 0.01</span>
<span>BigDecimal</span><span>.</span><span>valueOf</span><span>(</span><span>0.01</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="bigdecimal-비교-연산"> BigDecimal 비교 연산</h4>
<ul>
<li>BigDecimal은 기본 타입이 아닌 오브젝트이기 때문에 특히, 동등 비교 연산을 유의해야 한다. double 타입을 사용하던 습관대로 무의식적으로 == 기호를 사용하면 예기치 않은 연산 결과를 초래할 수 있다.</li>
</ul>
<div><pre><code><span>BigDecimal</span> a <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"2.01"</span><span>)</span><span>;</span>
<span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"2.010"</span><span>)</span><span>;</span>

<span>// 객체의 레퍼런스 주소에 대한 비교 연산자로 무의식적으로 값의 비교를 위해 사용하면 오동작</span>
<span>// false</span>
a <span>==</span> b<span>;</span>

<span>// 값의 비교를 위해 사용, 소수점 맨 끝의 0까지 완전히 값이 동일해야 true 반환</span>
<span>// false</span>
a<span>.</span><span>equals</span><span>(</span>b<span>)</span><span>;</span>

<span>// 값의 비교를 위해 사용, 소수점 맨 끝의 0을 무시하고 값이 동일하면 0, 적으면 -1, 많으면 1을 반환</span>
<span>// 0</span>
a<span>.</span><span>compareTo</span><span>(</span>b<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="bigdecimal-사칙-연산"> BigDecimal 사칙 연산</h4>
<ul>
<li>Java에서 BigDecimal 타입의 사칙 연산 방법은 아래와 같다. 보다시피 double 타입보다 장황하고 귀찮은 편이다.</li>
</ul>
<div><pre><code><span>BigDecimal</span> a <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"10"</span><span>)</span><span>;</span>
<span>BigDecimal</span> b <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"3"</span><span>)</span><span>;</span>

<span>// 더하기</span>
<span>// 13</span>
a<span>.</span><span>add</span><span>(</span>b<span>)</span><span>;</span>

<span>// 빼기</span>
<span>// 7</span>
a<span>.</span><span>subtract</span><span>(</span>b<span>)</span><span>;</span>

<span>// 곱하기</span>
<span>// 30</span>
a<span>.</span><span>multiply</span><span>(</span>b<span>)</span><span>;</span>

<span>// 나누기</span>
<span>// 3.333333...</span>
<span>// java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</span>
a<span>.</span><span>divide</span><span>(</span>b<span>)</span><span>;</span>

<span>// 나누기</span>
<span>// 3.333</span>
a<span>.</span><span>divide</span><span>(</span>b<span>,</span> <span>3</span><span>,</span> <span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>

<span>// 나누기 후 나머지</span>
<span>// 전체 자리수를 34개로 제한</span>
<span>// 1</span>
a<span>.</span><span>remainder</span><span>(</span>b<span>,</span> <span>MathContext</span><span>.</span>DECIMAL128<span>)</span><span>;</span>

<span>// 절대값</span>
<span>// 3</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"-3"</span><span>)</span><span>.</span><span>abs</span><span>(</span><span>)</span><span>;</span>

<span>// 두 수 중 최소값</span>
<span>// 3</span>
a<span>.</span><span>min</span><span>(</span>b<span>)</span><span>;</span>

<span>// 두 수 중 최대값</span>
<span>// 10</span>
a<span>.</span><span>max</span><span>(</span>b<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h4 id="bigdecimal-소수점-처리"> BigDecimal 소수점 처리</h4>
<ul>
<li>RoundingMode.HALF_EVEN은 Java의 기본 반올림 정책으로 금융권에서 사용하는 Bankers Rounding와 동일한 알고리즘이다. 금융권에서는 시스템 개발시 혼란을 막기 위해 요구사항에 반올림 정책을 명확히 명시하여 개발한다.</li>
</ul>
<div><pre><code><span>// 소수점 이하를 절사한다.</span>
<span>// 1</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"1.1234567890"</span><span>)</span><span>.</span><span>setScale</span><span>(</span><span>0</span><span>,</span> <span>RoundingMode</span><span>.</span>FLOOR<span>)</span><span>;</span>

<span>// 소수점 이하를 절사하고 1을 증가시킨다.</span>
<span>// 2</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"1.1234567890"</span><span>)</span><span>.</span><span>setScale</span><span>(</span><span>0</span><span>,</span> <span>RoundingMode</span><span>.</span>CEILING<span>)</span><span>;</span>
<span>// 음수에서는 소수점 이하만 절사한다.</span>
<span>// -1</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"-1.1234567890"</span><span>)</span><span>.</span><span>setScale</span><span>(</span><span>0</span><span>,</span> <span>RoundingMode</span><span>.</span>CEILING<span>)</span><span>;</span>

<span>// 소수점 자리수에서 오른쪽의 0 부분을 제거한 값을 반환한다.</span>
<span>// 0.9999</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"0.99990"</span><span>)</span><span>.</span><span>stripTrailingZeros</span><span>(</span><span>)</span><span>;</span>

<span>// 소수점 자리수를 재정의한다.</span>
<span>// 원래 소수점 자리수보다 작은 자리수의 소수점을 설정하면 예외가 발생한다.</span>
<span>// java.lang.ArithmeticException: Rounding necessary</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"0.1234"</span><span>)</span><span>.</span><span>setScale</span><span>(</span><span>3</span><span>)</span><span>;</span>

<span>// 반올림 정책을 명시하면 예외가 발생하지 않는다.</span>
<span>// 0.123</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"0.1234"</span><span>)</span><span>.</span><span>setScale</span><span>(</span><span>3</span><span>,</span> <span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>

<span>// 소수점을 남기지 않고 반올림한다.</span>
<span>// 0</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"0.1234"</span><span>)</span><span>.</span><span>setScale</span><span>(</span><span>0</span><span>,</span> <span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>
<span>// 1</span>
<span>new</span> <span>BigDecimal</span><span>(</span><span>"0.9876"</span><span>)</span><span>.</span><span>setScale</span><span>(</span><span>0</span><span>,</span> <span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h4 id="bigdecimal-나누기-처리"> BigDecimal 나누기 처리</h4>
<div><pre><code><span>BigDecimal</span> b10 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"10"</span><span>)</span><span>;</span>
<span>BigDecimal</span> b3 <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>"3"</span><span>)</span><span>;</span>

<span>// 나누기 결과가 무한으로 떨어지면 예외 발생</span>
<span>// java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>)</span><span>;</span>

<span>// 반올림 정책을 명시하면 예외가 발생하지 않음</span>
<span>// 3</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>,</span> <span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>

<span>// 반올림 자리값을 명시</span>
<span>// 3.333333</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>,</span> <span>6</span><span>,</span> <span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>

<span>// 3.333333333</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>,</span> <span>9</span><span>,</span> <span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>

<span>// 전체 자리수를 7개로 제한하고 HALF_EVEN 반올림을 적용한다.</span>
<span>// 3.333333</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>,</span> <span>MathContext</span><span>.</span>DECIMAL32<span>)</span><span>;</span>

<span>// 전체 자리수를 16개로 제한하고 HALF_EVEN 반올림을 적용한다.</span>
<span>// 3.333333333333333</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>,</span> <span>MathContext</span><span>.</span>DECIMAL64<span>)</span><span>;</span>

<span>// 전체 자리수를 34개로 제한하고 HALF_EVEN 반올림을 적용한다.</span>
<span>// 3.333333333333333333333333333333333</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>,</span> <span>MathContext</span><span>.</span>DECIMAL128<span>)</span><span>;</span>

<span>// 전체 자리수를 제한하지 않는다.</span>
<span>// java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result. 예외가 발생한다.</span>
b10<span>.</span><span>divide</span><span>(</span>b3<span>,</span> <span>MathContext</span><span>.</span>UNLIMITED<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h4 id="bigdecimal-문자열-변환-출력"> BigDecimal 문자열 변환 출력</h4>
<ul>
<li>.setScale()을 사용하여 소수점 자리수를 제한하면 원본의 소수점 값은 상실해 버린다. 문자열로 출력하는 것이 목적이라면 NumberFormat 클래스를 사용하는 것이 적합하다.</li>
</ul>
<div><pre><code><span>NumberFormat</span> format <span>=</span> <span>NumberFormat</span><span>.</span><span>getInstance</span><span>(</span><span>)</span><span>;</span>
format<span>.</span><span>setMaximumFractionDigits</span><span>(</span><span>6</span><span>)</span><span>;</span>
format<span>.</span><span>setRoundingMode</span><span>(</span><span>RoundingMode</span><span>.</span>HALF_EVEN<span>)</span><span>;</span>
<span>// 0.123457</span>
format<span>.</span><span>format</span><span>(</span><span>new</span> <span>BigDecimal</span><span>(</span><span>"0.1234567890"</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="mysql과-bigdecimal"> MySQL과 BigDecimal</h4>
<ul>
<li>MySQL 또한 Java와 동일한 문제를 가지고 있다. FLOAT, DOUBLE 타입에 소수를 가진 수를 저장할 경우 앞서와 동일한 연산의 정확도 문제가 발생한다. 이를 해결하기 위해 DECIMAL 타입을 제공한다.</li>
</ul>
<div><pre><code>foo <span>DECIMAL</span><span>(</span><span>5</span><span>,</span><span>2</span><span>)</span> <span>DEFAULT</span> <span>0.00</span> <span>NOT</span> <span>NULL</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>DECIMAL 타입 선언시 괄호 안의 숫자의 의미는 PRECISION, SCALE을 의미한다. (5,2)의 경우 전체 자리수는 5, 소수점 이하 자리수는 2로 선언하겠다는 의미이다. 기본으로 (10,0)이 적용된다.
PRECISION의 최대값은 65로 산업 표준인 DECIMAL128을 충분히 수용할 수 있다. SCALE의 최대값은 30으로 PRECISION보다 클 수 없다.</li>
<li>만약, 지정된 소수 자리수보다 많은 값을 저장할 경우, 지정된 소수 자리수 이하는 절사(floor)된다.</li>
</ul>
<h4 id="jpa에서의-bigdecimal-처리"> JPA에서의 BigDecimal 처리</h4>
<ul>
<li>JDBC에서 MySQL/MariaDB의 DECIMAL 타입은 ResultSet 인터페이스의 getBigDecimal(), getString() 2개 메서드로 획득이 가능하다. JPAㄷ 또한 별도의 작업 없이 엔티티 필드에 BigDecimal 타입을 사용하여 처리하면 된다.</li>
<li>만약, 데이터베이스 저장시 소수점 이하 자리수와 반올림 방법을 자동으로 처리되게 하고 싶다면 JPA가 제공하는 커스텀 컨버터를 제작하면 된다.</li>
</ul>
<h4 id="bigdecimal과-java-stream"> BigDecimal과 Java Stream</h4>
<div><pre><code><span>// POJO 목록에서 BigDecimal 타입을 가진 특정 필드의 합을 반환</span>
<span>BigDecimal</span> sumOfFoo <span>=</span> fooList<span>.</span><span>stream</span><span>(</span><span>)</span>
    <span>.</span><span>map</span><span>(</span><span>FooEntity</span><span>::</span><span>getFooBigDecimal</span><span>)</span>
    <span>.</span><span>filter</span><span>(</span>foo <span>-></span> <span>Objects</span><span>.</span><span>nonNull</span><span>(</span>foo<span>)</span><span>)</span>
    <span>.</span><span>reduce</span><span>(</span><span>BigDecimal</span><span>.</span>ZERO<span>,</span> <span>BigDecimal</span><span>::</span><span>add</span><span>)</span><span>;</span>

<span>// 특정 BigDecimal 필드를 기준으로 오름차순 정렬된 리스트를 반환</span>
foolist<span>.</span><span>stream</span><span>(</span><span>)</span>
    <span>.</span><span>sorted</span><span>(</span><span>Comparator</span><span>.</span><span>comparing</span><span>(</span>it <span>-></span> it<span>.</span><span>getAmount</span><span>(</span><span>)</span><span>)</span><span>)</span>
    <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>// 위와 동일한 기능, 정렬된 새로운 리스트를 반환하지 않고 원본 리스트를 바로 정렬</span>
foolist<span>.</span><span>sort</span><span>(</span><span>Comparator</span><span>.</span><span>comparing</span><span>(</span>it <span>-></span> it<span>.</span><span>getAmount</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>https://jsonobject.tistory.com/466</p>
<br>
<h2 id="_1104-정적-팩토리-메서드-static-factory-method"> 1104 - 정적 팩토리 메서드(static factory method)</h2>
<h3 id="개요"> 개요</h3>
<p>객체 생성을 캡슐화하는 기법이다.<br>
좀 더 구체적으로는 객체를 생성하는 메소드를 만들고, <code>static</code>으로 선언하는 기법이다.<br>
자바로 코딩할 때 흔하게 볼 수 있는 <code>valueOf</code> 메서드가 정적 팩토리 메서드의 한 예라 할 수 있다.</p>
<div><pre><code><span>BigInteger</span> answer <span>=</span> <span>BigInteger</span><span>.</span><span>valueOf</span><span>(</span><span>42L</span><span>)</span><span>;</span> <span>// BigInteger 42를 리턴한다</span>
</code></pre>
<div><span>1</span><br></div></div><p>static으로 선언된 메서드이며, new BigInteger(...)를 은닉하고 있다는 사실을 알 수 있다.<br>
valueOf 외에, 정적 팩토리 메서드의 이름으로 흔히 사용되는 것들은 다음과 같다.</p>
<ul>
<li>valueOf</li>
<li>of</li>
<li>getInstance</li>
<li>newInstance</li>
<li>getType</li>
<li>newType</li>
</ul>
<h3 id="effective-java"> Effective Java</h3>
<blockquote>
<p>이펙티브 자아 2판은 &quot;규칠 1&quot;에서 이 기법을 소개하고 있다.<br>
규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보라.</p>
</blockquote>
<ul>
<li>단, GoF의 디자인 패턴 책에 나오는 팩토리 메서드 패턴과는 다른 패턴이다. 이름만 비슷하다.</li>
<li>Effective Java 저자 조슈야 블로흐도 GoF의 디자인 패턴 책에 나온 어떤 패턴과도 맞아 떨어지지 않는다며 주의하라고 말함.</li>
</ul>
<p>Effective Java에서는 다음과 같은 장단점을 설명한다.</p>
<ul>
<li>장점
<ol>
<li>이름이 있으므로 생성자에 비해 가독성이 좋다.</li>
<li>호출할 때마다 새로운 객체를 생성할 필요가 없다.</li>
<li>하위 자료형 객체를 반환할 수 있다.</li>
<li>형인자 자료형(parameterized type) 객체를 만들 때 편하다.</li>
</ol>
</li>
<li>단점
<ol>
<li>정적 팩토리 메서드만 있는 클래스라면, 생성자가 없으므로 하위 클래스를 못 만든다.</li>
<li>정적 팩토리 메서드는 다른 정적 메서드와 잘 구분되지 않는다.(문서만으로 확인하기 어려울 수 있음)</li>
</ol>
</li>
</ul>
<h3 id="정적-팩토리-메서드-특징"> 정적 팩토리 메서드 특징</h3>
<ul>
<li>가독성이 좋다.</li>
</ul>
<div><pre><code><span>class</span> <span>Character</span> <span>{</span>

    <span>int</span> intelligence<span>,</span> strength<span>,</span> hitPoint<span>,</span> magicPoint<span>;</span>

    <span>public</span> <span>Character</span><span>(</span><span>int</span> intelligence<span>,</span> <span>int</span> strength<span>,</span> <span>int</span> hitPoint<span>,</span> <span>int</span> magicPoint<span>)</span> <span>{</span>
        <span>this</span><span>.</span>intelligence <span>=</span> intelligence<span>;</span>   <span>// 지능</span>
        <span>this</span><span>.</span>strength <span>=</span> strength<span>;</span>           <span>// 힘</span>
        <span>this</span><span>.</span>hitPoint <span>=</span> hitPoint<span>;</span>           <span>// HP</span>
        <span>this</span><span>.</span>magicPoint <span>=</span> magicPoint<span>;</span>       <span>// MP</span>
    <span>}</span>

    <span>// 정적 팩토리 메소드</span>
    <span>public</span> <span>static</span> <span>Character</span> <span>newWarrior</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Character</span><span>(</span><span>5</span><span>,</span> <span>15</span><span>,</span> <span>20</span><span>,</span> <span>3</span><span>)</span><span>;</span>     <span>// 전사는 힘과 HP가 높다</span>
    <span>}</span>

    <span>// 정적 팩토리 메소드</span>
    <span>public</span> <span>static</span> <span>Character</span> <span>newMage</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Character</span><span>(</span><span>15</span><span>,</span> <span>5</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>)</span><span>;</span>    <span>// 마법사는 지능과 MP가 높다</span>
    <span>}</span>
<span>}</span>

<span>// 정적 팩토리 메서드</span>
<span>Character</span> warrior <span>=</span> <span>Character</span><span>.</span><span>newWarrior</span><span>(</span><span>)</span><span>;</span>
<span>Character</span> mage <span>=</span> <span>Character</span><span>.</span><span>newMage</span><span>(</span><span>)</span><span>;</span>

<span>// 생성자</span>
<span>Character</span> warrior <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>5</span><span>,</span> <span>15</span><span>,</span> <span>20</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>Character</span> mage <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>15</span><span>,</span> <span>5</span><span>,</span> <span>10</span><span>,</span> <span>15</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><ul>
<li>호출할 때마다 새로운 객체를 생성할 필요가 없다.<br>
사실 위와 같이 마법사와 전사를 만드는 코드는 정적 메서드를 호출할 때마다 new Character(...)를 호출하게 된다.<br>
그러나 immutable 객체를 캐시해서 쓰고 있다면 굳이 일일이 new 같은 비싼 연산을 사용할 필요가 없다.<br>
<code>java.math.BigInteger.valueOf</code> 예제</li>
</ul>
<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>BigInteger</span> ZERO <span>=</span> <span>new</span> <span>BigInteger</span><span>(</span><span>new</span> <span>int</span><span>[</span><span>0</span><span>]</span><span>,</span> <span>0</span><span>)</span><span>;</span>

<span>private</span> <span>final</span> <span>static</span> <span>int</span> MAX_CONSTANT <span>=</span> <span>16</span><span>;</span>
<span>private</span> <span>static</span> <span>BigInteger</span> posConst<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>BigInteger</span><span>[</span>MAX_CONSTANT<span>+</span><span>1</span><span>]</span><span>;</span>
<span>private</span> <span>static</span> <span>BigInteger</span> negConst<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>BigInteger</span><span>[</span>MAX_CONSTANT<span>+</span><span>1</span><span>]</span><span>;</span>

<span>static</span> <span>{</span>
    <span>/* posConst에 1 ~ 16까지의 BigInteger 값을 담는다. */</span>
    <span>/* negConst에 -1 ~ -16까지의 BigInteger 값을 담는다. */</span>
<span>}</span>

<span>public</span> <span>static</span> <span>BigInteger</span> <span>valueOf</span><span>(</span><span>long</span> val<span>)</span> <span>{</span>
    <span>// 미리 만들어둔 객체를 리턴한다</span>
    <span>if</span> <span>(</span>val <span>==</span> <span>0</span><span>)</span>
        <span>return</span> ZERO<span>;</span>
    <span>if</span> <span>(</span>val <span>></span> <span>0</span> <span>&amp;&amp;</span> val <span>&lt;=</span> MAX_CONSTANT<span>)</span>
        <span>return</span> posConst<span>[</span><span>(</span><span>int</span><span>)</span> val<span>]</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>val <span><span>&lt;</span> 0 <span>&amp;</span><span>&amp;</span> val <span>></span></span><span>=</span> <span>-</span>MAX_CONSTANT<span>)</span>
        <span>return</span> negConst<span>[</span><span>(</span><span>int</span><span>)</span> <span>-</span>val<span>]</span><span>;</span>

    <span>// 새로운 객체를 만들어 리턴한다</span>
    <span>return</span> <span>new</span> <span>BigInteger</span><span>(</span>val<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><ul>
<li>하위 자료형 객체를 반환할 수 있다.
리턴하는 객체의 타입을 유연하게 지정할 수 있다.<br>
다음은 어느 가상의 인터넷 쇼핑몰에서 할인 코드를 처리하는 정적 팩토리 메서드이다.</li>
</ul>
<div><pre><code><span>class</span> <span>OrderUtil</span> <span>{</span>

    <span>public</span> <span>static</span> <span>Discount</span> <span>createDiscountItem</span><span>(</span><span>String</span> discountCode<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>if</span><span>(</span><span>!</span><span>isValidCode</span><span>(</span>discountCode<span>)</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"잘못된 할인 코드"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 쿠폰 코드인가? 포인트 코드인가?</span>
        <span>if</span><span>(</span><span>isUsableCoupon</span><span>(</span>discountCode<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>Coupon</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span><span>(</span><span>isUsablePoint</span><span>(</span>discountCode<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>Point</span><span>(</span><span>500</span><span>)</span><span>;</span>
        <span>}</span>
        <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"이미 사용한 코드"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Coupon</span> <span>extends</span> <span>Discount</span> <span>{</span> <span>}</span>
<span>class</span> <span>Point</span> <span>extends</span> <span>Discount</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>할인 코드의 규칙에 따란 Coupon과 point 객체를 선택적으로 리턴하고 있다.<br>
이를 위해서는 두 하위 클래스가 같은 인터페이스를 구현하거나, 같은 부모 클래스를 갖도록 하면 된다. 만약 파일을 분리하기 애매한 작은 클래스가 있다면 private class를 활용할 수도 있다.</p>
<p>다음은 <code>java.util.Collections</code>에서 EMPTY_MAP부분을 발췌한 것</p>
<div><pre><code><span>@SuppressWarnings</span><span>(</span><span>"rawtypes"</span><span>)</span>
<span>public</span> <span>static</span> <span>final</span> <span>Map</span> EMPTY_MAP <span>=</span> <span>new</span> <span>EmptyMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>/**
 * Returns an empty map (immutable).  This map is serializable.
 */</span>
<span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
<span>public</span> <span>static</span> <span>final</span> <span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>emptyMap</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span> EMPTY_MAP<span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>EmptyMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>AbstractMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Serializable</span> <span>{</span>
    <span>/* 생략 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>EmptyMap 클래스는 java.util.Collections 내에 private static으로 선언되었으며, emptyMap이라는 정적 팩토리 메서드를 통해 캐스팅된 인스턴스를 얻을 수 있다.</p>
<ul>
<li>형인자 자료형 객체를 만들 때 편리하다
Java 1.7이전에는 다음과 같이 형인자 자료형 객체를 만들어야 했다.</li>
</ul>
<div><pre><code><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> list <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>// 정적 팩토리 메서드: type inference를 이용한다</span>
<span>public</span> <span>static</span> <span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>newInstance</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 위의 정적 팩토리 메서드를 사용한다</span>
<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> list <span>=</span> <span>HashMap</span><span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>

<span>// Java 1.7 이후</span>
<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> list <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Java 1.7부터 형인자 없이 생성이 가능하게 되어서, 의미를 거의 잃었다.</p>
<ul>
<li>Lombok RequiredArgsConstructor.staticName의 사용
Lombok의 <code>RequiredArgsConstructor</code>를 사용하면 정적 팩토리 메소드를 쉽게 만들 수 있다.</li>
</ul>
<div><pre><code><span>import</span> <span>lombok<span>.</span></span><span>RequiredArgsConstructor</span><span>;</span>

<span>//                                      ↓ 정적 팩토리 메소드 이름</span>
<span>@RequiredArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>public</span> <span>class</span> <span>BlogUser</span> <span>{</span>
  <span>private</span> <span>final</span> <span>Long</span> id<span>;</span>
  <span>private</span> <span>final</span> <span>String</span> name<span>;</span>
<span>}</span>

<span>BlogUser</span> user <span>=</span> <span>BlogUser</span><span>.</span><span>of</span><span>(</span><span>1L</span><span>,</span> <span>"JohnGrib"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>위와 같이 staticName을 선언하면 롬복이 of라는 이름을 가진 정적 팩토리 메소드를 만들어준다.</p>
<br>
<h2 id="_1105-fixture와-mock"> 1105 - Fixture와 Mock</h2>
<h3 id="test-fixture"> Test Fixture</h3>
<blockquote>
<p>Fixture는 '고정되어 있는 물체'를 의미</p>
</blockquote>
<h4 id="junit-팀에서-말하는-테스트-픽스처란"> Junit 팀에서 말하는 테스트 픽스처란?</h4>
<p>의역하자면, 테스트 실행을 위해 베이스라인으로서 사용되는 객체들의 고정된 상태이다. 테스트 픽스처의 목적은 결과를 반복가능 할 수 있도록 알 수 있고, 고정된 환경에서 테스트할 수 있음을 보장하기 위함이다.</p>
<h4 id="예시"> 예시</h4>
<ul>
<li>목 또는 가짜 객체의 세팅이나 생성 그리고 삽입할 데이터의 준비</li>
<li>구체적이며 알고있는 데이터를 지닌 데이터베이스 로딩</li>
<li>테스트 픽스처를 만들어내는 특정 파일들을 복사하면 특정 상태로 초기화된 객체들이 생성됨.</li>
</ul>
<p>Junit은 테스트 클래스들이 매번 테스트 실행 전/후 아니면 한번만 픽스처를 가질 수 있도록 애노테이션으로 제공한다.(Junit4이 제공하는 4가지 픽스처 애노테이션: @Before, @BeforeClass, @After, @AfterClass)</p>
<h3 id="mock-mocking"> Mock, Mocking</h3>
<blockquote>
<p>주로 객체 지향 프로그래밍으로 개발한 프로그램을 테스트 할 경우 테스트를 수행할 모듈과 연결되는 외부의 다른 서비스나 모듈들을 실제 사용하는 모듈을 사용하지 않고 실제의 모듈을 &quot;흉내&quot;내는 &quot;가짜&quot;모듈을 작성하여 테스트의 효용성을 높이는데 사용하는 객체이다. 사용자 인터페이스(UI)나 데이터베이스 테스트 등과 같이 자동화된 테스트를 수행하기 어려울 때 널리 사용된다.</p>
</blockquote>
<h4 id="mocking"> Mocking</h4>
<p>Mocking은 유닛 테스트에서 주로 사용된다.</p>
<p>테스트 하는 객체는 보통 다른 객체들과 의존성을 가지고 있다. 원하는 객체의 행동을 고립시키기 위해(의존성 없이) 다른 객체들을 실제 객체의 행동을 시뮬레이션하는 mock으로 대체 시켜야한다.</p>
<p>이는 실제 객체를 단위 테스트에 통합하기에 실용적이지 않을 때 유용하다</p>
<p>간략히 말해, Mocking이란 실제 객체들의 행동을 시뮬레이션하는 객체들을 만드는 것이다.</p>
<br>
<h2 id="_1106-rest-assured"> 1106 - REST Assured</h2>
<p>Java 클래스의 동작을 확인하는 Unit 테스트 수행은, 테스트 전략의 첫 단계이다.<br>
개별 Java클래스가 독릭접으로 잘 작동한다고 해서 모든 클래스가 함께 묶일 때 어플리케이션 자체가 올바르게 작동한다는 것은 아니다.</p>
<p>기본 단위테스트 외에도 통합테스트(모듈에 초점을 맞춘 테스트), 기능 테스트(배포된대로 어플리케이션을 사용하는 end-to-end 테스트), 사용자 승인 테스트(GUI 테스트)가 있다.</p>
<h3 id="rest-assured란"> REST Assured란?</h3>
<p>REST Assured는 REST 웹 서비스를 검증하기 위한 Java 라이브러리<br>
HTTP endpoint에 대한 연결 및 예상되는 결과를 설명하는 친숙한 DSL(Domain Specific Languages)을 제공한다.</p>
<ul>
<li>예제</li>
</ul>
<div><pre><code><span>import</span> <span>org<span>.</span>junit<span>.</span></span><span>Test</span><span>;</span>
<span>import</span> <span>io<span>.</span>restassured<span>.</span></span><span>RestAssured</span><span>;</span>
<span>public</span> <span>class</span> <span>SampleTest</span> <span>{</span>
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>
        <span>RestAssured</span><span>.</span><span>given</span><span>(</span><span>)</span>
                    <span>.</span><span>when</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>"http://www.google.com"</span><span>)</span>
                    <span>.</span><span>then</span><span>(</span><span>)</span><span>.</span><span>statusCode</span><span>(</span><span>200</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>given-when-then 패턴을 이용한 코드를 작성
<ul>
<li>given : Test setup(테스트시 필요한 데이터, 및 파라미터를 셋팅)</li>
<li>when : Test action(Method type을 정의)</li>
<li>then : Test verification(Response Data를 검증)</li>
</ul>
</li>
</ul>
<h3 id="rest-assured-사용"> REST Assured 사용</h3>
<h4 id="설정"> 설정</h4>
<ul>
<li>gradle</li>
</ul>
<div><pre><code>dependencies <span>{</span>
    <span>...</span>
    testImplementation 'io.rest<span>-</span>assured<span>:</span>rest<span>-</span>assured<span>:</span>4.4.0'
    testImplementation 'io.rest<span>-</span>assured<span>:</span>json<span>-</span>schema<span>-</span>validator<span>:</span>4.4.0'
    <span>...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="사용법"> 사용법</h4>
<ul>
<li>Parameters</li>
</ul>
<div><pre><code><span>given</span><span>(</span><span>)</span><span>.</span>
       <span>param</span><span>(</span><span>"param1"</span><span>,</span> <span>"value1"</span><span>)</span><span>.</span>
       <span>param</span><span>(</span><span>"param2"</span><span>,</span> <span>"value2"</span><span>)</span><span>.</span>
<span>when</span><span>(</span><span>)</span><span>.</span>
       <span>get</span><span>(</span><span>"/something"</span><span>)</span><span>;</span>
       
<span>// given().param("myList", "value1", "value2");</span>

<span>// List&lt;String> values = new ArrayList&lt;String>();</span>
<span>// values.add("value1");</span>
<span>// values.add("value2");</span>
<span>// given().param("myList", values)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>REST Assured는 HTTP method에 기반하여 parameter type을 자동으로 결정, GET =&gt; query parameters / POST =&gt; form parameters</p>
<div><pre><code><span>given</span><span>(</span><span>)</span><span>.</span>
       <span>formParam</span><span>(</span><span>"formParamName"</span><span>,</span> <span>"value1"</span><span>)</span><span>.</span>
       <span>queryParam</span><span>(</span><span>"q0-998ueryParamName"</span><span>,</span> <span>"value2"</span><span>)</span><span>.</span>
<span>when</span><span>(</span><span>)</span><span>.</span>
       <span>post</span><span>(</span><span>"/something"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>하지만, PUT, POST type에서 query parameter와 form parameter를 함께 사용할 때는 정확하게 명시해야한다.</p>
<ul>
<li>path parameter</li>
</ul>
<div><pre><code><span>post</span><span>(</span><span>"/reserve/{hotelId}/{roomNumber}"</span><span>,</span> <span>"My Hotel"</span><span>,</span> <span>23</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h4 id="response-json의-assersion-정의"> Response JSON의 Assersion 정의</h4>
<ol>
<li>then().assertThat()</li>
<li>Response Message에서 Assert 구문을 이용하는 방법</li>
</ol>
<ul>
<li>Response Data 검증
<ul>
<li>equalTo : then().assertThat().body(equalTo(&quot;something&quot;))</li>
<li>hasItems : then(). assertThat().body(&quot;lotto.winners.winnerId&quot;, hasItems(23, 54));</li>
<li>startsWith, endsWithPath : body(&quot;href&quot;, and(startsWith(&quot;http:/localhost:8080/&quot;), endsWithPath(&quot;userId&quot;)));</li>
<li>time : when(). get(&quot;/&quot;). then(). time(lessThan(2000L)); // Milliseconds</li>
<li>size : then().assertThat().body(&quot;size()&quot;, equalTo(10))</li>
<li>contain : then().assertThat(). body(containsString(&quot;some&quot;))</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1108 - 1114</title>
      <link>ahnjs/TIL/2021/1108/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1108/</guid>
      <source url="ahnjs/TIL/rss.xml">1108 - 1114</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1108-1114"> 1108 - 1114</h1>
<h2 id="_1108-ssl"> 1108 - ssl</h2>
<h3 id="ssl이란"> SSL이란?</h3>
<p>SSL(Secure Socket Layer)은 암호화 기반 인터넷 보안 프로토콜이다. 인터넷 통신의 개인정보 보호, 인증, 데이터 무결성을 보장하기 위해 Netscape가 1995년 처음으로 개발했다. SSL은 현재 사용 중인 TLS 암호화의 전신이다.</p>
<p>SSL/TLS를 사용하는 웹사이트의 URL에는 &quot;HTTP&quot;대신 &quot;HTTPS&quot;가 있다.</p>
<h3 id="ssl-tls-작동원리"> SSL/TLS 작동원리</h3>
<ul>
<li>SSL은 높은 수준의 개인정보 보호를 제공하기 위해, 웹에서 전송되는 데이터를 암호화한다. 따라서, 데이터를 가로채려는 자는 거의 해독할 수 없는 복잡한 문자만 보게 된다.</li>
<li>SSL은 두 통신 장치 사이에 핸드셰이크라는 인증 프로세스를 시작하여 두 장치의 ID를 확인한다.</li>
<li>SSL은 또한 데이터 무결성을 제공하기 위해 데이터에 디지털 서명하여 데이터가 의도된 수신자에 도착하기 전에 조작되지 않았다는 것을 확인하다.</li>
</ul>
<p>SSL은 여러 번 개선되어 매번 성능이 개선되었으며, 1999년에 SSL은 TLS로 업데이트 됐다.</p>
<h3 id="ssl-tls의-중요성"> SSL/TLS의 중요성</h3>
<ul>
<li>예, 주문 과정에서 고객의 신용 카드 번호가 사용됐을떄 탈취자에게 노출되게 된다.</li>
<li>또한 SSL은 특정한 유형의 사이버 공격도 차단한다.</li>
</ul>
<h3 id="ssl-tls의-차이"> SSL/TLS의 차이</h3>
<ul>
<li>SSL은 TLS(Transport Layer Security)라는 또 다른 프로토콜의 바로 이전 버전이다. 1999년 IETF는 SSL에 대한 업데이트를 제안했고, Netscape가 더 이상 참여하지 않게 되면서, 이름이 TLS로 변경되었다.</li>
</ul>
<h3 id="ssl인증이란"> SSL인증이란?</h3>
<p>SSL은 SSL 인증서가 있는 웹사이트만 실행할 수 있다. SSL 인증서는 웹사이트나 애플리케이션 서버가 웹에 저장하고 표시한다.</p>
<p>SSL 인증서에 포함된 가장 중요한 정보에 웹사이트의 공개 키가 있다. 이 공개 키 덕북에 암호화가 가능하며, 사용자의 장치는 공개 키를 보고 이를 이용하여 웹 서버와 안전한 암호화 키를 수립한다. 한편, 웹 서버에도 기밀로 유지하는 개인 키가 있다. 개인 키는 공개 키로 암호화된 데이터를 해독한다. CA(인증 기관)는 SSL 인증서 발행을 담당한다.</p>
<h3 id="ssl-인증서-유형"> SSL 인증서 유형</h3>
<ul>
<li>단일 도메인</li>
<li>와일드카드</li>
<li>멀티 도메인</li>
<li>도메인 유효성 검사</li>
<li>조직 유효성 검사</li>
<li>확장 유효성 검사</li>
</ul>
<br>
<h2 id="_1110-mapstruct-맵스트럭트"> 1110 - MapStruct(맵스트럭트)</h2>
<p>Model mapping을 아주 쉽게 해주는 라이브러리.</p>
<h3 id="맵스트럭트-사용법"> 맵스트럭트 사용법</h3>
<h4 id="build-gradle"> build.gradle</h4>
<div><pre><code>buildscript {
	ext {
		mapstructVersion = '1.3.1.Final'
	}
}

...

// Mapstruct
implementation "org.mapstruct:mapstruct:${mapstructVersion}"
annotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"
testAnnotationProcessor "org.mapstruct:mapstruct-processor:${mapstructVersion}"

...

compileJava {
	options.compilerArgs = [
			'-Amapstruct.suppressGeneratorTimestamp=true',
			'-Amapstruct.suppressGeneratorVersionInfoComment=true'
	]
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h4 id="java"> java</h4>
<div><pre><code><span>@Data</span>
<span>@AllArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>CarDto</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> color<span>;</span>
<span>}</span>
 
<span>--</span><span>-</span>

<span>@Data</span>
<span>@AllArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>Car</span> <span>{</span>
    <span>private</span> <span>String</span> modelName<span>;</span>
    <span>private</span> <span>String</span> modelColor<span>;</span>
<span>}</span>
 
<span>--</span><span>-</span>

<span>@Mapper</span>
<span>public</span> <span>interface</span> <span>CarMapper</span> <span>{</span>
 
    <span>CarMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>CarMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"name"</span><span>,</span> target <span>=</span> <span>"modelName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"color"</span><span>,</span> target <span>=</span> <span>"modelColor"</span><span>)</span>
    <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>각각 dto, domain, mapper</p>
<div><pre><code><span>public</span> <span>class</span> <span>MapstructTest</span> <span>{</span>
 
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>
        <span>CarDto</span> carDto <span>=</span> <span>CarDto</span><span>.</span><span>of</span><span>(</span><span>"bmw x4"</span><span>,</span> <span>"black"</span><span>)</span><span>;</span>
        <span>Car</span> car <span>=</span> <span>CarMapper</span><span>.</span>INSTANCE<span>.</span><span>to</span><span>(</span>carDto<span>)</span><span>;</span>
 
        <span>assertEquals</span><span>(</span>carDto<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> car<span>.</span><span>getModelName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>assertEquals</span><span>(</span>carDto<span>.</span><span>getColor</span><span>(</span><span>)</span><span>,</span> car<span>.</span><span>getModelColor</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>간단한 테스트 코드</p>
<ul>
<li>실제 생성된 코드</li>
</ul>
<div><pre><code><span>@Generated</span><span>(</span>
    value <span>=</span> <span>"org.mapstruct.ap.MappingProcessor"</span>
<span>)</span>
<span>public</span> <span>class</span> <span>CarMapperImpl</span> <span>implements</span> <span>CarMapper</span> <span>{</span>
 
    <span>@Override</span>
    <span>public</span> <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span> <span>{</span>
        <span>if</span> <span>(</span> carDto <span>==</span> <span>null</span> <span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
 
        <span>Car</span> car <span>=</span> <span>new</span> <span>Car</span><span>(</span><span>)</span><span>;</span>
 
        car<span>.</span><span>setModelName</span><span>(</span> carDto<span>.</span><span>getName</span><span>(</span><span>)</span> <span>)</span><span>;</span>
        car<span>.</span><span>setModelColor</span><span>(</span> carDto<span>.</span><span>getColor</span><span>(</span><span>)</span> <span>)</span><span>;</span>
 
        <span>return</span> car<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h4 id="하나의-객체로-합치기"> 하나의 객체로 합치기</h4>
<ul>
<li>여러 객체의 필드값을 하나의 객체로 합치기가 가능하다. 특별히 다른 옵션을 넣는 것은 아니다.</li>
</ul>
<div><pre><code><span>@Data</span>
<span>@AllArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>UserDto</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
<span>}</span>

<span>--</span><span>-</span> 

<span>@Data</span>
<span>@AllArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>AddressDto</span> <span>{</span>
    <span>private</span> <span>String</span> si<span>;</span>
    <span>private</span> <span>String</span> dong<span>;</span>
<span>}</span>
 
<span>--</span><span>-</span>

<span>@Mapper</span>
<span>public</span> <span>interface</span> <span>UserInfoMapper</span> <span>{</span>
 
    <span>UserInfoMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>UserInfoMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"user.name"</span><span>,</span> target <span>=</span> <span>"userName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"address.si"</span><span>,</span> target <span>=</span> <span>"si"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"address.dong"</span><span>,</span> target <span>=</span> <span>"dong"</span><span>)</span>
    <span>UserInfo</span> <span>to</span><span>(</span><span>UserDto</span> user<span>,</span> <span>AddressDto</span> address<span>)</span><span>;</span>
<span>}</span>
 
<span>--</span><span>-</span> 

<span>@Generated</span><span>(</span>
    value <span>=</span> <span>"org.mapstruct.ap.MappingProcessor"</span>
<span>)</span>
<span>public</span> <span>class</span> <span>UserInfoMapperImpl</span> <span>implements</span> <span>UserInfoMapper</span> <span>{</span>
 
    <span>@Override</span>
    <span>public</span> <span>UserInfo</span> <span>to</span><span>(</span><span>UserDto</span> user<span>,</span> <span>AddressDto</span> address<span>)</span> <span>{</span>
        <span>if</span> <span>(</span> user <span>==</span> <span>null</span> <span>&amp;&amp;</span> address <span>==</span> <span>null</span> <span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
 
        <span>UserInfo</span> userInfo <span>=</span> <span>new</span> <span>UserInfo</span><span>(</span><span>)</span><span>;</span>
 
        <span>if</span> <span>(</span> user <span>!=</span> <span>null</span> <span>)</span> <span>{</span>
            userInfo<span>.</span><span>setUserName</span><span>(</span> user<span>.</span><span>getName</span><span>(</span><span>)</span> <span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span> address <span>!=</span> <span>null</span> <span>)</span> <span>{</span>
            userInfo<span>.</span><span>setDong</span><span>(</span> address<span>.</span><span>getDong</span><span>(</span><span>)</span> <span>)</span><span>;</span>
            userInfo<span>.</span><span>setSi</span><span>(</span> address<span>.</span><span>getSi</span><span>(</span><span>)</span> <span>)</span><span>;</span>
        <span>}</span>
 
        <span>return</span> userInfo<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><h4 id="이미-생성된-객체에-매핑"> 이미 생성된 객체에 매핑</h4>
<ul>
<li>새로운 인스턴스를 생성하는 것이 아니라, 기존에 이미 생성되어 있는 객체에 매핑이 필요한 경우</li>
</ul>
<div><pre><code><span>@Mapper</span>
<span>public</span> <span>interface</span> <span>UserInfoMapper</span> <span>{</span>
 
    <span>UserInfoMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>UserInfoMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"user.name"</span><span>,</span> target <span>=</span> <span>"userName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"address.si"</span><span>,</span> target <span>=</span> <span>"si"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"address.dong"</span><span>,</span> target <span>=</span> <span>"dong"</span><span>)</span>
    <span>void</span> <span>write</span><span>(</span><span>UserDto</span> user<span>,</span> <span>AddressDto</span> address<span>,</span> <span>@MappingTarget</span> <span>UserInfo</span> userInfo<span>)</span><span>;</span>
<span>}</span>
 
<span>@Generated</span><span>(</span>
    value <span>=</span> <span>"org.mapstruct.ap.MappingProcessor"</span>
<span>)</span>
<span>public</span> <span>class</span> <span>UserInfoMapperImpl</span> <span>implements</span> <span>UserInfoMapper</span> <span>{</span>
 
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>write</span><span>(</span><span>UserDto</span> user<span>,</span> <span>AddressDto</span> address<span>,</span> <span>UserInfo</span> userInfo<span>)</span> <span>{</span>
        <span>if</span> <span>(</span> user <span>==</span> <span>null</span> <span>&amp;&amp;</span> address <span>==</span> <span>null</span> <span>)</span> <span>{</span>
            <span>return</span><span>;</span>
        <span>}</span>
 
        <span>if</span> <span>(</span> user <span>!=</span> <span>null</span> <span>)</span> <span>{</span>
            userInfo<span>.</span><span>setUserName</span><span>(</span> user<span>.</span><span>getName</span><span>(</span><span>)</span> <span>)</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span> address <span>!=</span> <span>null</span> <span>)</span> <span>{</span>
            userInfo<span>.</span><span>setDong</span><span>(</span> address<span>.</span><span>getDong</span><span>(</span><span>)</span> <span>)</span><span>;</span>
            userInfo<span>.</span><span>setSi</span><span>(</span> address<span>.</span><span>getSi</span><span>(</span><span>)</span> <span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h4 id="타입-변환"> 타입 변환</h4>
<ul>
<li>대부분의 암시적인 자동 형변환이 가능하다. (Integer -&gt; String ...) 다음은 조금 유용한 기능이다.</li>
</ul>
<div><pre><code><span>@Mapper</span>
<span>public</span> <span>interface</span> <span>CarMapper</span> <span>{</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"price"</span><span>,</span> numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>CarDto</span> <span>carToCarDto</span><span>(</span><span>Car</span> car<span>)</span><span>;</span>
 
    <span>@IterableMapping</span><span>(</span>numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>prices</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> prices<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="source-target-mapping-policy"> Source, Target mapping policy</h4>
<ul>
<li>매핑될 필드가 존재하지 않을 때, 엄격한 정책을 가져가기 위한 기능을 제공한다.</li>
</ul>
<div><pre><code><span>@Data</span>
<span>@AllArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>Car</span> <span>{</span>
    <span>private</span> <span>String</span> modelName<span>;</span>
    <span>private</span> <span>String</span> modelColor<span>;</span>
    <span>private</span> <span>String</span> modelPrice<span>;</span>
    <span>private</span> <span>String</span> description<span>;</span>
<span>}</span>
 
<span>@Data</span>
<span>@AllArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>@NoArgsConstructor</span>
<span>public</span> <span>class</span> <span>CarDto</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> color<span>;</span>
    <span>private</span> <span>Integer</span> price<span>;</span>
<span>}</span>
 
<span>@Mapper</span><span>(</span>unmappedTargetPolicy <span>=</span> <span>ReportingPolicy</span><span>.</span>ERROR<span>)</span>
<span>public</span> <span>interface</span> <span>CarMapper</span> <span>{</span>
 
    <span>CarMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>CarMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"name"</span><span>,</span> target <span>=</span> <span>"modelName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"color"</span><span>,</span> target <span>=</span> <span>"modelColor"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"price"</span><span>,</span> target <span>=</span> <span>"modelPrice"</span><span>,</span> numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span><span>;</span>
 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>위 코드는 타겟이 되는 오브젝트 필드에 대한 정책을 가져간다. Car 클래스에는 description 필드가 있는데, CarDto 클래스에는 해당 필드가 존재하지 않기 때문에 컴파일시 컴파일에러가 발생한다.(ERROR, IGNORE, WARN 정책 존재) 만약 특정 필드는 해당 정책을 피하고 싶다면 아래와 같이 어노테이션하나를 달아준다.</p>
<div><pre><code><span>@Mapper</span><span>(</span>unmappedTargetPolicy <span>=</span> <span>ReportingPolicy</span><span>.</span>ERROR<span>)</span>
<span>public</span> <span>interface</span> <span>CarMapper</span> <span>{</span>
 
    <span>CarMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>CarMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"name"</span><span>,</span> target <span>=</span> <span>"modelName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"color"</span><span>,</span> target <span>=</span> <span>"modelColor"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"price"</span><span>,</span> target <span>=</span> <span>"modelPrice"</span><span>,</span> numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>@Mapping</span><span>(</span>target <span>=</span> <span>"description"</span><span>,</span> ignore <span>=</span> <span>true</span><span>)</span>
    <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span><span>;</span>
 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="null-정책"> null 정책</h4>
<ul>
<li>Source가 null이거나 혹은 Source의 특정 필드가 null일때 적용가능한 정책이 존재한다.</li>
</ul>
<div><pre><code><span>@Mapper</span><span>(</span>
        unmappedTargetPolicy <span>=</span> <span>ReportingPolicy</span><span>.</span>ERROR<span>,</span>
        nullValueMappingStrategy <span>=</span> <span>NullValueMappingStrategy</span><span>.</span>RETURN_DEFAULT
<span>)</span>
<span>public</span> <span>interface</span> <span>CarMapper</span> <span>{</span>
 
    <span>CarMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>CarMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"name"</span><span>,</span> target <span>=</span> <span>"modelName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"color"</span><span>,</span> target <span>=</span> <span>"modelColor"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"price"</span><span>,</span> target <span>=</span> <span>"modelPrice"</span><span>,</span> numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>@Mapping</span><span>(</span>target <span>=</span> <span>"description"</span><span>,</span> ignore <span>=</span> <span>true</span><span>)</span>
    <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span><span>;</span>
 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>위 코드는 Source 오브젝트가 null일때, 기본생성자로 필드가 비어있는 Target 오브젝트를 반환해준다.</p>
<div><pre><code><span>@Mapper</span><span>(</span>
        unmappedTargetPolicy <span>=</span> <span>ReportingPolicy</span><span>.</span>ERROR<span>,</span>
        nullValueMappingStrategy <span>=</span> <span>NullValueMappingStrategy</span><span>.</span>RETURN_NULL
<span>)</span>
<span>public</span> <span>interface</span> <span>CarMapper</span> <span>{</span>
 
    <span>CarMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>CarMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"name"</span><span>,</span> target <span>=</span> <span>"modelName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"color"</span><span>,</span> target <span>=</span> <span>"modelColor"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"price"</span><span>,</span> target <span>=</span> <span>"modelPrice"</span><span>,</span> numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>@Mapping</span><span>(</span>
            source <span>=</span> <span>"description"</span><span>,</span> 
            target <span>=</span> <span>"description"</span><span>,</span> 
            ignore <span>=</span> <span>true</span><span>,</span>
            nullValuePropertyMappingStrategy <span>=</span> <span>NullValuePropertyMappingStrategy</span><span>.</span>SET_TO_DEFAULT
    <span>)</span>
    <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span><span>;</span>
 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>위 코드는 각 필드에 대해 null정책을 부여한다. 만약 SET_TO_DEFAULT로 설정하면, List 일때는 빈 ArrayList를 생성해주고, String은 빈문자열, 특정 오브젝트라면 해당 오브젝트의 기본 생성자 등으로 기본값을 생성해준다.</p>
<h4 id="특정-필드-매핑-무시"> 특정 필드 매핑 무시</h4>
<ul>
<li>특정 필드는 매핑되지 않길 원한다면 @Mapping 어노테이션에 ignore = true 속성을 넣어준다.</li>
</ul>
<div><pre><code><span>@Mapper</span><span>(</span>
        unmappedTargetPolicy <span>=</span> <span>ReportingPolicy</span><span>.</span>ERROR<span>,</span>
        nullValueMappingStrategy <span>=</span> <span>NullValueMappingStrategy</span><span>.</span>RETURN_NULL
<span>)</span>
<span>public</span> <span>interface</span> <span>CarMapper</span> <span>{</span>
 
    <span>CarMapper</span> INSTANCE <span>=</span> <span>Mappers</span><span>.</span><span>getMapper</span><span>(</span><span>CarMapper</span><span>.</span><span>class</span><span>)</span><span>;</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"name"</span><span>,</span> target <span>=</span> <span>"modelName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"color"</span><span>,</span> target <span>=</span> <span>"modelColor"</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"price"</span><span>,</span> target <span>=</span> <span>"modelPrice"</span><span>,</span> numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>@Mapping</span><span>(</span>target <span>=</span> <span>"description"</span><span>,</span> ignore <span>=</span> <span>true</span><span>)</span>
    <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span><span>;</span>
 
<span>}</span>
 
<span>public</span> <span>class</span> <span>MapstructTest</span> <span>{</span>
 
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>
        <span>CarDto</span> carDto <span>=</span> <span>CarDto</span><span>.</span><span>of</span><span>(</span>
                <span>"bmw x4"</span><span>,</span>
                <span>"black"</span><span>,</span>
                <span>10000</span><span>,</span>
                <span>"description"</span><span>)</span><span>;</span>
        <span>Car</span> car <span>=</span> <span>CarMapper</span><span>.</span>INSTANCE<span>.</span><span>to</span><span>(</span>carDto<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>car<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
 
result <span>=</span><span>></span>
 
<span>Car</span><span>(</span>modelName<span>=</span>bmw x4<span>,</span> modelColor<span>=</span>black<span>,</span> modelPrice<span>=</span>$<span>10000.00</span><span>,</span> description<span>=</span><span>null</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h4 id="매핑-전처리-후처리"> 매핑 전처리, 후처리</h4>
<ul>
<li>매핑하기 이전과 매핑 이후 특정 로직을 주입시킬 수 있다.</li>
</ul>
<div><pre><code><span>@Mapper</span><span>(</span>
        unmappedTargetPolicy <span>=</span> <span>ReportingPolicy</span><span>.</span>ERROR<span>,</span>
        nullValueMappingStrategy <span>=</span> <span>NullValueMappingStrategy</span><span>.</span>RETURN_NULL<span>,</span>
        componentModel <span>=</span> <span>"spring"</span>
<span>)</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>CarMapper</span> <span>{</span>
 
    <span>@BeforeMapping</span>
    <span>protected</span> <span>void</span> <span>setColor</span><span>(</span><span>CarDto</span> carDto<span>,</span> <span>@MappingTarget</span> <span>Car</span> car<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>carDto<span>.</span><span>getName</span><span>(</span><span>)</span><span>.</span><span>equals</span><span>(</span><span>"bmw x4"</span><span>)</span><span>)</span> <span>{</span>
            car<span>.</span><span>setModelColor</span><span>(</span><span>"red"</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            car<span>.</span><span>setModelColor</span><span>(</span><span>"black"</span><span>)</span><span>;</span>
        <span>}</span>
 
    <span>}</span>
 
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"name"</span><span>,</span> target <span>=</span> <span>"modelName"</span><span>)</span>
    <span>@Mapping</span><span>(</span>target <span>=</span> <span>"modelColor"</span><span>,</span> ignore <span>=</span> <span>true</span><span>)</span>
    <span>@Mapping</span><span>(</span>source <span>=</span> <span>"price"</span><span>,</span> target <span>=</span> <span>"modelPrice"</span><span>,</span> numberFormat <span>=</span> <span>"$#.00"</span><span>)</span>
    <span>public</span> <span>abstract</span> <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span><span>;</span>
 
    <span>@AfterMapping</span>
    <span>protected</span> <span>void</span> <span>setDescription</span><span>(</span><span>@MappingTarget</span> <span>Car</span> car<span>)</span> <span>{</span>
        car<span>.</span><span>setDescription</span><span>(</span>car<span>.</span><span>getModelName</span><span>(</span><span>)</span> <span>+</span> <span>" "</span> <span>+</span> car<span>.</span><span>getModelColor</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
 
<span><span>&lt;</span><span>Generate</span> <span>Code</span><span>></span></span>
 
<span>@Generated</span><span>(</span>
    value <span>=</span> <span>"org.mapstruct.ap.MappingProcessor"</span>
<span>)</span>
<span>@Component</span>
<span>public</span> <span>class</span> <span>CarMapperImpl</span> <span>extends</span> <span>CarMapper</span> <span>{</span>
 
    <span>@Override</span>
    <span>public</span> <span>Car</span> <span>to</span><span>(</span><span>CarDto</span> carDto<span>)</span> <span>{</span>
        <span>if</span> <span>(</span> carDto <span>==</span> <span>null</span> <span>)</span> <span>{</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
 
        <span>Car</span> car <span>=</span> <span>new</span> <span>Car</span><span>(</span><span>)</span><span>;</span>
 
        <span>setColor</span><span>(</span> carDto<span>,</span> car <span>)</span><span>;</span>
 
        car<span>.</span><span>setModelName</span><span>(</span> carDto<span>.</span><span>getName</span><span>(</span><span>)</span> <span>)</span><span>;</span>
        <span>if</span> <span>(</span> carDto<span>.</span><span>getPrice</span><span>(</span><span>)</span> <span>!=</span> <span>null</span> <span>)</span> <span>{</span>
            car<span>.</span><span>setModelPrice</span><span>(</span> <span>new</span> <span>DecimalFormat</span><span>(</span> <span>"$#.00"</span> <span>)</span><span>.</span><span>format</span><span>(</span> carDto<span>.</span><span>getPrice</span><span>(</span><span>)</span> <span>)</span> <span>)</span><span>;</span>
        <span>}</span>
        car<span>.</span><span>setDescription</span><span>(</span> carDto<span>.</span><span>getDescription</span><span>(</span><span>)</span> <span>)</span><span>;</span>
 
        <span>setDescription</span><span>(</span> car <span>)</span><span>;</span>
 
        <span>return</span> car<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>전처리와 후처리를 위한 메서드는 private를 사용해서는 안된다. 그 이유는 generate된 코드에 전, 후 처리 메서드가 들어가는 것이 아니라 추상 클래스에 있는 메서드를 그대로 사용하기 때문이다.</p>
<ul>
<li>공식 레퍼런스
https://mapstruct.org/documentation/stable/reference/html/</li>
</ul>
<br>
<h2 id="_1112-custom-exception-장단점"> 1112 - custom exception 장단점</h2>
<h3 id="표준-예외-사용시-장점"> 표준 예외 사용시 장점</h3>
<ol>
<li>예외 메시지로도 충분히 의미를 전달할 수 있다.</li>
</ol>
<ul>
<li>유효하지 않은 입력값에 대한 예외 같은 경우 자바에서 정의해 놓은 IllegalArgumentException을 사용하고 메시지만 예외사항에 맞게 재정의해준다면 충분히 그 의미를 파악할 수 있다.</li>
</ul>
<ol start="2">
<li>표준 예외를 사용하면 가독성이 높아진다.</li>
</ol>
<ul>
<li>인수로 부적절한 값이 들어올 때 던지는 예외인 IllegalArgumentException, 일을 수행하기에 적합하지 않은 상태의 객체인 경우 던지는 예외인 IllegalStateException, 요청받은 작업을 지원하지 않는 경우에 던지는 예외인 UnsupportedOperationException 등, 우리는 이미 익숙하고, 쓰임에 대해 잘 알고있는 예외들이 많다.<br>
이런 예외들이 아닌 처음 보는 예외들은 당연히 구체적인 쓰임을 잘 모른다. 이런 이유로 낯선 예외보다는 익숙한 예외를 마주치는 것이 당연히 가동성이 높을 수 밖에 없다.<br>
또한, 낯선 예외를 만났을 땐, 당연하게도 그 커스텀 익셉션을 파악하는 작업이 따라온다. 이 또한 비용이 될 수 있다.<br>
표준 예외에 대한 쓰임은 공식문서를 참고하면 된다.
https://docs.oracle.com/javase/8/docs/api/?java/lang/RuntimeException.html</li>
</ul>
<ol start="3">
<li>일일히 예외 클래스를 만들다보면 지나치게 커스텀 예외가 많아질 수 있다.</li>
</ol>
<ul>
<li>많은 domain이 생기고 도메인 별 정의된 custom Exception들이 생길 경우 지나치게 많아질 수 있다. 이 디렉토리와 클래스를 관리하는 것 역시 일이며, 지나치게 많아진다면 메모리 문제도 발생할 수 있고, 클래스 로딩에도 시간이 더 소요될 가능성이 있다.</li>
</ul>
<h3 id="커스텀-예외-사용시-장점"> 커스텀 예외 사용시 장점</h3>
<p>사용자 정의 예외가 필요하다.</p>
<ul>
<li>Spring의 @Valid 어노테이션은 예외 상황에서 MethodArgumentNotValidException을 발생시킨다. 해당 예외의 패키지 구조는 org.springframework.web.bind.MethodArgumentNotValidException 으로 Spring에서 만든 사용자 정의 예외다.</li>
</ul>
<ol>
<li>이름으로도 정보 전달이 가능하다.</li>
</ol>
<ul>
<li>NoSuchElementException 만으로는 어떤 요소가 없는지 알 수 없다. 하지만, PostNotFoundException이 발생했따면, Post를 찾는 요청을 보냈지만 해당 요소가 없다는 상황을 유추할 수 있을 것이다.<br>
이처럼 Custom Exception은 이름을 통해 일차적으로 예외 발생 상황에 대해 유추할 수 있는 정보를 제공한다.</li>
</ul>
<ol start="2">
<li>상세한 예외 정보를 제공할 수 있다.</li>
</ol>
<ul>
<li>컬렉션의 범위를 벗어난 index 접근 요청이 생겼다고 가정했을때, 기존의 예외에선 IllegalArgumentException이나 IndexOutOfBoundsException을 후보로 생각해볼 수 있을 것이다. 예외 메시지로는 &quot;범위를 벗어났습니다.&quot; 정도면 적당하다.</li>
</ul>
<div><pre><code><span>if</span> <span>(</span>index <span>>=</span> arr<span>.</span>length<span>)</span> <span>{</span>
  <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>"범위를 벗어났습니다."</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>하지만 전체 범위가 얼마인지, 요청한 index가 몇인지 파악하기 우해서는 프로그래머가 직접 디버깅하거나 정보를 담은 메시지를 만들어줘야 한다. 디버그르류 통해 직접 정보를 찾아내는 행위는 썩 좋은 일이 아니다. 개발 과정에 피로함만 늘어간다. 메시지는 단 한 곳에서만 발생하는 예외라면 상관없지만 여러 곳에서 발생한다면 리팩토링하기가 힘들어 질 것이다.<br>
이러한 상황에서 사용자 정의 예외는 좋은 해결책이 될 수 있다.</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>IllegalIndexException</span> <span>extends</span> <span>IndexOutOfBoundsException</span> <span>{</span>
	<span>private</span> <span>static</span> <span>final</span> <span>String</span> message <span>=</span> <span>"범위를 벗어났습니다."</span><span>;</span>

	<span>public</span> <span>IllegalIndexException</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span><span>></span></span> target<span>,</span> <span>int</span> index<span>)</span> <span>{</span>
		<span>super</span><span>(</span>message <span>+</span> <span>" size: "</span>  <span>+</span> target<span>.</span><span>size</span><span>(</span><span>)</span> <span>+</span> <span>" index: "</span> <span>+</span> index<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>예를 보면 요청 받은 컬렉션의 최대 범위가 어디까지인지, 요청한 index는 몇인지 확인 가능하다. try/catch를 통해 발생한 예외를 붙잡아 새로 만든 예외를 던져도 되고, 기존 예외가 발생하기 전에 index를 검사해 새로 맏는 예외를 직접 발생시켜도 괜찮다.<br>
전달하는 정보의 수정이 필요할 때는 IllegalIndexException 클래스를 수정하면 된다. 같은 예외를 발생시키는 모든 상황에 적용될 것이다.</li>
</ul>
<ol start="3">
<li>예외에 대한 응집도가 향상된다.</li>
</ol>
<ul>
<li>클래스를 만드는 행위는 관련 정보를 해당 클래스에서 최대한 관리하겠다는 이야기다.<br>
표준예외와 메시지로도 충분히 정보를 전달할 수 있지만, 전달하는 정보의 양이 많아지거나 여러곳에서 발생하는 예외라면 책임소재가 불분명해진다.<br>
사실 정적 메소드를 담은 유틸성 클래스로도 충분히 표준 예외를 사용하면서 이문제를 해결할 수 도 있지만 사용자 정의 예외를 사용한다면 객체의 책임이 분리된 깔끔한 코드를 얻을 수 있다.</li>
</ul>
<ol start="4">
<li>예외 발생 후처리가 용이하다.</li>
</ol>
<ul>
<li>예외는 상속 관계에 있기 때문에, Exception이나 RuntimeException을 잡아두면 프로그램 내에서 발생하는 거의 모든 예외에 대해 처리가 가능하다. 하지만 이는 프로그래머가 의도하지 않은 예외까지 모두 잡아내 혼란을 야기할 수 있다.<br>
재사용성이 높은 것은 표준 예외들의 장점이다. 하지만 그 장점 때문에 발생 위치를 정확하게 파악하기 힘들다는 단점도 생긴다.</li>
</ul>
<ol start="5">
<li>예외 생성 비용을 절감한다.</li>
</ol>
<ul>
<li>자바에서 예외를 생성하는 행위는 생각보다 많은 비용이 소모된다. 바로 stack trace 때문이다.<br>
stack trace는 예외 발생 시 call stack에 있는 메소드 리스트를 저장한다. 이를 통해 예외가 발생한 정확한 위치를 파악할 수 있다. 하지만 try/catch나 Advice를 통해 예외를 처리한다면 해다 예외의 stack trace는 사용하지 않을 때가 많다. 비용을 들여 만들었다지만 사용하지 않고 사라지는 형태, 너무나도 비요율적이다.</li>
</ul>
<p>stack trace의 생성은 예외의 부모 클래스 중 Throwable의 fillInStackTrace() 메소드를 통해 이루어진다. 사용자 정의 예외는 해당 메소드를 Override 함으로 stack trace의 생성 비용을 줄일 수 있다. 필요하다면 짧게 일부만을 생성할 수도, 아예 생성하지 않을 수도 있다.</p>
<div><pre><code><span>@Override</span>
<span>public</span> <span>synchronized</span> <span>Throwable</span> <span>fillInStackTrace</span><span>(</span><span>)</span> <span>{</span>
	  <span>return</span> <span>this</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CustomException</span> <span>extends</span> <span>RuntimeException</span> <span>{</span>
	  <span>public</span> <span>static</span> <span>final</span> <span>CustomException</span> CUSTOM_EXCEPTION <span>=</span> <span>new</span> <span>CustomException</span><span>(</span><span>"대충 예외라는 내용"</span><span>)</span><span>;</span>
	  <span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>만일 구현해 낸 Custom Exception이 stack trace도 갖지 않고, 상황에 따라 정보를 다르게 주는 예외가 아니라 단순하게 메세지만 넘겨준다면 해당 예외를 캐싱해 두는 것도 비용 절감의 방법이다.</li>
</ul>
<br>
<h2 id="_1113-임베디드-타입-embedded-type"> 1113 - 임베디드 타입(embedded type)</h2>
<h3 id="임베디드-타입-복합-값-타입"> 임베디드 타입(복합 값 타입)</h3>
<p>새로운 값 타입을 직접 정의해서 사용할 수 있따. JPA에서는 이것을 임베디드 타입(embedded type)이라 한다. 중요한 것은 직접 정의한 임베디드 타입도 int, String 처럼 값 타입이다.</p>
<h4 id="예제"> 예제</h4>
<ul>
<li>임베디드 타입을 사용하지 않았을 때</li>
</ul>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>
  
  <span>@Id</span> <span>@GeneratedValue</span>
  <span>private</span> <span>Long</span> id<span>;</span>
  <span>private</span> <span>String</span> name<span>;</span>
  
  <span>// 근무 기간</span>
  <span>@Temporal</span><span>(</span><span>TemporalType</span><span>.</span>DATE<span>)</span>
  <span>Date</span> startDate<span>;</span>
  <span>@Temporal</span><span>(</span><span>TemporalType</span><span>.</span>DATE<span>)</span>
  <span>Date</span> endDate<span>;</span>
  
  <span>// 집 주소 표현</span>
  <span>private</span> <span>String</span> city<span>;</span>
  <span>private</span> <span>String</span> street<span>;</span>
  <span>private</span> <span>String</span> zipcode<span>;</span>
  <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>임베디드 타입 사용</li>
</ul>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>
  
  <span>@Id</span> <span>@GeneratedVAlue</span>
  <span>private</span> <span>Long</span> id<span>;</span>
  <span>private</span> <span>String</span> name<span>;</span>
  
  <span>@Embedded</span>
  <span>private</span> <span>Period</span> workPeriod<span>;</span>	<span>// 근무 기간</span>
  
  <span>@Embedded</span>
  <span>private</span> <span>Address</span> homeAddress<span>;</span>	<span>// 집 주소</span>
<span>}</span>

<span>--</span><span>-</span>

<span>@Embeddable</span>
<span>public</span> <span>class</span> <span>Peroid</span> <span>{</span>
  
  <span>@Temporal</span><span>(</span><span>TemporalType</span><span>.</span>DATE<span>)</span>
  <span>Date</span> startDate<span>;</span>
  <span>@Temporal</span><span>(</span><span>TemporalType</span><span>/</span><span>Date</span><span>)</span>
  <span>Date</span> endDate<span>;</span>
  <span>// ...</span>
  
  <span>public</span> <span>boolean</span> isWork <span>(</span><span>Date</span> date<span>)</span> <span>{</span>
    <span>// .. 값 타입을 위한 메서드를 정의할 수 있다</span>
  <span>}</span>
<span>}</span>

<span>--</span><span>-</span>

<span>@Embeddable</span>
<span>public</span> <span>class</span> <span>Address</span> <span>{</span>
  
  <span>@Column</span><span>(</span>name<span>=</span><span>"city"</span><span>)</span> <span>// 매핑할 컬럼 정의 가능</span>
  <span>private</span> <span>String</span> city<span>;</span>
  <span>private</span> <span>String</span> street<span>;</span>
  <span>private</span> <span>String</span> zipcode<span>;</span>
  <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id="임베디드-타입-사용-방법"> 임베디드 타입 사용 방법</h3>
<ul>
<li>@Embeddable : 값 타입을 정의하는 곳에 표시</li>
<li>@Embedded : 값 타입을 사용하는 곳에 표시</li>
<li><code>임베디드 타입은 기본 생성자가 필수</code></li>
</ul>
<p>임베디드 타입을 포함한 모든 값 타입은 엔티티의 생명주기에 의존하므로 엔티티와 임베디드 타입 관계를 UML로 표현 하면 컴포지션(composition) 관계가 된다.</p>
<blockquote>
<p>하이버네이트는 임베디드 타입을 컴포넌트(components)라 한다.</p>
</blockquote>
<p><img src="https://media.vlpt.us/post-images/conatuseus/8c9227f0-1a86-11ea-81c4-6f5e57ac36c2/image.png" alt="uml">
&lt;회원-컴포지션 관계 UML (출처: 김영한님 강의)&gt;</p>
<h3 id="임베디드-타입의-장점"> 임베디드 타입의 장점</h3>
<ul>
<li>재사용</li>
<li>높은 응집도</li>
<li>Period 객체의 isWork() 메서드처럼 해당 값 타입만 사용하는 의미있는 메서드를 만들 수 있다.</li>
</ul>
<h3 id="임베디드-타입과-테이블-매핑"> 임베디드 타입과 테이블 매핑</h3>
<p><img src="https://media.vlpt.us/post-images/conatuseus/a7d7d0a0-1a86-11ea-bdac-0d8b2621ee12/image.png" alt="uml2">
&lt;임베디드 타입을 사용한 회원-테이블 매핑 (출처: 김영한님 강의)&gt;</p>
<p>임베디드 타입은 엔티티의 값일 뿐이다. 따라서 값이 속한 엔티티의 테이블에 매핑되며, 임베디드 타입을 사용하기 전과 후에 매핑되는 테이블은 동일하다.</p>
<p>임베디드 타입 덕분에 객체와 테이블을 아주 세밀하게(fine-grained) 매핑하는 것이 가능하다. 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.</p>
<h3 id="임베디드-타입과-연관관계"> 임베디드 타입과 연관관계</h3>
<p>임베디드 타입은 값 타입을 포함하거나 엔티티를 참조할 수 있다.</p>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>
  
  <span>@Embedded</span>
  <span>Address</span> address<span>;</span>	<span>// 임베디드 타입 포함</span>
  <span>@Embedded</span>
  <span>PhoneNumber</span> phoneNumber<span>;</span>	<span>// 임베디드 타입 포함</span>

  <span>// ...</span>
<span>}</span>


<span>@Embeddable</span>
<span>public</span> <span>class</span> <span>Address</span> <span>{</span>
  <span>String</span> street<span>;</span>
  <span>String</span> city<span>;</span>
  <span>String</span> state<span>;</span>
  <span>@Embedded</span>
  <span>Zipcode</span> zipcode<span>;</span> <span>// 임베디드 타입 포함</span>
<span>}</span>


<span>@Embeddable</span>
<span>public</span> <span>class</span> <span>Zipcode</span> <span>{</span>
  <span>String</span> zip<span>;</span>
  <span>String</span> plusFour<span>;</span>
<span>}</span>


<span>@Embeddable</span>
<span>public</span> <span>class</span> <span>PhoneNumber</span> <span>{</span>
 
  <span>String</span> areaCode<span>;</span>
  <span>String</span> localNumber<span>;</span>
  
  <span>@ManyToOne</span>
  <span>PhoneServiceProvider</span> provider<span>;</span>	<span>// 엔티티 참조</span>
<span>}</span>


<span>@Entity</span>
<span>public</span> <span>class</span> <span>PhoneServiceProvider</span> <span>{</span>
  <span>@Id</span>
  <span>String</span> name<span>;</span>
 	<span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><p>값 타입인 Address가 값 타입인 Zipcode를 포함하고, 값 타입인 PhoneNumber가 엔티티 타입인 PhoneServiceProvider를 참조한다.</p>
<h3 id="attributeoverride-속성-재정의"> @AttributeOverride: 속성 재정의</h3>
<p>임베디드 타입에 정의한 매핑정보를 재정의하려면 엔티티에 @AttributeOverride를 사용하면 된다.</p>
<div><pre><code><span>// 같은 임베디드 타입을 가지고 있는 회원</span>
<span>@Entity</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>
  
  <span>@Id</span> <span>@GeneratedValue</span>
  <span>private</span> <span>Long</span> id<span>;</span>
  <span>private</span> <span>String</span> name<span>;</span>
  
  <span>@Embedded</span>
  <span>Address</span> homeAddress<span>;</span>
  
  <span>@Embedded</span>
  <span>Address</span> companyAddress<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>위 코드의 문제점은 테이블에 매핑하는 컬럼명이 중복된다. 이떄는 아래와 같이 @AttributeOberrides를 사용해서 매핑정보를 재정의해야 한다.</p>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>
  
  <span>@Id</span> <span>@GeneratedValue</span>
  <span>private</span> <span>Long</span> id<span>;</span>
  <span>private</span> <span>String</span> name<span>;</span>
  
  <span>@Embedded</span>
  <span>Address</span> homeAddress<span>;</span>
  
  <span>@Embedded</span>
  <span>@AttributeOverrides</span><span>(</span><span>{</span>
    <span>@AttributeOverride</span><span>(</span>name<span>=</span><span>"city"</span><span>,</span> column<span>=</span><span>@Column</span><span>(</span>name<span>=</span><span>"COMPANY_CITY"</span><span>)</span><span>)</span><span>,</span>
    <span>@AttributeOverride</span><span>(</span>name<span>=</span><span>"street"</span><span>,</span> column<span>=</span><span>@Column</span><span>(</span>name<span>=</span><span>"COMPANY_STREET"</span><span>)</span><span>)</span><span>,</span>
    <span>@AttributeOverride</span><span>(</span>name<span>=</span><span>"zipcode"</span><span>,</span> column<span>=</span><span>@Column</span><span>(</span>name<span>=</span><span>"COMPANY_ZIPCODE"</span><span>)</span><span>)</span>
  <span>}</span><span>)</span>
  <span>Address</span> companyAddress<span>;</span>
<span>}</span>

<span>// 생성된 테이블</span>
<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>
CREATE <span>TABLE</span> MEMBER <span>(</span>
	<span>COMPANY_CITY</span> <span>varchar</span><span>(</span><span>255</span><span>)</span><span>,</span>
  <span>COMPANY_STREET</span> <span>varchar</span><span>(</span><span>255</span><span>)</span><span>,</span>
  <span>COMPANY_ZIPCODE</span> <span>varchar</span><span>(</span><span>255</span><span>)</span><span>,</span>
  city <span>varchar</span><span>(</span><span>255</span><span>)</span><span>,</span>
  street <span>varchar</span><span>(</span><span>255</span><span>)</span><span>,</span>
  zipcode <span>varchar</span><span>(</span><span>255</span><span>)</span><span>,</span>
  <span>.</span><span>.</span><span>.</span>
<span>)</span>
<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>@AttributeOverrides는 엔티티에 설정해야 한다. 임베디드 타입이 임베디드 타입을 가지고 있어도 엔티티에 설정해야 한다.</p>
<h3 id="임베디드-타입과-null"> 임베디드 타입과 Null</h3>
<p>임베디드 타입이 null이면 매핑한 컬럼 값은 모두 null이 된다.</p>
]]></content:encoded>
      <enclosure url="https://media.vlpt.us/post-images/conatuseus/8c9227f0-1a86-11ea-81c4-6f5e57ac36c2/image.png" type="image/png"/>
    </item>
    <item>
      <title>1115 - 1124</title>
      <link>ahnjs/TIL/2021/1115/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1115/</guid>
      <source url="ahnjs/TIL/rss.xml">1115 - 1124</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1115-1124"> 1115 - 1124</h1>
<h2 id="_1115-상속과-컴포지션"> 1115 - 상속과 컴포지션</h2>
<h3 id="상속과-composite-조합-이란"> 상속과 composite(조합) 이란?</h3>
<h4 id="상속"> 상속</h4>
<ul>
<li>IS-A관계로 정의될 수 있으며, 부모클래스를 '확장'하는 개념이다.</li>
<li>상속을 받은 자식클래스는, 부모클래스의 변수와 메소드에 접근이 가능하고, 메소드를 재정의 할 수 있다. (생성자, static블록은 상속되지 않으며, private 선언자는 접근이 불가능하고, final선언자는 재정의가 불가능하다.)</li>
</ul>
<h4 id="컴포지션-조합"> 컴포지션(조합)</h4>
<ul>
<li>HAS-A 관계로 정의될 수 있으며, 기존 클래스가 새로운 클래스의 구성요소가 되는 것이다.</li>
<li>기존에 존재하는 객체를 멤버변수로 이용, 새로운 객체를 구현하는 방법</li>
</ul>
<h3 id="상속의-단점"> 상속의 단점</h3>
<ol>
<li>캡슐화를 위반한다.
<ul>
<li>상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있기 때문이다.</li>
<li>상위 클래스의 내부 구현이 달라지면 하위 클래스를 고쳐야할 수 있다.</li>
</ul>
</li>
<li>설계가 유연하지 못하다.
<ul>
<li>컴파일 시점에 객체의 Type이 정해지기 때문이다.</li>
</ul>
</li>
<li>다중상속
<ul>
<li>자바는 다중상속이 불가능하다.</li>
<li>따라서 다른 클래스를 상속받고있다면 추가적으로 상속을 받을 수 없다.</li>
</ul>
</li>
</ol>
<br>
<h2 id="_1116-왜-jpa의-entity는-기본-생성자를-가져야-하는가"> 1116 - 왜 JPA의 Entity는 기본 생성자를 가져야 하는가?</h2>
<blockquote>
<p>정확히 말하자면 Entity는 반드시 파라미터가 없는 생성자가 있어야 하고, 이것은 public 또는 protected이어야 한다.</p>
</blockquote>
<h4 id="setter의-제한"> setter의 제한</h4>
<p>Entity의 모든 필드에 public setter 메소드를 생성하는 것은 객체의 값의 변경을 열어두기 때문에 일관성을 보장할 수 없다. 또한 단순히 setter이기 때분에 그 의도를 쉽게 파악할 수 없다. setter 메소드를 제공하는 것 보단 확실한 비즈니스가 드러나는 메소드를 제공하는 것이 더 욱 바람직하다.</p>
<h3 id="java-reflection-api"> Java Reflection API</h3>
<blockquote>
<p>Java Reflection API란?<br>
구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 Java API</p>
</blockquote>
<p>이러한 Java Reflection을 활용하면 컴파일 시점이 아닌 런타임 시점에 동적으로 클래스를 객체화하여 분석 및 추출할 수 있는 프로그래밍 기법이다.</p>
<p>자세한 내용은 woowacourse.github.io/javable/post/2020-07-16-reflection-api/ 을 참고</p>
<p>JPA는 DB값을 객체 필드에 주입할 때 기본 생성자로 객체를 생성한 후 이러한 Reflection을 사용하여 값을 매핑하기 때문이다.</p>
<h3 id="proxy-객체"> Proxy 객체</h3>
<p>JPA는 매핑한 Entity를 조회할 때 두 가지 전략을 사용한다. 조회 시점에 함께 가져오는 EAGER와 매핑한 Entity를 사용할 때 조회하는 LAZY가 있다.</p>
<p>이러한 LAZY, 지연로딩을 사용할 경우에는 매핑한 Entity의 대상 객체에 proxy 객체가 들어있다.</p>
<blockquote>
<p>정리<br>
정리하면 JPA의 구현체인 hibernate에서 제공하는 다양한 기능을 활용하기 위해서는 public이나 protected 기본 생성자가 필요하다. private로 생성자를 만들게 되면 이러한 기능들을 사용하는데 제약이 되기 때문이다. 다만 안정성 측면에서 좀더 작은 scope를 가진 protected 기본 생성자를 주로 사용한다.</p>
</blockquote>
<br>
<h2 id="_1117-좋은-커밋-메세지-작성하기위한-규칙"> 1117 - 좋은 커밋 메세지 작성하기위한 규칙</h2>
<p>글작성전에 정답은 없으며 협업이나 일관성있게 관리하기 위해 컨벤션을 적용한다.</p>
<p>AngularJS Git Commit Message Conventions 참고하여 작성</p>
<h3 id="커밋-메시지의-7가지-규칙"> 커밋 메시지의 7가지 규칙</h3>
<ol>
<li>제목과 본문을 빈 행으로 구분한다.</li>
<li>제목을 50글자 내로 제한한다.</li>
<li>제목 첫 글자는 대문자로 작성한다.</li>
<li>제목 끝에 마침표 넣지 않기</li>
<li>제목은 명령문으로 사용하며 과거형을 사용하지 않는다.</li>
<li>본문의 각 행은 72글자 내로 제한한다.</li>
<li>어떻게 보다는 무엇과 왜를 설명한다.</li>
</ol>
<h3 id="커밋-메시지-구조"> 커밋 메시지 구조</h3>
<ul>
<li>헤더는 필수이며, 범위(scope), 본문(body), 바닥글(footer)은 선택사항이다.</li>
</ul>
<div><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;          -- 헤더
&lt;BLANK LINE&gt;
&lt;body&gt;                              -- 본문
&lt;BLANK LINE&gt;
&lt;footer&gt;                            -- 바닥글
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><type>은 해당 커밋의 성격을 나타내며 아래 중 하나여야 한다.</li>
</ul>
<div><pre><code>feat : 새로운 기능에 대한 커밋
fix : 버그 수정에 대한 커밋
build : 빌드 관ㄹ녀 파일 수정에 대한 커밋
chore : 그 외 자잘한 수정에 대한 커밋
ci : CI관련 설정 수정에 대한 커밋
docs : 문서 수정에 대한 커밋
style : 코드 스타일 혹은 포맷 등에 관한 커밋
refactor : 코드 리팩토링에 대한 커밋
test : 테스트 코드 수정에 대한 커밋
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>1129 - 1205</title>
      <link>ahnjs/TIL/2021/1129/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1129/</guid>
      <source url="ahnjs/TIL/rss.xml">1129 - 1205</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1129-1205"> 1129 - 1205</h1>
<h2 id="_1129-webhook"> 1129 - Webhook</h2>
<h3 id="webhook-웹훅-이란"> Webhook(웹훅)이란?</h3>
<p>웹훅은 웹페이지 또는 웹앱에서 발생하는 특정 행동(이벤트)들을 커스텀 Callback으로 변환해주는 방법이다. 일반적인 API(Polling)는 클라이언트가 서버를 호출하는 방식이다. 하지만 웹훅의 경우 서버에서 특정 이벤트가 발생했을 때 클라이언트를 호출하는 방식이며 &quot;역방향 API&quot;라고도 부른다.</p>
<blockquote>
<p>callback URL은 서버측에서 이벤트가 발생했을 때 클라이언트의 어느 URL로 데이터를 보낼지 정해놓은 주소라고 생각하면 된다.</p>
</blockquote>
<h4 id="webhook을-사용하는-이유"> Webhook을 사용하는 이유</h4>
<p>Polling과 비교하여 API 요청 횟수가 적어지기 때문에 효율적</p>
<h4 id="webhook-구현시-유의해야할-점"> Webhook 구현시 유의해야할 점</h4>
<ul>
<li>웹훅으로부터 오는 데이터가 유실될 경우</li>
<li>웹훅으로 부터 오는 요청에 대하여 처리를 완료하였으나 response를 제대로 보내지 못했을 경우</li>
</ul>
<p>와같은 상황을 올바른 예외처리로 해결.</p>
<h4 id="webhook-vs-api"> Webhook vs API</h4>
<ul>
<li>데이터를 수신하는 방식의 차이
: 웹훅은 공급자가 데이터를 애플리케이션에 보낼 수 있으며, 푸시라고도 부를 수 있고 역 API라고 부르는 이유이다.</li>
</ul>
<br>
<h2 id="_1201-jcp-jsr-jep"> 1201 - JCP JSR JEP</h2>
<ul>
<li>
<p>JCP (Java Community Process)<br>
: 자바 기술에 대한 표준 기술 명세를 개발하는 메커니즘.</p>
</li>
<li>
<p>JSR (Java Specification Requests)<br>
: 자바 요구 사항 상세 명세서</p>
</li>
<li>
<p>JEP (JDK Enhancement Proposal)<br>
: Java Development Kit와 OpenJDK를 향상된 기능에 대한 제안을 수집하기 위해 오라클이 초안을 작성하는 프로세스. JDK 출시와 장기적인 로드맵 역할을 함</p>
</li>
</ul>
<br>
<h2 id="_1202-동시성과-병렬성"> 1202 - 동시성과 병렬성</h2>
<h3 id="동시성"> 동시성</h3>
<p>동시성은 적어도 두 개의 스레드가 진행 중일 때 존재하는 조건이며, 가상 병렬 처리의 한 형태로 시간 분할(time-slicing)을 포함한다. 우리가 흔히 '동시'라고 이야기 하지만 컴퓨터(코어)는 한번에 하나의 명령어만 처리할 수 있따. 즉, 두개 이상의 알고리즘이 하나의 코어내에서 스레드간에 빠르게 교차되면서 실행되기 때문에 '동시'라고 느끼는 것이다. 스레드간 교최더며 실행되는 부분을 Context Switching(문맥교환)이라고 한다.</p>
<ul>
<li>동시에 실행되는 것 같이 보이는 것</li>
<li>싱글 코어에서 멀티 쓰레드(Multi thread)를 동작 시키는 방식</li>
<li>한번에 많은 것을 처리</li>
<li>논리적인 개념</li>
</ul>
<h3 id="병렬성"> 병렬성</h3>
<p>병렬성을 이야기하려면 적어도 2개 이상의 코어가 있어야 한다. 병렬성도 동시성을 의미하지만 동시성과의 차이는 각 코어내의 스레드가 실제로 동시에 명령어를 실행할 수 있음을 말한다. 그러므로 두개의 알고리즘이 정확히 같은 시점에 실행될 때 이를 병렬적이라고 말할 수 있다.</p>
<ul>
<li>실제로 동시에 여러 작업이 처리되는 것</li>
<li>멀티 코어에서 멀티 쓰레드를 동작시키는 방식</li>
<li>한번에 많은 일을 처리</li>
<li>물리적인 개념</li>
</ul>
<p>비동기화함께 다시한번 정리할 것</p>
]]></content:encoded>
    </item>
    <item>
      <title>1122 - 1128</title>
      <link>ahnjs/TIL/2021/1122/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1122/</guid>
      <source url="ahnjs/TIL/rss.xml">1122 - 1128</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1122-1128"> 1122 - 1128</h1>
<h2 id="_1122-tostring을-항상-재정의하라"> 1122 - toString을 항상 재정의하라</h2>
<h3 id="tostring"> toString()</h3>
<p>Object의 기본 toString메서드는 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다. 이 메서드는 <code>클래스_이름@16진수로_표현한_해시코드</code>를 반환한다.</p>
<h3 id="tostring-을-재정의-해야-하는-이유"> toString()을 재정의 해야 하는 이유</h3>
<p>equals와 hashCode 규약 만큼 대단히 중요하진 않지만, toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다. toString 메서드는 객체를 println, printf, 문자열 연결 연산자(+), assert 구문에 넘길 때, 혹은 디버거가 객체를 출력할 때 자동으로 불린다. 여러분이 직접 호출하지 않더라도 다른 어딘가에서 쓰인다. 예를들어 객체를 참조하는 컴포넌트가 오류 페이지를 로딩할 때 자동으로 호출 될 수 있다. 이때 toString을 제대로 재정의하지 않는다면 쓸모없는 메시지만 로그에 남는다.</p>
<h3 id="tostring-재정의시-주의-사항"> toString 재정의시 주의 사항</h3>
<ul>
<li>실전에서 toString은 그 객체가 가진 주요 정보를 모두 반환하는게 좋다.
<ul>
<li>하지만 객체가 거대하거나 객체의 상태의 문자열로 표현하기 어렵다면, 요약 정보를 담아야한다.</li>
</ul>
</li>
<li>toString을 구현할 때면 반환값의 포맷을 문서화할지 정해야 한다.
<ul>
<li>포맷을 명시하면 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li>
<li>다만, 포맷을 한번 명시하면 얽매이게 된다.</li>
</ul>
</li>
<li>포맷을 명시하든 아니든 의도는 명확히 밝혀야 한다.</li>
</ul>
<div><pre><code><span>/** * 이 약물에 관한 대략적인 설명을 반환한다. * 다음은 이 설명의 일반적인 형태이나, * 상세 형식은 정해지지 않았으며 향후 변경될 수 있다. * * "[약물 #9: 유형=사랑, 냄새=테레빈유, 겉모습=먹물]" */</span> <span>@Override</span> <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>정적 유틸리티 클래스는 toString을 제공할 이유가 없고, 대부분의 결거 타입도 자바가 이미 완벽한 toString을 제공하니 따로 재정의하지 않아도 된다.
<ul>
<li>하지만, 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상 클래스라면 toString을 재정의 해줘야 하며, 대다수 컬렉션 구현체는 추상 컬렉션 클래스들의 toStirng메서드를 상속해서 사용한다.</li>
</ul>
</li>
</ul>
<h2 id="_1123-crudrepository-vs-jparepository"> 1123 - CrudRepository vs JpaRepository</h2>
<p><img src="https://blog.kakaocdn.net/dn/HqURy/btq9aM1qvwy/Difw4KKvjTyCcGUcxKahok/img.png" alt="image">
위 상속관계를 살펴보면, 최상위 부모인 Repository를 CrudRepository가 상속받아 확장시키고, 이를 PagingAndSortingRepository가, 그리고 이를 또 JpaRepository가 상속받아 확장시킨 것을 볼 수 있다.</p>
<p>각각 소스코드를 IDE를 통해 상세히 살펴볼 수 있지만, 구조상으로 JpaRepository의 구현체들이 당연히 더 많다. 사용하고자 하는 도메인이 어느 정도의 수준까지 필요한가에 따라 사용.</p>
<ul>
<li>CrudRepository : CRUD 관련 기능을 제공. (간단한 CRUD만 필요한 경우)</li>
<li>PagingAndSortingRepository : 페이징과 솔팅을 추가로 제공.</li>
<li>JpaRepository : 위 기능은 물론 JPA 관련 특화된 기능(지속성 컨텍스트 플러시 및 배치에서 레코드 삭제)들을 제공.</li>
</ul>
<h2 id="_1124-maven-다중모듈-의존성"> 1124 - Maven 다중모듈, 의존성</h2>
<h3 id="maven환경-다중-모듈-프로젝트-생성"> Maven환경 다중 모듈 프로젝트 생성</h3>
<ol>
<li>parent 프로젝트 생성
<ul>
<li>Maven Project로 생성</li>
<li>packaging : pom</li>
</ul>
</li>
<li>'Parent'의 pom을 상속받는 프로젝트 생성
<ul>
<li>Maven Module로 생성</li>
<li>Parent 를 1에서 정의한 프로젝트로 설정</li>
</ul>
</li>
</ol>
<p>=&gt; 하위 프로젝트는 parent에서 정의한 pom.xml(dependency, repository 등등..) 을 그대로 사용할 수 있다.</p>
<h3 id="다중-모듈간-클래스-사용"> 다중 모듈간 클래스 사용</h3>
<ul>
<li>별다른 설정 필요 없이, 둘다 Maven 프로젝트이며 같은 Workspace안에 있을 경우 Dependency로 추가</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span> 
    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.mypjt<span><span><span>&lt;/</span>groupId</span><span>></span></span> 
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>myProjectA<span><span><span>&lt;/</span>artifactId</span><span>></span></span> 
    <span><span><span>&lt;</span>version</span><span>></span></span>0.0.1-SNAPSHOT<span><span><span>&lt;/</span>version</span><span>></span></span> 
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><br>
<h2 id="_1125-spring-bean-lifecycle-스프링-빈-생명주기"> 1125 - Spring Bean LifeCycle(스프링 빈 생명주기)</h2>
<h3 id="빈-생명주기-콜백"> 빈 생명주기 콜백</h3>
<p>데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.</p>
<p>스프링 빈도 위와 같은 원리로 초기화 작업과 종료 작업이 나눠서 진행된다.<br>
간단하게 말하면 <code>객체 생성 -&gt; 의존관계 주입</code>이라는 라이프사이클을 가진다.</p>
<p>즉, 스프링 빈은 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.</p>
<h4 id="spring-의존관계-주입-과정"> Spring 의존관계 주입 과정</h4>
<ul>
<li>가장 처음에는 Spring IoC 컨테이너가 먼저 만들어지는 과정이 일어난다.
<ul>
<li>Component-Scan으로 Bean을 등록한다.</li>
<li>@Configuration, @Controller, @Service 등등 Bean으로 등록할 수 있는 어노테이션들과 설정파일들을 읽어 IoC 컨테이너 안에 Bean으로 등록한다.</li>
</ul>
</li>
<li>의존 관계를 주입하기 전의 준비 단계까 존재하는데, 이 단계에서 객체의 생성이 일어난다.
<ul>
<li>생성자 주입: 객체의 생성과 의존관계 주입이 동시에 일어난다.</li>
<li>setter, Field 주입: 객체의 생성 -&gt; 의존관계 주입으로 라이프 사이클이 나누어진다.</li>
</ul>
</li>
</ul>
<h4 id="스프링-의존관계-주입이-완료된-시점을-어떻게-알-수-있을까"> 스프링 의존관계 주입이 완료된 시점을 어떻게 알 수 있을까?</h4>
<p>Bean으로 등록된 객체들은 의존관계 주입이 완료된 후에 초기화 작업을 진행해야 한다.</p>
<ul>
<li>스프링의 Bean LifeCycle</li>
</ul>
<div><pre><code>스프링 컨테이너 생성 -&gt; 스프링 빈 생성 -&gt; 의존관계 주입 -&gt; 초기화 콜백 -&gt; 사용 -&gt; 소멸 전 콜백 -&gt; 스프링 종료
</code></pre>
<div><span>1</span><br></div></div><p>스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메소드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 제공한다.</p>
<ul>
<li>초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출</li>
<li>소멸전 콜백 : 빈이 소멸되기 직전에 호출</li>
</ul>
<blockquote>
<p>객체의 생성과 초기화를 분리하자<br>
생성자는 필수 정보를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다.<br>
따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다.</p>
</blockquote>
<h3 id="빈-생명주기-콜백-지원-방법"> 빈 생명주기 콜백 지원 방법</h3>
<ul>
<li>인터페이스(InitializaingBean, DisposableBean)</li>
<li>설정 정보에 초기화 메소드, 종료 메소드 지정</li>
<li>@PostConstruct, @PreDestroy 어노테이션 지원</li>
</ul>
<h4 id="_1-인터페이스-initializaingbean-disposablebean"> 1. 인터페이스(InitializaingBean, DisposableBean)</h4>
<ul>
<li>상속을 통한 생명주기 콜백 지원</li>
<li>InitializaingBean -&gt; afterPropertiesSet 메소드로 초기화 지원</li>
<li>DisposableBean -&gt; destroy 메소드로 소멸을 지원</li>
<li>초기화, 소멸메서드의 이름을 변경 할 수 없다.</li>
<li>외부 라이브러리에 적용 할 수 없다.</li>
<li>현재 거의 사용하지 않는다.</li>
</ul>
<h4 id="_2-postconstruct-predestory-어노테이션"> 2. @PostConstruct, @PreDestory 어노테이션</h4>
<ul>
<li>최신 스프링에서 가장 권장하는 방법.</li>
<li>컴포넌트 스캔과 잘어울림.</li>
<li>javax.annotation.PostConstruct 패키지로, 스프링 종속 X, 자바 표준</li>
</ul>
<h4 id="_3-빈-등록-초기화-소멸-메소드-지정"> 3. 빈 등록 초기화, 소멸 메소드 지정</h4>
<ul>
<li>설정 정보에 <code>@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;close&quot;)</code>처럼 초기화, 소멸 메소드를 지정</li>
</ul>
<br>
<h2 id="_1127-filter-interceptor-aop-차이"> 1127 - Filter, Interceptor, AOP 차이</h2>
<ul>
<li>공통 프로세스에 대한 처리
<ul>
<li>로그인 관련(세션체크)처리, 권한체크, XSS방어, pc와 모바일웹의 분기처리, 로그, 페이지 인코딩 변환 등</li>
</ul>
</li>
<li>스프링에서 사용되는 Filter, Interceptor, AOP 세 가지 기능은 모두 무슨 행동을 하기전에 먼저 실행하거나, 실행한 후에 추가적인 행동을 할 때 사용되는 기능Handler들이다.</li>
<li>순서</li>
</ul>
<div><pre><code>Filter -&gt; Interceptor -&gt; AOP -&gt; Interceptor -&gt; Filter

1. 서버를 실행시켜 서블릿이 올라오는 동안에 init이 실행되고, 그 후 doFilter가 실행된다.
2. 컨트롤러에 들어가기 전 preHandler가 실행된다.
3. 컨트롤러에서 나와 postHandler, after Completion, doFilter 순으로 진행이 된다.
4. 서블릿 종료 시 destroy가 실행된다.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>Filter와 Interceptor는 Servlet 단위에서 이루어진다. 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.</li>
<li>실행순서를 보면 Filter가 가장 밖에 있고 그안에 Interceptor, 그안에 AOP가 있는 형태이다.</li>
</ul>
<h3 id="_1-filter-필터"> 1. Filter(필터)</h3>
<p>말 그대로 요청과 응답을 거른뒤 정제하는 역할을 한다.<br>
서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러가지 체크를 수행할 수 있다.<br>
또한 자원의 처리가 끝난 후 응답내용에 대해서도 변경하는 처리를 할 수가 있다.</p>
<h4 id="실행-메서드"> 실행 메서드</h4>
<ul>
<li>init() - 필터 인스턴스 초기화</li>
<li>doFilter() - 전/후 처리</li>
<li>destroy() - 필터 인스턴스 종료</li>
</ul>
<h3 id="_2-interceptor-인터셉터"> 2. Interceptor(인터셉터)</h3>
<p>요청에 대한 작업 전/후로 가로챈다.<br>
필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 하지만 인터셉터는 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대한 처리를한다.<br>
스프링의 모든 빈 객체에 접근할 수 있다.<br>
인터셉터는 여러 개를 사용할 수 있고 로그인 체크, 권한체크, 프로그램 실행시간 계산작업 로그확인 등의 업무처리</p>
<h4 id="실행-메서드-2"> 실행 메서드</h4>
<ul>
<li>preHandler() - 컨트롤러 메서드가 실행되기 전</li>
<li>postHandler() - 컨트롤러 메서드 실행직 후 view페이지 렌더링 되기 전</li>
<li>afterCompletion() - view페이지가 렌더링 되고 난 후</li>
</ul>
<h3 id="_3-aop"> 3. AOP</h3>
<p>OOP를 보완하기 위해 나온 개념<br>
객체지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.<br>
주로 로깅, 트랜잭션, 에러처리 등 비지니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용한다.</p>
<p>Interceptor나 Filter와 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다. Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.</p>
<p>AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이다. Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다. 반면 HandlerInterceptor는 Filter와 유사하가 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다.</p>
<h4 id="aop의-포인트컷"> AOP의 포인트컷</h4>
<ul>
<li>@Before: 대상 메서드의 수행 전</li>
<li>@After: 대상 메서드의 수행 후</li>
<li>@Atter-returning: 대상 메서드의 정상적인 수행 후</li>
<li>@After-throwing: 예외발생 후</li>
<li>@Around: 대상 메서드의 수행 전/후</li>
</ul>
]]></content:encoded>
      <enclosure url="https://blog.kakaocdn.net/dn/HqURy/btq9aM1qvwy/Difw4KKvjTyCcGUcxKahok/img.png" type="image/png"/>
    </item>
    <item>
      <title>1206 - 1212</title>
      <link>ahnjs/TIL/2021/1206/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1206/</guid>
      <source url="ahnjs/TIL/rss.xml">1206 - 1212</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1206-1212"> 1206 - 1212</h1>
<h2 id="_1206-git-revert-reset"> 1206 - git revert, reset</h2>
<h3 id="reset"> reset</h3>
<p>reset은 특정 사건으로 되돌아가게 되는데 과거로 되돌아 갔으니 해당 사건 이후의 사건들은 모두 사라진다. 과거의 이력이 커밋에 남지 않고, revert는 특정 사건을 revert했다는 이력이 커밋에 남게 된다.</p>
<div><pre><code>git reset &lt;옵션&gt; &lt;돌아가고싶은 커밋id&gt;

ex)
git reset --soft abcdef
git reset --mixed abcdef  (옵션 작성안할 시 기본값)
git reset --hard abcdef 
git reset HEAD~10 (현재부터 10개 이전으로 복원)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="revert"> revert</h3>
<p>revert는 특정 사건을 골라서 없던일로 만든다. 또한 특정 사건을 취소하지만 revert를 했다는 이력이 남게된다.</p>
<div><pre><code>git revert &lt;취소할 commit&gt;
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_1207-transactional"> 1207 - @Transactional</h2>
<p>스프링에서 지원하는 선언적 트랜잭션. java config를 통해 설정 할 수 있다. Spring boot에서는 별도의 설정이 필요 없으며, 클래스 또는 메소드에 선언할 수 있다.</p>
<h3 id="transactional-옵션"> @Transactional 옵션</h3>
<ul>
<li>propagation : 트랜잭션 동작 도중 다른 트랙잭션을 호출할 때, 어떻게 할 것인지 지정하는 옵션.</li>
<li>isolation : 트랜잭션에서 일관성없는 데이터 허용 수준을 설정.</li>
<li>noRollbackFor=Exception.class : 특정 예외 발생 시 rollback하지 않는다.</li>
<li>rollbackFor=Exception.class : 특정 예외 발생시 rollback한다.</li>
<li>timeout : 지정한 시간 내에 메소드 수행이 완료되지 않으면 rollback한다. (-1일 경우 timeout을 사용하지 않는다)</li>
<li>readOnly : 트랜잭션을 읽기 전용으로 설정한다.</li>
</ul>
<h4 id="_1-propagation"> 1. propagation</h4>
<ul>
<li>REQUIRED (Default) : 이미 진행중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 진행중이 아니라면 새로운 트랜재셕을 생성한다.</li>
<li>REQUIRES_NEW : 항상 새로운 트랜잭션을 생성한다. 이미 진행중인 트랜잭션이 있다면 잠깐 보류하고 해당 트랜잭션 작업을 먼저 진행한다.</li>
<li>SUPPORT : 이미 진행 중인 트랜잭션이 있다면 해당 트랜잭션 속성을 따르고, 없다면 트랜잭션을 설정하지 않는다.</li>
<li>NOT_SUPPORT : 이미 진행중인 트랜잭션이 있따면 보류하고, 트랜잭션 없이 작업을 수행한다.</li>
<li>MANDATORY : 이미 진행중인 트랙잭션이 있어야만, 작업을 수행한다. 없다면 Exception을 발생시킨다.</li>
<li>NEVER : 트랜잭션이 진행중이지 않을 때 작업을 수행한다. 트랜잭션이 있다면 Exception을 발생시킨다.</li>
<li>NESTED : 진행중인 트랜잭션이 있다면 중첩된 트랜잭션이 실행되며, 존재하지 않으면 REQUIRED와 동일하게 실행된다.</li>
</ul>
<h4 id="_2-isolation"> 2. isolation</h4>
<ul>
<li>Default : 사용하는 DB 드라이버의 디폴트 설정을 따른다. 대부분 READ_COMMITED를 기본 격리수준으로 설정한다.</li>
<li>READ_UNCOMMITED : 가장 낮은 격리 수준이다. 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출된다. 하지만 속도가 빠르기 때문에 데이터의 일광성이 떨어지더라도, 성능 극대화를 위해 의도적으로 사용하기도 한다.</li>
<li>READ_COMMITED : 트랜잭션이 커밋하지 않은 정보를 읽을 수 없다. 하지만 트랜잭션이 읽은 로우를 다른 트랜잭션에서 수정 할 수 있다. 그래서 트랜잭션이 같은 로우를 읽었어도 시간에 따라서 다른 내용이 발견될 수 있다.</li>
<li>REPEATABLE_READ : 트랜잭션이 읽은 로우를 다른 트랜잭션에서 수정되는 것을 막아준다. 하지만 새로운 로우를 추가하는 것은 제한하지 않는다.</li>
<li>SERIALIZABLE : 가장 강력한 트랜잭션 격리수준이다. 여러 트랜잭션이 동시에 같은 테이블 로우에 액세스하지 못하게 한다. 가장 안전하지만 가장 성능이 떨어진다.</li>
</ul>
<h4 id="_3-rollbackfor"> 3. rollbackFor</h4>
<p>트랜잭션 작업 중 런타임 예외가 발생하면 롤백한다. 반면에 예외가 발생하지 않거나 체크 예외가 발생하면 커밋한다.<br>
체크 예외를 커밋 대상으로 삼는 이유는 체크 예외가 예외적인 상황에서 사용되기 보다는 리턴 값을 대신해서 비지니스 적인 의미를 담은 결과로 돌려주는 용도로 사용되기 때문이다.<br>
스프링에서는 데이터 엑세스 기술의 예외를 런타임 예외로 전환에서 던지므로 런타임 예외만 롤백대상으로 삼는다.<br>
하지만 원한다면 체크예외지만 롤백 대상으로 삼을 수 있다. rollbackFor 또는 rollbackForClassName 속성을 이용해서 예외를 지정한다.</p>
<h4 id="_4-norollbackfor"> 4. noRollbackFor</h4>
<p>런타임 예외가 발생해도 지정한 런타임 예외면 커밋을 진행한다.</p>
<h4 id="_5-timeout"> 5. timeout</h4>
<p>트랜잭션에 제한시간을 지정한다. 초 단위로 지정하고, 티폴트 설정으로 트랜잭션 시스템의 제한시간을 따른다. -1 입력 시, 트랜잭션 제한시간을 사용하지 안흔다.</p>
<h4 id="_6-readonly"> 6. readOnly</h4>
<p>트랜잭션을 읽기 전용으로 설정한다. 특정 트랜잭션 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용된다. insert, update, delete 작업이 진행되면 예외가 발생한다.</p>
<br>
<h2 id="_1208-responseentity"> 1208 - ResponseEntity</h2>
<p>Spring4 이상부터 @Controller와 @ResponseBody를 합쳐놓은 @RestController를 지원하기에 기본적으로 ResponseBody로 리턴하고 있다.</p>
<p>ResponseEntity는 일반적으로 하는 역할을 동일하나 ResponseEntity로 리턴하는 경우는 본문정보와 헤더 정보, HTTP 상태코드를 좀더 세밀하게 개발자가 처리하기 수월해지며, HATEOAS, builder패턴 등을 활용해서 개발하기 용이하다.</p>
<h4 id="responsebody-responseentity"> ResponseBody / ResponseEntity<T></h4>
<div><pre><code>@GetMapping(value = &quot;/board/{id}&quot;) //@ResponseBody
public Board getBoard(@PathVariable int id) {
    Board board = boardService.selectBoard(id);
    return board;
}

@GetMapping(value = &quot;/board/{id}&quot;)
ResponseEntity&lt;Board&gt; getBoard(@PathVariable int id) {
    Board board = boardService.selectBoard(id);
    return new ResponseEntity&lt;Board&gt;(board, HttpStatus.OK);
    //return ResponseEntity.ok().body(board);
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>HATEOAS (Hypermedia As The Engine Of Application State)
HATEOAS는 독립된 시스템에서 클라이언트서버가 RESTful하게 디자인 된 API서버에 의해 동적으로 상호작용이 가능하다. 쉽게 말하면 클라이언트가 서버에 요청시 서버는 header에 POST, GET, PUT, DELETE 등 URI를 동적으로 설정하고 response를 한다.</li>
</ul>
<p>그러면 클라이언트에서 서버에서 받은 URI로 적용해서 호출한다면, API서버에서 URI가 변경되어도 클라이언트는 호출URI를 변경할 필요가 없다. 또한 권한에 따른 URI를 제안을 할 수 있다. 그리고 클라이언트는 본문응답과 URI정보를 통해서 요청한 후에 해당 리소스에 대해 예측가능하게 한다.</p>
<br>
<h2 id="_1209-uri-url"> 1209 - URI &amp; URL</h2>
<blockquote>
<p>자원의 식별자(URI), 위치(URL), 이름(URN)</p>
</blockquote>
<p><img src="https://media.vlpt.us/images/jch9537/post/51dcc312-8ecb-4048-80df-cbde40865e7a/image.png" alt="diagram"></p>
<h3 id="uri-uniform-resource-identifier"> URI(Uniform Resource Identifier)</h3>
<p>URI는 인터넷에 있는 자원을 나타내는 유일한 주소. URI의 존재는 인터넷에서 요구되는 기본조건으로서 인터넷 프로토콜에 항상 붙어다닌다. 하위 개념으로 URL, URN이 있다.</p>
<h3 id="url-uniform-resource-locator"> URL(Uniform Resource Locator)</h3>
<p>URL은 네트워크상에서 자원이 어디 있는지를 알려주기 위한 규약이다. 즉, 컴퓨터 네트워크와 검색 메커니즘에서의 위치를 지정하는, 웹 리소스에 대한 참조이다. 흔히 웹 사이트 주소로 알고 있지만, URL은 웹 사이트 주소뿐만 아니라 컴퓨터 네트워크상의 자원을 모두 나타낼 수 있다. 그 주소에 접속하려면 해당 URL에 맞는 프로토콜을 알아야 하고, 그와 도일한 프로토콜로 접속해야 한다.</p>
<h3 id="urn-uniform-resource-name"> URN(Uniform Resource Name)</h3>
<p>URN은 urn:scheme을 사용하는 URI를 위한 역사적인 이름이다. URN은 영속적이고, 위치에 독립적인 자원을 위한 지시자로 싸용하기 위해 1997년도 RFC 2141 문서에서 정의되었다.</p>
<p><img src="https://media.vlpt.us/images/jch9537/post/88b0c8ac-5870-4cbc-b613-7dd39f510f31/image.png" alt="url"></p>
<br>
<h2 id="_1212-database-index"> 1212 - Database index</h2>
<h3 id="인덱스란"> 인덱스란?</h3>
<p>추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다. 많이 드는 예시로 책의 색인을 이야기 한다. 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.</p>
<p>인덱스를 활용하면, 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 대상을 조회해야 UPDATE, DELETE가 가능하기 때문.</p>
<p>만약 index를 사용하지 않은 컬럼을 조회해야 하는 상황이라면 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.</p>
<h3 id="인덱스-관리"> 인덱스 관리</h3>
<p>DBMS는 index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해주어야 하며 그에 따른 오버헤드가 발생한다.</p>
<ul>
<li>INSERT: 새로운 데이터에 대한 인덱스를 추가함.</li>
<li>DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행함.</li>
<li>UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인엑스를 추가함.</li>
</ul>
<h3 id="인덱스의-장점과-단점"> 인덱스의 장점과 단점</h3>
<p>장점</p>
<ul>
<li>테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.</li>
<li>전반적인 시스템의 부하를 줄일 수 있다.</li>
</ul>
<p>단점</p>
<ul>
<li>인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.</li>
<li>인덱스를 관리하기 위해 추가 작업이 필요하다.</li>
<li>인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.</li>
</ul>
<p>만약 CREATE, DELETE, UPDATE가 빈번한 속성에 인덱스를 걸게 되면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생할 수 있다. 그러한 이유 중 하나는 DELETE와 UPDATE 연산 때문이다. UPDATE와 DELETE는 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 해준다고 했다. 만약 어떤 테이블에 UPDATE와 DELETE가 빈번하게 발생된다면 실제 데이터는 10만건이지만 인덱스는 100만 건이 넘어가게 되어, SQL문 처리 시 비대해진 인덱스에 의해 오히려 성능이 떨어지게 된다.</p>
<h3 id="인덱스를-사용하면-좋은-경우"> 인덱스를 사용하면 좋은 경우</h3>
<ul>
<li>규모가 작지 않은 테이블</li>
<li>INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼</li>
<li>JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼</li>
<li>데이터의 중복도가 낮은 컬럼</li>
</ul>
<h3 id="인덱스의-자료구조"> 인덱스의 자료구조</h3>
<p>인덱스를 구현하기 위해서는 여러가지 자료구조를 사용할 수 있는데, 가장 대표적인 자료구조는 해시 테이블과 B+Tree가 있다.</p>
<h4 id="해시테이블-hash-table"> 해시테이블(Hash Table)</h4>
<p>해시 테이블 기반의 DB 인덱스는 컬럼의 값, 데이터의 위치를 Key, Value로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현한다. 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원한다.<br>
하지만 DB인덱스에서 해시 테이블이 사용되는 경우는 제한적이다. 그이유는 해시가 등호(=) 연산에만 특화되었기 때문이다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 부등호 연산이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.<br>
즉, 예를 들면 &quot;나는&quot;으로 시작하는 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜택을 전혀 받지 못하게 된다.</p>
<h4 id="b-tree"> B+Tree</h4>
<p>DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터를 저장했던 BTree와 다른 특성을 가지고 있다.</p>
<ul>
<li>리프노드(데이터노드)만 인덱스와 함꼐 데이터(벨류)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(키)만을 갖는다.</li>
<li>리프노드들은 LinkedList로 연결되어 있다.</li>
<li>데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.</li>
</ul>
<p>데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있다. 이러한 이유로 BTree의 리프노드들은 LinkedList로 연결하여 순차검색을 용이하게 하는 등 BTree를 인덱스에 맞게 최적화하였다. (물론 Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 BTree에 비해 무조건 리프노드까지 가야한다는 단점도 있다.) 이러한 이유로 비록 B+Tree는 O(𝑙𝑜𝑔2𝑛)의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었다.</p>
<ul>
<li>InnoDB에서 사용된 B+Tree의 구조
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd78iJ0%2FbtqKRYbLdM9%2FnIvz1M4gffMl4YHS77JSfK%2Fimg.png" alt="btree"></li>
</ul>
]]></content:encoded>
      <enclosure url="https://media.vlpt.us/images/jch9537/post/51dcc312-8ecb-4048-80df-cbde40865e7a/image.png" type="image/png"/>
    </item>
    <item>
      <title>1213 - 1219</title>
      <link>ahnjs/TIL/2021/1213/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1213/</guid>
      <source url="ahnjs/TIL/rss.xml">1213 - 1219</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1213-1219"> 1213 - 1219</h1>
<h2 id="_1213-stopwatch"> 1213 - StopWatch</h2>
<p>Spring의 StopWatch 클래스는 여러개 작업의 시간을 측정해주며, 총 소요시간과 각각의 이름붙인 작업들에 소요된 시산을 표시해준다. System.nanoTime()의 사용을 감추고 어플리케이션 코드의 가독성을 높일 뿐만 아니라 계산 오류의 가능성도 줄여준다.</p>
<ul>
<li>예시 코드</li>
</ul>
<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>util<span>.</span></span><span>StopWatch</span><span>;</span>
 
<span>public</span> <span>class</span> <span>StopWatchClass</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
 
        <span>// StopWatch 생성</span>
        <span>StopWatch</span> stopwatch <span>=</span> <span>new</span> <span>StopWatch</span><span>(</span><span>)</span><span>;</span>
 
        <span>// 타이머 시작</span>
        stopwatch<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
 
        <span>// 작업</span>
        <span>fibonacci</span><span>(</span><span>45</span><span>)</span><span>;</span>
 
        <span>// 타이머 종료</span>
        stopwatch<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
 
        <span>// 결과 분석</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stopwatch<span>.</span><span>prettyPrint</span><span>(</span><span>)</span><span>)</span><span>;</span>
 
    <span>}</span>
 
    <span>public</span> <span>static</span> <span>int</span> <span>fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>)</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>return</span> <span>fibonacci</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fibonacci</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>
    <span>}</span>
 
<span>}</span>    

<span>// 1 sec = 1,000 ms = 1,000,000 μs = 1,000,000,000 ns</span>

<span>// 45개의 피보나치 수열을 계산하는데 총 3.82 초.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><ul>
<li>Recursive, Dynamic Programming</li>
</ul>
<div><pre><code><span>import</span> <span>org<span>.</span>springframework<span>.</span>util<span>.</span></span><span>StopWatch</span><span>;</span>
 
<span>public</span> <span>class</span> <span>StopWatchClass2</span> <span>{</span>
    <span>static</span> <span>final</span> <span>int</span> number <span>=</span> <span>45</span><span>;</span>
    <span>static</span> <span>long</span><span>[</span><span>]</span> memo<span>=</span> <span>new</span> <span>long</span><span>[</span>number<span>+</span><span>1</span><span>]</span><span>;</span>
 
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
 
        <span>StopWatch</span> stopwatch <span>=</span> <span>new</span> <span>StopWatch</span><span>(</span><span>"fibonacci"</span><span>)</span><span>;</span>
 
        <span>// 1번 작업</span>
        stopwatch<span>.</span><span>start</span><span>(</span><span>"recursive"</span><span>)</span><span>;</span>
        <span>fibonacci</span><span>(</span>number<span>)</span><span>;</span>
        stopwatch<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
 
        <span>// 2번 작업</span>
        stopwatch<span>.</span><span>start</span><span>(</span><span>"DP"</span><span>)</span><span>;</span>
        <span>fibonacciDp</span><span>(</span>number<span>)</span><span>;</span>
        stopwatch<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
 
        <span>// 결과 분석</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>stopwatch<span>.</span><span>prettyPrint</span><span>(</span><span>)</span><span>)</span><span>;</span>
 
    <span>}</span>
 
    <span>public</span> <span>static</span> <span>long</span> <span>fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>)</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>return</span> <span>fibonacci</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fibonacci</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>
    <span>}</span>
 
    <span>public</span> <span>static</span> <span>long</span> <span>fibonacciDp</span><span>(</span><span>int</span> n<span>)</span><span>{</span>
        <span>if</span><span>(</span>n<span>==</span><span>0</span><span>)</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>if</span><span>(</span>n<span>==</span><span>1</span><span>)</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>if</span><span>(</span>memo<span>[</span>n<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> memo<span>[</span>n<span>]</span><span>;</span>
        <span>}</span><span>else</span> <span>{</span>
            <span>return</span> memo<span>[</span>n<span>]</span> <span>=</span> <span>fibonacciDp</span><span>(</span>n<span>-</span><span>1</span><span>)</span> <span>+</span> <span>fibonacciDp</span><span>(</span>n<span>-</span><span>2</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><br>
<h2 id="_1215-map-과-flatmap"> 1215 - .map()과 .flatMap()</h2>
<h3 id="map"> .map()</h3>
<p>.map()은 단일 스트림 원소를 매핑시킨 후 매핑시킨 값을 다시 스트림으로 변환하는 중간 연산을 담당한다. 객체에서 원하는 원소를 주출하는 역할을 한다.</p>
<h3 id="flatmap"> .flatMap()</h3>
<p>.flatMap()은 Array나 Object로 감싸져 있는 모든 원소를 단일 원소 스트림으로 반환한다. .map()은 입력한 원소를 그대로 스트림으로 반환하지만, .flatMap()은 입력한 원소를 가장 작은 단위의 단일 스트림으로 반환한다.</p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEBPcN%2FbtqDljIyCWG%2FDMFulkA3iEg71mEDCBolZK%2Fimg.png" alt="flatMap"></p>
<ul>
<li>witheoutFlatMap.java</li>
</ul>
<div><pre><code><span>String</span><span>[</span><span>]</span><span>[</span><span>]</span> sample <span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>[</span><span>]</span><span>{</span>
  <span>{</span><span>"a"</span><span>,</span> <span>"b"</span><span>}</span><span>,</span> <span>{</span><span>"c"</span><span>,</span> <span>"d"</span><span>}</span><span>,</span> <span>{</span><span>"e"</span><span>,</span> <span>"a"</span><span>}</span><span>,</span> <span>{</span><span>"a"</span><span>,</span> <span>"h"</span><span>}</span><span>,</span> <span>{</span><span>"i"</span><span>,</span> <span>"j"</span><span>}</span>
<span>}</span><span>;</span>

<span>//without .flatMap()</span>
<span>Stream</span><span><span>&lt;</span><span>String</span><span>></span></span> stream <span>=</span> sample<span>.</span><span>stream</span><span>(</span><span>)</span>
  <span>.</span><span>filter</span><span>(</span>alpha <span>-></span> <span>"a"</span><span>.</span><span>equals</span><span>(</span>alpha<span>[</span><span>0</span><span>]</span><span>.</span><span>toString</span><span>(</span><span>)</span> <span>||</span> <span>"a"</span><span>.</span><span>equals</span><span>(</span>alpha<span>[</span><span>1</span><span>]</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>)</span><span>)</span>
stream<span>.</span><span>forEach</span><span>(</span>alpha <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"{"</span><span>+</span>alpha<span>[</span><span>0</span><span>]</span><span>+</span><span>", "</span><span>+</span>alpha<span>[</span><span>1</span><span>]</span><span>+</span><span>"}"</span><span>)</span><span>)</span><span>;</span>

<span>// output</span>
<span>{</span>a<span>,</span> b<span>}</span>
<span>{</span>e<span>,</span> a<span>}</span>
<span>{</span>a<span>,</span> h<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>
<li>withFlatMap.java</li>
</ul>
<div><pre><code><span>String</span><span>[</span><span>]</span><span>[</span><span>]</span> sample <span>=</span> <span>new</span> <span>String</span><span>[</span><span>]</span><span>[</span><span>]</span><span>{</span>
  <span>{</span><span>"a"</span><span>,</span> <span>"b"</span><span>}</span><span>,</span> <span>{</span><span>"c"</span><span>,</span> <span>"d"</span><span>}</span><span>,</span> <span>{</span><span>"e"</span><span>,</span> <span>"a"</span><span>}</span><span>,</span> <span>{</span><span>"a"</span><span>,</span> <span>"h"</span><span>}</span><span>,</span> <span>{</span><span>"i"</span><span>,</span> <span>"j"</span><span>}</span>
<span>}</span><span>;</span>

<span>//without .flatMap()</span>
<span>Stream</span><span><span>&lt;</span><span>String</span><span>></span></span> stream <span>=</span> sample<span>.</span><span>stream</span><span>(</span><span>)</span>
  <span>.</span><span>flatMap</span><span>(</span>array <span>-></span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>array<span>)</span><span>)</span>
  <span>.</span><span>filter</span><span>(</span>x<span>-></span> <span>"a"</span><span>.</span><span>equals</span><span>(</span>x<span>)</span><span>)</span><span>;</span>

stream<span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>

<span>// output</span>
a
a
a
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><br>
<h2 id="_1218-aws-인프라-구축"> 1218 - AWS 인프라 구축</h2>
<h3 id="전통인프라와-비교"> 전통인프라와 비교</h3>
<table>
<thead>
<tr>
<th>전통인프라</th>
<th>AWS</th>
</tr>
</thead>
<tbody>
<tr>
<td>네트워크</td>
<td>VPC</td>
</tr>
<tr>
<td>보안정책</td>
<td>SECURITY CROUP</td>
</tr>
<tr>
<td>L4</td>
<td>ELB</td>
</tr>
<tr>
<td>서버</td>
<td>EC2</td>
</tr>
<tr>
<td>DNS</td>
<td>ROUTE 53</td>
</tr>
<tr>
<td>DB</td>
<td>RDS</td>
</tr>
<tr>
<td>스토리지</td>
<td>S3</td>
</tr>
<tr>
<td>CDN</td>
<td>CloudFront</td>
</tr>
<tr>
<td>NAT</td>
<td>NAT</td>
</tr>
<tr>
<td>배포시스템</td>
<td>OpsWorks</td>
</tr>
<tr>
<td>장애알림</td>
<td>SNS</td>
</tr>
<tr>
<td>서버접근방식</td>
<td>VPN</td>
</tr>
</tbody>
</table>
<h3 id="vpc란"> vpc란</h3>
<p>VPC(Virtual Private Cloud)는 사용자가 정의하는 가장의 네트워크 이다. VPC를 통해 인스턴스가 속하는 네트워크를 구분하여 각 네트워크에 맞는 설정을 부여할 수 있다. AWS는 VPC의 중요성을 강조하여 2019년부터 모든 서비스에 VPC를 적용하도록 했고, 인스턴스 생성싱 자동으로 default VPC에 인스턴스가 배치된다.</p>
<p>사설 IP 대역</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255(10/8 prefix)</li>
<li>172.16.0.0 ~ 172.31.255.255(182.16/12 prefix)</li>
<li>192.168.0.0 ~ 192.168.255.255(192.168/16 prefix)</li>
</ul>
<p>VPC에서 한번 설정된 IP 대역은 수정할 수 없으며 각각의 VPC는 독립적이기 때문에 서로 통신할 수 없다. 만약 통신을 원한다면 VPC피어링 서비스를 통해 VPC간에 트래픽을 라우팅할 수 있또록 설정할 수 있다.</p>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FEBPcN%2FbtqDljIyCWG%2FDMFulkA3iEg71mEDCBolZK%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0102 - 0109</title>
      <link>ahnjs/TIL/2022/0102/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0102/</guid>
      <source url="ahnjs/TIL/rss.xml">0102 - 0109</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0102-0109"> 0102 - 0109</h1>
<h2 id="_0103-원격-저장소에-push된-파일을-ignore"> 0103 - 원격 저장소에 push된 파일을 ignore</h2>
<ul>
<li>
<p>문제<br>
원격 저장소에 이미 올라가 있는 파일을 git ignore에 추가 하여 파일을 무시하고 싶은 경우<br>
그냥 ignore에 추가시키면 추가가 되지 않는다.</p>
</li>
<li>
<p>해결</p>
</li>
</ul>
<div><pre><code><span>git</span> <span>rm</span> -r --cached <span>.</span>
<span>git</span> <span>add</span> <span>.</span>
<span>git</span> commit -m <span>"chore: git ignore"</span>
<span>git</span> push
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>이와 같이 명령을 실행하게 되면 깃의 캐시를 다 날린 다음 다시 add를 진행하게 된다.</p>
<br>
<h2 id="_0104-jpa-연관관계"> 0104 - JPA 연관관계</h2>
<h3 id="jpa에서-가장-중요한-것"> JPA에서 가장 중요한 것</h3>
<ul>
<li>객체와 관계형 데이터베이스 테이블이 어떻게 매핑되는지를 이해하는 것이 중요</li>
<li>1차원 매핑
<ul>
<li>@Entity, @Column, @Id, @GeneratedValue, @Enumerated.. 와 같은 말 그대로 객체와 데이터베이스 사이의 일대일로 대응되는 것으로써 기본적인 Annotation을 숙지</li>
</ul>
</li>
<li>연관 관계 매핑</li>
</ul>
<h3 id="연관-관계-정의-규칙"> 연관 관계 정의 규칙</h3>
<p>연관 관계를 매핑할 때, 생각해야 할 3가지</p>
<ul>
<li>방향 : 단방향, 양방향</li>
<li>연관 관계의 주인 : 양방향일 때, 연관 관계에서 관리 주체</li>
<li>다중성 : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)</li>
</ul>
<h4 id="단방향-양방향"> 단방향, 양방향</h4>
<p>데이터베이스 테이블은 외래키 하나로 양 쪽 테이블 조인이 가능. 따라서 데이터 베이스는 단방향, 양방향을 나눌 필요가 없다.<br>
그러나 객체는 참조용 필드가 있는 객체만 다른 객체를 참조하는 것이 가능하기 때문에 두 객체 사이에 하나의 객체만 참조용 필드를 갖고 참조하면 단방향 관계, 두 객체가 모드가 각각 참조용 필드를 갖고 참조하면 양방향 관계가 된다.<br>
엄밀하게는 양방향 관계는 없고 두 객체가 단방향 참조를 각각 가져서 양방향 관계처럼 사용된다.</p>
<h4 id="연관-관계의-주인"> 연관 관계의 주인</h4>
<p>두 단방향 관계에서 제어의 권한(외래키를 비롯한 테이블 레코드를 저장, 수정, 삭제처리)을 갖는 실질적인 관계까 어떤 것인지 JPA에게 제공, 연관 관계의 주인이 아니라면 조회만 가능하다.<br>
연관 관계의 주인이 아닌 객체에서 <code>mappedBy</code> 속성을 사용하고 외래 키가 있는 곳을 연관 관계의 주인으로 정하면 된다.</p>
<h4 id="다중성"> 다중성</h4>
<ul>
<li>다대일(N:1) - 단방향(주인이 'N') : 사용가능</li>
<li>다대일(N:1) - 양방향(주인이 'N') : 사용가능</li>
<li>일대다(1:N) - 단방향(주인이 '1') : 사용불가</li>
<li>일대다(1:N) - 양방향(주인이 '1') : 사용불가</li>
<li>일대일(1:1) - 단방향 : 사용가능</li>
<li>일대일(1:1) - 양방향 : 사용가능</li>
<li>다대다(N:M) - 실무 사용금지 =&gt; 자기도 모르는 복잡한 조인의 쿼리가 발생할 수 도 있음. 따라서 중간 테이블을 생성할 것</li>
</ul>
<br>
<h2 id="_0105-datajpatest-vs-springboottest"> 0105 - @DataJpaTest vs @SpringBootTest</h2>
<h3 id="datajpatest"> @DataJpaTest</h3>
<p>@DataJpaTest는 오직 JPA 컴포넌트들만을 테스트하기 위한 어노테이션.<br>
full-auto config를 해제하고 JPA 테스트와 연관된 config만 적용한다.</p>
<ul>
<li>@DataJpaTest가 포함하고 있는 어노테이션</li>
</ul>
<div><pre><code><span>@Target</span><span>(</span>value<span>=</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span>value<span>=</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Inherited</span> <span>@BootstrapWith</span><span>(</span>value<span>=</span><span><span>org<span>.</span>springframework<span>.</span>boot<span>.</span>test<span>.</span>autoconfigure<span>.</span>orm<span>.</span>jpa<span>.</span></span>DataJpaTestContextBootstrapper</span><span>.</span><span>class</span><span>)</span>
<span>@ExtendWith</span><span>(</span>value<span>=</span><span><span>org<span>.</span>springframework<span>.</span>test<span>.</span>context<span>.</span>junit<span>.</span>jupiter<span>.</span></span>SpringExtension</span><span>.</span><span>class</span><span>)</span>
<span>@OverrideAutoConfiguration</span><span>(</span>enabled<span>=</span><span>false</span><span>)</span>
<span>@TypeExcludeFilters</span><span>(</span>value<span>=</span><span>DataJpaTypeExcludeFilter</span><span>.</span><span>class</span><span>)</span>
<span>@Transactional</span>
<span>@AutoConfigureCache</span>
<span>@AutoConfigureDataJpa</span>
<span>@AutoConfigureTestDatabase</span>
<span>@AutoConfigureTestEntityManager</span>
<span>@ImportAutoConfiguration</span>
<span>public</span> <span>@interface</span> <span>DataJpaTest</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ol>
<li>@Transactional
<ul>
<li>자동으로 롤백</li>
</ul>
</li>
<li>@AutoConfigureTestDatabase
<ul>
<li>replace=AutoConfigureTestDatabase.Replace가 디폴트로 설정되어 있어, 설정해놓은 DB가 아닌 in-memory DB를 활용해서 테스트가 실행된다.</li>
<li>EmbeddedBatabaseConnection 클래스를 보면 H2, DERBY, HSQL, HSQLDB 중 사용 가능한 in-memory DB에 자동으로 커넥션을 설정하는 것을 확인할 수 있다.</li>
<li>replace=AutoConfigureTestDatabase.NONE 으로 값을 덮어 씌우면 설정해놓은 DB를 테스트에 사용할 수 있다.</li>
</ul>
</li>
</ol>
<h3 id="springboottest"> @SpringBootTest</h3>
<p>@SpringBootTest는 full application config을 로드에서 통합 테스트를 진행하기 위한 어노테이션이다.</p>
<div><pre><code><span>@Target</span><span>(</span>value<span>=</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span>value<span>=</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Inherited</span>
<span>@BootstrapWith</span><span>(</span>value<span>=</span><span>SpringBootTestContextBootstrapper</span><span>.</span><span>class</span><span>)</span>
<span>@ExtendWith</span><span>(</span>value<span>=</span><span><span>org<span>.</span>springframework<span>.</span>test<span>.</span>context<span>.</span>junit<span>.</span>jupiter<span>.</span></span>SpringExtension</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>@interface</span> <span>SpringBootTest</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>설정해 놓은 config, context, components를 모두 로드한다.</li>
<li>DataSource bean을 그대로 사용하기 때문에 in-memory, 로컬, 외부 상관 없이 DB를 사용해서 테스트가 실행된다.</li>
<li>테스트할 때마다 DB가 롤백되지 않기 때문에 @Transactional을 사용해야 한다.</li>
</ul>
<br>
<h2 id="_0106-junit5-extendwith-mockmvc-testconstructor"> 0106 - Junit5 : @ExtendWith, MockMvc, @TestConstructor</h2>
<h3 id="extendwith"> @ExtendWith</h3>
<ul>
<li>Junit 4의 @RunWith가 Junit 5에서는 @ExtendWith로 변경</li>
<li>@SpringBootTest 애노테이션에 포함되어 있기 떄문에 둘다 명시할 필요는 없다</li>
</ul>
<h3 id="mockmvc"> MockMvc</h3>
<ul>
<li>Spring MVC 에플리케이션을 테스트 해볼 수 있게 도와준다.</li>
<li>실제 서버의 실행 없이 요청하고 응답을 받을 수 있다.</li>
</ul>
<p>MocmMvc와 WebApplicationContext를 @Autowired 애노페이션을 이용해 의존관계를 주입하고, setup() 메서드로 MockMvc를 초기화 한다.<br>
@BeforeEach 애노테이션을 명시함으로써 테스트가 실행되기 전 setup() 메서드가 실행되어 반복적으로 초기화 할 필요가 없다.</p>
<div><pre><code><span>@WebMvcTest</span>
<span>public</span> <span>class</span> <span>HelloControllerTest</span> <span>{</span>

    <span>@Autowired</span>
    <span>private</span> <span>MockMvc</span> mockMvc<span>;</span>

    <span>@Autowired</span>
    <span>private</span> <span>WebbApplicationContext</span> webApplicationContext<span>;</span>

    <span>@BeforeEach</span>
    <span>public</span> <span>void</span> <span>setup</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>{</span>
        <span>this</span><span>.</span>mockMvc <span>=</span> <span>MockMvcBuilders</span>
                        <span>.</span><span>webAppContextSetup</span><span>(</span><span>this</span><span>.</span>webApplicationContext<span>)</span>
                        <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="testresttemplate"> TestRestTemplate</h4>
<ul>
<li>@SpringBootTest의 WebEnvironment설정으로 실제 서버를 동작하게 한 뒤, RestTemplate을 통해 요청, 응답 받을 수 있다.</li>
<li>TestRestTemplate는 스프링에서 제공하는 테스트용 RestTemplate이며, 자동으로 내장 서버와 연결된다</li>
<li>필요하다면 RestTemplateBuilder를 통해 여러 설정을 추가할 수 있다.</li>
</ul>
<blockquote>
<p>MockMvc는 사이드에서 테스트 하는것, TestRestTemplate는 클라이언트 사이드에서 테스트 해보는 것</p>
</blockquote>
<h3 id="testconstructor"> @TestConstructor</h3>
<p>JUnit 5부터는 생성자를 통한 의존관계 주입이 가능하다.<br>
AutowireMode.ALL 설정을 통해 @Autowired 애노테이션을 명시하지 않고, private final로 선언된 필드들에 의존관계 주입이 가능하다.</p>
<div><pre><code><span>@RequiredArgsConstructor</span>
<span>@TestConstructor</span><span>(</span>autowireMode <span>=</span> <span>TestConstructor<span>.</span>AutowireMode</span><span>.</span>ALL<span>)</span>
<span>@SpringBootTest</span>
<span>public</span> <span>class</span> <span>MyTest</span> <span>{</span>

    <span>private</span> <span>final</span> <span>HelloService</span> helloService<span>;</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> 테스트<span>(</span><span>)</span> <span>{</span>
        <span>// 테스트 코드 생략</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><br>
<h2 id="_0107-springboot-test"> 0107 - Springboot Test</h2>
<h3 id="스프링부트-테스트-핵심-기능"> 스프링부트 테스트 핵심 기능</h3>
<ul>
<li>의존성</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
  <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
  <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-test<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
  <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="springboottest-2"> @SpringBootTest</h3>
<blockquote>
<p>스프링부투에서는 @SpringBootTest 어노테이션을 통해 애플리케이션 테스트에 필요한 거의 모든 의존성들을 제공해준다.</p>
</blockquote>
<blockquote>
<p>@SpringBootTest 어노테이션은 Spring Main Application(@SpringBootApplication)을 찾아가 하위의 모든 Bean을 Scan한다.</p>
</blockquote>
<blockquote>
<p>그 후 Test용 Application Context를 만들면서 빈을 등록해주고, mock bean을 찾아가 그 빈만 mock bean으로 교체해준다.</p>
</blockquote>
<h3 id="webenvironment"> WebEnvironment</h3>
<ul>
<li>MOCK : mock servlet environment로 내장 톰캣 구동을 안한다.</li>
<li>RANDOM_PORT, DEFINED_PORT : 내장 톰캣 사용</li>
<li>NONE : 서블릿 환경 제공 안함</li>
</ul>
<h4 id="_1-mock"> 1. MOCK</h4>
<div><pre><code><span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>
<span>@SpringBootTest</span><span>(</span>webEnvironment <span>=</span> <span>SpringBootTest<span>.</span>WebEnvironment</span><span>.</span>MOCK<span>)</span>
<span>@AutoConfigureMockMvc</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>@RunWith(SpringRunner.class) 어노테이션은 JUnit이 내장된 Runner를 실행할 때 SpringRunner.class라는 확장된 클래스를 실행하라고 지시한다.</p>
<p>테스트의 WebEnvironment 환경은 기본적으로 MOCK으로 잡혀있으며, 이 때 내장톰캣을 구동하지 않아 서블릿이 아니라 서블릿을 Mocking한 컨테이너가 뜬다.</p>
<p>Mockup이된 서블릿과 interaction 하기 위해서는 MockMVC라는 클라이언트를 사용해야 한다.</p>
<h4 id="_2-random-port"> 2. RANDOM_PORT</h4>
<div><pre><code><span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>
<span>@SpringBootTest</span><span>(</span>webEnvironment <span>=</span> <span>SpringBootTest<span>.</span>WebEnvironment</span><span>.</span>RANDOM_PORT<span>)</span>
<span>@AutoConfigureMockMvc</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>WebEnvironment가 RANDOM_PORT를 사용할 때 실제로 서블릿 컨테이너(내장 톰캣)이 랜덤한 포트로 뜬다. 이떄부터는 Test용 RestTemplate, Web Client를 사용한다.</p>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>hello</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>String</span> result <span>=</span> testRestTemplate<span>.</span><span>getForObject</span><span>(</span><span>"/hello"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>result<span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"hello dsunni"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="_3-mockbean"> 3. MockBean</h4>
<div><pre><code><span>@RunWith</span><span>(</span><span>SpringRunner</span><span>.</span><span>class</span><span>)</span>
<span>@SpringBootTest</span><span>(</span>webEnvironment <span>=</span> <span>SpringBootTest<span>.</span>WebEnvironment</span><span>.</span>RANDOM_PORT<span>)</span>
<span>@AutoConfigureMockMvc</span>
<span>public</span> <span>class</span> <span>ControllerTest</span> <span>{</span>
    <span>@Autowired</span>
    <span>TestRestTemplate</span> testRestTemplate<span>;</span>

    <span>@MockBean</span>
    <span>TestService</span> mockTestService<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>@MockBean을 붙여서 mockTestService를 만들면 Application Context안에 TestService 빈을 mockTestService빈으로 교체한다. 실질적으로 원본이 아닌 mock bean을 사용해 테스트할 수 있다.</p>
<h4 id="_4-webtestclient"> 4. @WebTestClient</h4>
<p>java5 Spring MVC WebFlux에 새로 추가된 Rest Client 중 하나이다. 기존에 사용하던 Rest Client는 Synchronous였다. 오청 하나 보내면 끝날때 까지 기다렸다가 요청을 보낼 수 있었다.</p>
<p>WebTestClient는 Asynchronous하게 동작한다. 요청을 보내고 응답이 오면 그 떄 CallBackEvent가 발생해 실행할 수 있다.</p>
<ul>
<li>의존성 추가</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
  <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
  <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-webflux<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>@Autowired</span>
<span>WebTestClient</span> webTestClient<span>;</span>

<span>@Test</span>
    <span>public</span> <span>void</span> <span>hello</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>when</span><span>(</span>mockiService<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>thenReturn</span><span>(</span><span>"test"</span><span>)</span><span>;</span>
        webTestClient<span>.</span><span>get</span><span>(</span><span>)</span><span>.</span><span>uri</span><span>(</span><span>"/hello"</span><span>)</span>	<span>//request 만들어서</span>
          			<span>.</span><span>exchange</span><span>(</span><span>)</span>								<span>//보내고</span>
                <span>.</span><span>expectStatus</span><span>(</span><span>)</span><span>.</span><span>isOk</span><span>(</span><span>)</span>		<span>//검증</span>
                <span>.</span><span>expectBody</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"hello test"</span><span>)</span><span>;</span>
    <span>}</span>   
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="슬라이스-테스트"> 슬라이스 테스트</h3>
<p>레이어 별로 잘라서 테스트하고 싶을 때 사용. 레이어 별로 빈이 등록됨</p>
<ul>
<li>@JsonTest</li>
<li>@WebMvcTest</li>
<li>@WebFluxTest</li>
<li>@DataJpaTest</li>
</ul>
<h3 id="테스트-유틸"> 테스트 유틸</h3>
<ul>
<li>OutputCapture</li>
<li>TestPropertyValues</li>
<li>TestRestTemplate</li>
<li>ConfigFileApplicationContextInitializer</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>1220 - 1226</title>
      <link>ahnjs/TIL/2021/1220/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/1220/</guid>
      <source url="ahnjs/TIL/rss.xml">1220 - 1226</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_1220-1226"> 1220 - 1226</h1>
<h2 id="_1221-전략패턴과-커맨드패턴"> 1221 - 전략패턴과 커맨드패턴</h2>
<p>인터페이스를 구현하여 사용하는 두 가지 패턴인 전략 패턴과 커맨드 패턴의 차이</p>
<h3 id="전략패턴"> 전략패턴</h3>
<p>전략 패턴은 프로그램이 진행되면서 캡슐화된 로직을 선택할 수 있게 하는 디자인 패턴이다. 로직 실행은 인터페이스에 의존을 시키고 인터페이스를 구현한 로직들을 전달해줌으로써 분기처리 없이 유연서을 갖출 수가 있다.</p>
<ul>
<li>예제 코드</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>PeopleWithMovement</span> <span>{</span>

    <span>private</span> <span>Transportation</span> transportation<span>;</span>

    <span>public</span> <span>PeopleWithMovement</span><span>(</span><span>Transportation</span> transportation<span>)</span> <span>{</span>
        <span>this</span><span>.</span>transportation <span>=</span> transportation<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>move</span><span>(</span><span>String</span> start<span>,</span> <span>String</span> end<span>)</span> <span>{</span>
        transportation<span>.</span><span>move</span><span>(</span>start<span>,</span> end<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>changeTransporation</span><span>(</span><span>Transportation</span> transportation<span>)</span> <span>{</span>
        <span>this</span><span>.</span>transportation <span>=</span> transportation<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>전략을 행항 주체인 Transporation은 인터페이스로 분리되어 캡슐화 되어 있다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>Transportation</span> <span>{</span>

    <span>void</span> <span>move</span><span>(</span><span>String</span> start<span>,</span> <span>String</span> end<span>)</span><span>;</span>
<span>}</span>

<span>// </span>
<span>public</span> <span>class</span> <span>Bicycle</span> <span>implements</span> <span>Transportation</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>move</span><span>(</span><span>String</span> start<span>,</span> <span>String</span> end<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"출발점 : "</span> <span>+</span> start <span>+</span> <span>"에서 목적지 : "</span> <span>+</span> end <span>+</span> <span>"까지 `자전거`로 이동합니다."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// </span>
<span>public</span> <span>class</span> <span>Bus</span> <span>implements</span> <span>Transportation</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>move</span><span>(</span><span>String</span> start<span>,</span> <span>String</span> end<span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"출발점 : "</span> <span>+</span> start <span>+</span> <span>"에서 목적지 : "</span> <span>+</span> end <span>+</span> <span>"까지 `버스`로 이동합니다."</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>Transporation을 구현하여 Bus와 Bicycle 코드 작성</p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Bicycle</span> bicycle <span>=</span> <span>new</span> <span>Bicycle</span><span>(</span><span>)</span><span>;</span>
        <span>Bus</span> bus <span>=</span> <span>new</span> <span>Bus</span><span>(</span><span>)</span><span>;</span>

        <span>PeopleWithMovement</span> whybeFirst <span>=</span> <span>new</span> <span>PeopleWithMovement</span><span>(</span>bicycle<span>)</span><span>;</span>
        whybeFirst<span>.</span><span>move</span><span>(</span><span>"시작점"</span><span>,</span> <span>"끝점"</span><span>)</span><span>;</span>

        <span>PeopleWithMovement</span> whybeSecond <span>=</span> <span>new</span> <span>PeopleWithMovement</span><span>(</span>bus<span>)</span><span>;</span>
        whybeSecond<span>.</span><span>move</span><span>(</span><span>"시작점"</span><span>,</span> <span>"끝점"</span><span>)</span><span>;</span>

        <span>PeopleWithMovement</span> whybeChangeMovement <span>=</span> <span>new</span> <span>PeopleWithMovement</span><span>(</span>bicycle<span>)</span><span>;</span>
        whybeChangeMovement<span>.</span><span>move</span><span>(</span><span>"시작점"</span><span>,</span> <span>"중간지점"</span><span>)</span><span>;</span>
        whybeChangeMovement<span>.</span><span>changeTransporation</span><span>(</span>bus<span>)</span><span>;</span>
        whybeChangeMovement<span>.</span><span>move</span><span>(</span><span>"중간지점"</span><span>,</span> <span>"끝점"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>실행 결과</p>
<div><pre><code>출발점 <span>:</span> 시작점에서 목적지 <span>:</span> 끝점까지 `자전거`로 이동합니다<span>.</span>
출발점 <span>:</span> 시작점에서 목적지 <span>:</span> 끝점까지 `버스`로 이동합니다<span>.</span>
출발점 <span>:</span> 시작점에서 목적지 <span>:</span> 중간지점까지 `자전거`로 이동합니다<span>.</span>
출발점 <span>:</span> 중간지점에서 목적지 <span>:</span> 끝점까지 `버스`로 이동합니다<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="커맨드-패턴"> 커맨드 패턴</h3>
<p>커맨드 패턴은 요청을 홀로 처리할 수 있도록 요청을 수행하는 여러 인자를 함께 패키징하여 나중에 처리할 수 있도록 만들어주는 행동 중심 디자인 패턴이다. 커맨드를 실행시키는 객체는 커맨드 내부의 요소에 대해서 숨김으로써 코드의 유연성을 가질 수 있다.</p>
<ul>
<li>예제 코드</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>PeopleWithLottery</span> <span>{</span>

    <span>private</span> <span>List</span><span><span>&lt;</span><span>LotteryCommand</span><span>></span></span> lotteryCommands<span>;</span>

    <span>public</span> <span>PeopleWithLottery</span><span>(</span><span>List</span><span><span>&lt;</span><span>LotteryCommand</span><span>></span></span> lotteryCommands<span>)</span> <span>{</span>
        <span>this</span><span>.</span>lotteryCommands <span>=</span> lotteryCommands<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>addLotteryCommand</span><span>(</span><span>LotteryCommand</span> lotteryCommand<span>)</span> <span>{</span>
        lotteryCommands<span>.</span><span>add</span><span>(</span>lotteryCommand<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>scratchAllLottery</span><span>(</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> lotteryCommands<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>LotteryCommand</span> lotteryCommand <span>=</span> lotteryCommands<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
            lotteryCommand<span>.</span><span>scratch</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>//초기화</span>
        lotteryCommands <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>interface</span> <span>LotteryCommand</span> <span>{</span>
    <span>void</span> <span>scratch</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>class</span> <span>InstantScratch</span> <span>implements</span> <span>LotteryCommand</span> <span>{</span>
    
    <span>private</span> <span>InstantLottery</span> instantLottery<span>;</span>
    <span>private</span> <span>Account</span> account<span>;</span>

    <span>public</span> <span>InstantScratch</span><span>(</span><span>InstantLottery</span> instantLottery<span>,</span> <span>Account</span> account<span>)</span> <span>{</span>
        <span>this</span><span>.</span>instantLottery <span>=</span> instantLottery<span>;</span>
        <span>this</span><span>.</span>account <span>=</span> <span>Account</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>scratch</span><span>(</span><span>)</span> <span>{</span>
      <span>//instantLottery의 당첨을 확인하고 account에 돈을 집어 넣는 로직</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>InstantLottery</span> <span>{</span>
    
    <span>private</span> <span>boolean</span> win<span>;</span>

    <span>public</span> <span>InstantLottery</span><span>(</span><span>boolean</span> win<span>)</span> <span>{</span>
        <span>this</span><span>.</span>win <span>=</span> win<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>isWin</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> win<span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Account</span> <span>{</span>

    <span>private</span> <span>int</span> balance<span>;</span>

    <span>public</span> <span>void</span> <span>putMoney</span><span>(</span><span>int</span> money<span>)</span> <span>{</span>
        balance <span>+=</span> money<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>PeopleWithLottery</span> whybe <span>=</span> <span>new</span> <span>PeopleWithLottery</span><span>(</span><span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Account</span> 와이비통장 <span>=</span> <span>new</span> <span>Account</span><span>(</span><span>)</span><span>;</span>
        
        <span>//즉석복권 구입</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>//즉석복권 생성 로직 </span>
            <span>InstantLottery</span> instantLottery <span>=</span> <span>new</span> <span>InstantLottery</span><span>(</span>당첨여부<span>)</span><span>;</span>
            <span>//즉석복권긁기행위 객체 생성 및 커맨드 목록에 추가</span>
            <span>InstantScratch</span> 즉석복권긁기커맨드 <span>=</span> <span>new</span> <span>InstantScratch</span><span>(</span>즉석복권<span>,</span> 와이비통장<span>)</span><span>;</span>
            whybe<span>.</span><span>addLotteryCommand</span><span>(</span>즉석복권긁기커맨드<span>)</span><span>;</span>
        <span>}</span>
        
        whybe<span>.</span><span>scratchAllLotery</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>당첨을 확인하고 통장에 돈을 추가하는 것을 캡슐화하고, 긁는 행위를 호출하는 객체(People), 명령을 담장하는 객체(LotteryCommand) 그리고 명령 수행으로 인하여 영향을 받는 객체(MyAccount)가 모두 다르게 구성.</p>
<div><pre><code><span>public</span> <span>class</span> <span>NumberScratch</span> <span>implements</span> <span>LotteryCommand</span> <span>{</span>

    <span>private</span> <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> winners<span>;</span>
    <span>private</span> <span>NumberLottery</span> numberLottery<span>;</span>
    <span>private</span> <span>Account</span> account<span>;</span>

    <span>public</span> <span>NumberScratch</span><span>(</span><span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> winners<span>,</span> <span>NumberLottery</span> numberLottery<span>,</span> <span>Account</span> account<span>)</span> <span>{</span>
        <span>this</span><span>.</span>winners <span>=</span> winners<span>;</span>
        <span>this</span><span>.</span>numberLottery <span>=</span> numberLottery<span>;</span>
        <span>this</span><span>.</span>account <span>=</span> account<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>scratch</span><span>(</span><span>)</span> <span>{</span>
        <span>// winners와 numberLottery를 비교하여 당첨금을 계산하고 </span>
        <span>// account에 해당 금액을 입금하는 로직</span>
    <span>}</span>   
<span>}</span>

<span>public</span> <span>class</span> <span>NumberLottery</span> <span>{</span>
    
    <span>private</span> <span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers<span>;</span>

    <span>public</span> <span>NumberLottery</span><span>(</span><span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers<span>)</span> <span>{</span>
        <span>this</span><span>.</span>numbers <span>=</span> numbers<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>rank</span><span>(</span><span>Set</span><span><span>&lt;</span><span>Integer</span><span>></span></span> winners<span>)</span> <span>{</span>
        <span>// 당첨 번호와 비교하여 자신의 등수를 계산하는 로직</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>PeopleWithLottery</span> whybe <span>=</span> <span>new</span> <span>PeopleWithLottery</span><span>(</span><span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Account</span> 영이통장 <span>=</span> <span>new</span> <span>Account</span><span>(</span><span>)</span><span>;</span>
        
        <span>//즉석복권 구입</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>//번호식 복권 생성 로직 </span>
            <span>NumberLottery</span> 번호식복권 <span>=</span> <span>new</span> <span>NumberLottery</span><span>(</span>선택한 번호<span>)</span><span>;</span>
            <span>//번호식복권긁기행위 객체 생성 및 커맨드 목록에 추가</span>
            <span>NumberScratch</span> 번호식복권긁기커맨드 <span>=</span> <span>new</span> <span>NumberScratch</span><span>(</span>이번주 당첨번호<span>,</span> 번호식복권<span>,</span> 영이통장<span>)</span><span>;</span>
            whybe<span>.</span><span>addLotteryCommand</span><span>(</span>번호식복권긁기커맨드<span>)</span><span>;</span>
        <span>}</span>

        whybe<span>.</span><span>scratchAllLottery</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>행위를 캡슐화하여 복권을 긁는 행위를 호출하는 객체인 PeopleWithLottery와 명령 수행으로 인하여 영향을 받는 객체에 큰 변화를 거치지 않도록 만듬</p>
<h3 id="전략패턴과-커맨드패턴의-차이"> 전략패턴과 커맨드패턴의 차이</h3>
<p>전략 패턴은 <code>어떻게</code>라는 측면에 집중. 커맨드 패턴은 <code>무엇</code>에 초점</p>
<br>
<h2 id="_1224-multipart"> 1224 - Multipart</h2>
<h3 id="multipart란"> Multipart란?</h3>
<ul>
<li>웹 클라이언트가 요청을 보낼 때, http 프로토콜의 바디 부분에 데이터를 여러 부분으로 나눠서 보내는 것.
웹 클라이언트가 서버에게 파이을 업로드 할 때, http 프로토콜의 바디 부분에 파일정보를 담아서 전송을 하는데, 파일을 한번에 여러개 전송을 하면 body 부분에 파일이 여러개의 부분으롤 연결되어 전송된다. 이렇게 여러 부분으로 나뉘어서 전송되는 것을 Multipart data라고 한다.</li>
<li>보통 파일을 전송할 때 사용한다.</li>
</ul>
<h3 id="httpservletrequest는-파일-업로드를-지원하지-않는다"> HttpServletRequest는 파일 업로드를 지원하지 않는다.</h3>
<ul>
<li>HttpServletRequest는 웹 클라이언트가 전달하는 Multipart 데이터를 쉽게 처리하는 메소드를 제공하지 않는다.
(HttpServletRequest는 http 프로토콜의 body 부분을 읽어들이는 input 스트림안을 지원, 사용자는 이런 input 스트림을 이용해서 Multipart부분을 잘 나누어서 사용해야한다. 보통은 직접 구현하지 않고 라이브러리를 사용)</li>
<li>서블릿에서 파일 업로드를 처리하려면 별도의 라이브러리를 사용해야 한다. 대표적인 라이브러리가 아파치 재단의 commons-filedupload이다.</li>
</ul>
<h3 id="spring-mvc에서의-파일-업로드"> Spring MVC에서의 파일 업로드</h3>
<p>Spring MVC에서 파일 업로드 하려면 몇가지 라이브러리와 설정을 추가</p>
<ul>
<li>commons-fileupload, commons-io 라이브러리 추가</li>
<li>MultipartResolver Bean 추가</li>
<li>DispatcherServlet은 준비과정에서 &quot;multipart/form-data&quot;가 요청으로 올 경우 MultipartResolver를 사용한다.
(MultipartFile 매개변수를 사용하기 위해서는 MultipartResolver Bean이 등록되어있어야 한다.)</li>
</ul>
<div><pre><code><span>@Bean</span>
<span>public</span> <span>MultipartResolver</span> <span>multipartResolver</span><span>(</span><span>)</span><span>{</span>
    <span><span>org<span>.</span>springframework<span>.</span>web<span>.</span>multipart<span>.</span>commons<span>.</span></span>CommonsMultipartResolver</span> multipartResolver <span>=</span> <span>new</span> 
    <span><span>org<span>.</span>springframework<span>.</span>web<span>.</span>multipart<span>.</span>commons<span>.</span></span>CommonsMultipartResolver</span><span>(</span><span>)</span><span>;</span>
    
    multipartResolver<span>.</span><span>setMaxUplaodSize</span><span>(</span><span>10485760</span><span>)</span><span>;</span> <span>//1024 * 1024 * 10 (최대 10MB)</span>
    <span>return</span> multipartResolver<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>boot<span>.</span>autoconfigure<span>.</span>web<span>.</span>servlet</span><span>;</span>

<span>@Configuration</span><span>(</span>proxyBeanMethods <span>=</span> <span>false</span><span>)</span>
<span>@ConditionalOnClass</span><span>(</span><span>{</span> <span>Servlet</span><span>.</span><span>class</span><span>,</span> <span>StandardServletMultipartResolver</span><span>.</span><span>class</span><span>,</span> <span>MultipartConfigElement</span><span>.</span><span>class</span> <span>}</span><span>)</span>
<span>@ConditionalOnProperty</span><span>(</span>prefix <span>=</span> <span>"spring.servlet.multipart"</span><span>,</span> name <span>=</span> <span>"enabled"</span><span>,</span> matchIfMissing <span>=</span> <span>true</span><span>)</span>
<span>@ConditionalOnWebApplication</span><span>(</span>type <span>=</span> <span>Type</span><span>.</span>SERVLET<span>)</span>
<span>@EnableConfigurationProperties</span><span>(</span><span>MultipartProperties</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>class</span> <span>MultipartAutoConfiguration</span> <span>{</span>

	<span>private</span> <span>final</span> <span>MultipartProperties</span> multipartProperties<span>;</span>

	<span>public</span> <span>MultipartAutoConfiguration</span><span>(</span><span>MultipartProperties</span> multipartProperties<span>)</span> <span>{</span>
		<span>this</span><span>.</span>multipartProperties <span>=</span> multipartProperties<span>;</span>
	<span>}</span>

	<span>@Bean</span>
	<span>@ConditionalOnMissingBean</span><span>(</span><span>{</span> <span>MultipartConfigElement</span><span>.</span><span>class</span><span>,</span> <span>CommonsMultipartResolver</span><span>.</span><span>class</span> <span>}</span><span>)</span>
	<span>public</span> <span>MultipartConfigElement</span> <span>multipartConfigElement</span><span>(</span><span>)</span> <span>{</span>
		<span>return</span> <span>this</span><span>.</span>multipartProperties<span>.</span><span>createMultipartConfig</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>

	<span>@Bean</span><span>(</span>name <span>=</span> <span>DispatcherServlet</span><span>.</span>MULTIPART_RESOLVER_BEAN_NAME<span>)</span>
	<span>@ConditionalOnMissingBean</span><span>(</span><span>MultipartResolver</span><span>.</span><span>class</span><span>)</span>
	<span>public</span> <span>StandardServletMultipartResolver</span> <span>multipartResolver</span><span>(</span><span>)</span> <span>{</span>
		<span>StandardServletMultipartResolver</span> multipartResolver <span>=</span> <span>new</span> <span>StandardServletMultipartResolver</span><span>(</span><span>)</span><span>;</span>
		multipartResolver<span>.</span><span>setResolveLazily</span><span>(</span><span>this</span><span>.</span>multipartProperties<span>.</span><span>isResolveLazily</span><span>(</span><span>)</span><span>)</span><span>;</span>
		<span>return</span> multipartResolver<span>;</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>MultipartResolver는 SpringMVC에서 기본적으로 등록해주지 않지만, SpringBoot에서는 위와 같이 MultipartAutoConfiguration클래스에서 MultipartResolver Bean이 등록되어있지 않는 경우 자동으로 Bean을 등록해준다. 따라서 SpringBoot에서는 별도의 설정없이 MultipartFile 매개변수를 사용할 수 있다.</p>
<br>
<h2 id="_1225-authenticationprincipal"> 1225 - @AuthenticationPrincipal</h2>
<p>스프링 시큐리티는 SecurityContext에 인증된 Authentication 객체를 넣어두고 현재 스레드 내에서 공유되도록 관리하고 있다.
보통은 인증 이후 @AuthenticationPrincipal 어노테이션을 통해 UserDetails 인터페이스를 구현한 유저 객체를 주입할 때 사용하는 편이다.</p>
<p>관련 클래스와 인터페이스</p>
<ul>
<li>SecurityContext : 인터페이스. Security Context 인터페이스. Authentication에 대한 접근 getter를 정의해 놓았다.</li>
<li>SecurityContextImpl : 클래스. SecurityContext 인터페이스를 구현한 객체 Authentication 객체에 대한 getter/setter를 정의해 놓은 객체. 해당 구현체를 통해 내부적으로 현재 스레드의 Security Context를 생성하여 인증 후 Authentication 객체를 넣어놓는 역할을 한다.</li>
<li>Authentication : 인증 정보에 대한 부분을 정의해놓은 인터페이스. Principal과 같은 Credentials, Authorities 에 대한 정의가 되어있다. 여러 구현체가 있다. (ex. UsernamePasswordAuthenticationToken)
<ul>
<li>Principal의 의미는 &quot;인증되는 주체의 ID&quot;</li>
<li>Credentials은 &quot;주체가 정확한지 증명하는 것&quot;</li>
<li>Authorities는 &quot;권한&quot;</li>
</ul>
</li>
<li>UserDetails : 사용자 정보를 가지는 인터페이스. 이를 구현하여 실제 로그인에 사용할 클래스를 만들면 되고, 스프링 시큐리티 내부적으로 직접 사용하지는 않고 Authentication으로 캡슐화하여 저장된다. 따라서 UserDetails구현체의 정보는 Spring Security Context에 저장된 Authentication 객체가 가져간다.</li>
<li>HandlerMethodArgumentResolver : 인터페이스. 특정 적략에 따라 한 request에서 넘어온 인자들을 메소드 파라미터로 해석할 수 있도록 도와줌</li>
<li>AuthenticationPrincipalArgumentResolver : 스프링 시큐리티에서 HandlerMethodArgumentResolver를 구현한 구현체로 @AuthenticationPrincipal 어노테이션이 실제로 사용되는 부분.</li>
</ul>
<h3 id="동작-원리"> 동작 원리</h3>
<p>현재 스레드가 세션을 물고 있다면 이미 SecurityContextHolder의 getContext() 메소드를 통해 SecurityContext 객체를 얻고 그 안의 getAuthentication() 메소드를 통해 Authentication (인증객체)를 얻을 수 있다.</p>
<div><pre><code><span>@PostMapping</span><span>(</span>value <span>=</span> <span>"/logout"</span><span>,</span> 
             consumes <span>=</span> <span>MediaTypes</span><span>.</span>HAL_JSON_VALUE<span>,</span> 
             produces <span>=</span> <span>MediaTypes</span><span>.</span>HAL_JSON_VALUE<span>)</span>
<span>public</span> <span>Object</span> <span>logout</span><span>(</span><span>@AuthenticationPrincipal</span> <span>SecurityUser</span> securityUser<span>,</span> 
                     <span>@RequestHeader</span><span>(</span><span>"Authorization"</span><span>)</span> <span>String</span> authorization<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>// 컨트롤러 로직</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>Spring Security를 사용하는 경우, AuthenticationPrincipalArgumentResolver 클래스를 활용하여 resolveArgument 메소드를 구현하고 SecurityContext에 저장된 인증객체를 기반으로 Authentication 객체를 꺼내오게 된다.</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>AuthenticationPrincipalArgumentResolver</span> <span>implements</span> <span>HandlerMethodArgumentResolver</span> <span>{</span>

	<span>private</span> <span>ExpressionParser</span> parser <span>=</span> <span>new</span> <span>SpelExpressionParser</span><span>(</span><span>)</span><span>;</span>

	<span>private</span> <span>BeanResolver</span> beanResolver<span>;</span>

	<span>@Override</span>
	<span>public</span> <span>boolean</span> <span>supportsParameter</span><span>(</span><span>MethodParameter</span> parameter<span>)</span> <span>{</span>
		<span>return</span> <span>findMethodAnnotation</span><span>(</span><span>AuthenticationPrincipal</span><span>.</span><span>class</span><span>,</span> parameter<span>)</span> <span>!=</span> <span>null</span><span>;</span>
	<span>}</span>

	<span>@Override</span>
	<span>public</span> <span>Object</span> <span>resolveArgument</span><span>(</span><span>MethodParameter</span> parameter<span>,</span> <span>ModelAndViewContainer</span> mavContainer<span>,</span>
			<span>NativeWebRequest</span> webRequest<span>,</span> <span>WebDataBinderFactory</span> binderFactory<span>)</span> <span>{</span>
            
        <span>// Security Context에서 꺼내욘 객체를 기반으로 한다.</span>
		<span>Authentication</span> authentication <span>=</span> <span>SecurityContextHolder</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>.</span><span>getAuthentication</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span>authentication <span>==</span> <span>null</span><span>)</span> <span>{</span>
			<span>return</span> <span>null</span><span>;</span>
		<span>}</span>

        <span>// 인증객체에서 Principal을 꺼낸다.</span>
		<span>Object</span> principal <span>=</span> authentication<span>.</span><span>getPrincipal</span><span>(</span><span>)</span><span>;</span>

        <span>// 해당 어노테이션이 붙은 파라미터가 존재하는지 찾는다.</span>
		<span>AuthenticationPrincipal</span> annotation <span>=</span> <span>findMethodAnnotation</span><span>(</span><span>AuthenticationPrincipal</span><span>.</span><span>class</span><span>,</span> parameter<span>)</span><span>;</span>
		<span>String</span> expressionToParse <span>=</span> annotation<span>.</span><span>expression</span><span>(</span><span>)</span><span>;</span>
		<span>if</span> <span>(</span><span>StringUtils</span><span>.</span><span>hasLength</span><span>(</span>expressionToParse<span>)</span><span>)</span> <span>{</span>
			<span>StandardEvaluationContext</span> context <span>=</span> <span>new</span> <span>StandardEvaluationContext</span><span>(</span><span>)</span><span>;</span>
			context<span>.</span><span>setRootObject</span><span>(</span>principal<span>)</span><span>;</span>
			context<span>.</span><span>setVariable</span><span>(</span><span>"this"</span><span>,</span> principal<span>)</span><span>;</span>
			context<span>.</span><span>setBeanResolver</span><span>(</span><span>this</span><span>.</span>beanResolver<span>)</span><span>;</span>
			<span>Expression</span> expression <span>=</span> <span>this</span><span>.</span>parser<span>.</span><span>parseExpression</span><span>(</span>expressionToParse<span>)</span><span>;</span>
			principal <span>=</span> expression<span>.</span><span>getValue</span><span>(</span>context<span>)</span><span>;</span>
		<span>}</span>
		<span>if</span> <span>(</span>principal <span>!=</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>parameter<span>.</span><span>getParameterType</span><span>(</span><span>)</span><span>.</span><span>isAssignableFrom</span><span>(</span>principal<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>
			<span>if</span> <span>(</span>annotation<span>.</span><span>errorOnInvalidType</span><span>(</span><span>)</span><span>)</span> <span>{</span>
				<span>throw</span> <span>new</span> <span>ClassCastException</span><span>(</span>principal <span>+</span> <span>" is not assignable to "</span> <span>+</span> parameter<span>.</span><span>getParameterType</span><span>(</span><span>)</span><span>)</span><span>;</span>
			<span>}</span>
			<span>return</span> <span>null</span><span>;</span>
		<span>}</span>

        <span>// principal 리턴</span>
		<span>return</span> principal<span>;</span>
	<span>}</span>

	<span>public</span> <span>void</span> <span>setBeanResolver</span><span>(</span><span>BeanResolver</span> beanResolver<span>)</span> <span>{</span>
		<span>this</span><span>.</span>beanResolver <span>=</span> beanResolver<span>;</span>
	<span>}</span>

	<span>private</span> <span><span>&lt;</span><span>T</span> <span>extends</span> <span>Annotation</span><span>></span></span> <span>T</span> <span>findMethodAnnotation</span><span>(</span><span>Class</span><span><span>&lt;</span><span>T</span><span>></span></span> annotationClass<span>,</span> <span>MethodParameter</span> parameter<span>)</span> <span>{</span>
		<span>T</span> annotation <span>=</span> parameter<span>.</span><span>getParameterAnnotation</span><span>(</span>annotationClass<span>)</span><span>;</span>
		<span>if</span> <span>(</span>annotation <span>!=</span> <span>null</span><span>)</span> <span>{</span>
			<span>return</span> annotation<span>;</span>
		<span>}</span>
		<span>Annotation</span><span>[</span><span>]</span> annotationsToSearch <span>=</span> parameter<span>.</span><span>getParameterAnnotations</span><span>(</span><span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>Annotation</span> toSearch <span>:</span> annotationsToSearch<span>)</span> <span>{</span>
			annotation <span>=</span> <span>AnnotationUtils</span><span>.</span><span>findAnnotation</span><span>(</span>toSearch<span>.</span><span>annotationType</span><span>(</span><span>)</span><span>,</span> annotationClass<span>)</span><span>;</span>
			<span>if</span> <span>(</span>annotation <span>!=</span> <span>null</span><span>)</span> <span>{</span>
				<span>return</span> annotation<span>;</span>
			<span>}</span>
		<span>}</span>
		<span>return</span> <span>null</span><span>;</span>
	<span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br></div></div><p>컨트롤러의 파라미터마다 해당 resolveArgument 메소드가 실행된다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>0110 - 0116</title>
      <link>ahnjs/TIL/2022/0110/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0110/</guid>
      <source url="ahnjs/TIL/rss.xml">0110 - 0116</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0110-0116"> 0110 - 0116</h1>
<h2 id="_0110-arrays-aslist-와-list-of-의-차이"> 0110 - Arrays.asList()와 List.of()의 차이</h2>
<p>Arrays.asList와 List.of 둘 다 고정된 크기의 리스트를 제공하기 때문에 새 요소를 추가하거나 삭제하려고 하면 <code>UnsupportedOperationException</code>이 발생한다. 그렇다면 둘의 차이점은 무엇일까?</p>
<ol>
<li>List.of는 set으로 값 변경이 불가능하다.</li>
</ol>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> asList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> listOf <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>

asList<span>.</span><span>set</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>)</span><span>;</span>
listOf<span>.</span><span>set</span><span>(</span><span>0</span><span>,</span> <span>10</span><span>)</span><span>;</span>        <span>//UnsupportedOperationException</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>List.of는 set으로 값 변경을 시도하면 컴파일 에러가 발생하게 된다.</p>
<ol start="2">
<li>List.of는 null을 허용하지 않는다.</li>
</ol>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> asList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>null</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> listOf <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>null</span><span>)</span><span>;</span>        <span>//NPE</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>null을 받아들이는 Arrays.asList와 달리 List.of는 거부한다.</p>
<ol start="3">
<li>List.of는 null 여부를 contains 확인도 못하게 한다.</li>
</ol>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> asList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> listOf <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>

<span>boolean</span> asListResult <span>=</span> asList<span>.</span><span>contains</span><span>(</span><span>null</span><span>)</span><span>;</span>
<span>boolean</span> listOfResult <span>=</span> listOf<span>.</span><span>contains</span><span>(</span><span>null</span><span>)</span><span>;</span>        <span>//NPE</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="4">
<li>Arrays.asList는 원본의 배열의 변화에 반응한다.</li>
</ol>
<div><pre><code><span>Integer</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>

<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> asList <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>arr<span>)</span><span>;</span>
<span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> listOf <span>=</span> <span>List</span><span>.</span><span>of</span><span>(</span>arr<span>)</span><span>;</span>

arr<span>[</span><span>0</span><span>]</span> <span>=</span> <span>10</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>asList<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>listOf<span>)</span><span>;</span>
<span>/*
[10, 2, 3]
[1, 2, 3]
 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>arr의 값이 변하면 asList의 값 또한 변한다.</p>
<br>
<h2 id="_0112-database-connection-pool이란"> 0112 - Database Connection Pool이란</h2>
<p>DB Connection Pool에 대해 알아보기 전에 우선 JDBC에 대해 알아보면 기본적으로 JDBC는 다음과 같은 과정을 거친다.</p>
<div><pre><code>1. DB벤더에 맞는 드라이버 로드
2. DB서버의 IP, ID, PW등을 DriverManager 클래스의 getConnection 메소드를 사용하여 Connection 객체 생성
3. Connection으로 부터 PreparedStatement 객체를 받음
4. executeQurey를 수행하고 ResultSet객체를 받아 데이터를 처리
5. 사용했던 ResultSet, PreparedStatedment, Connection을 close 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>이러한 일련의 과정을 거쳐 Java 어플리케이션과 Database가 연동이 되어 원하는 데이터를 처리할 수 있다. 이 과정중에서 가장 오래 걸리는 부분을 예상한다면 2번 과정의 Connection 객체를 얻는 부분이다. 이유는 DB서버와 애플리케이션 서버 사이의 통신이기에 같은 장비에 둘다 존재하더라도 시간이 걸리기 때문이다. 만일 사용자가 급증한다면 서버 환경에선 반복적으로 Connection 객체를 얻기 위해 엄청난 시간을 소모할 것이다.</p>
<p>만약에 이러한 필요한 양만큼 Connection 객체를 미리 얻어놓는다면 Connection 객체를 생성하는 부분에서 발생하는 대기 시간을 줄이고 네트워크의 부담을 줄일 수 있다. 이때 등장한 개념이 DB Connection Pool이다.</p>
<h3 id="dbcp-database-connection-pool"> DBCP(DataBase Connection Pool)</h3>
<p>DBCP는 Database Connection Pool의 약자로 DB와 커넥션을 맺고 있는 객체를 관리하는 역할을 한다.
DBCP를 사용하게 되면, WAS 실행 시 미리 일정량의 DB Connection 객체를 생성하고 Pool이라는 공간에 저장해 둔다. 그리고 DB 연결 요청이 있을 시, Pool에서 Connection 객체를 가져다 쓰고 반환하도록 한다. DBCP를 사용하는 가장 큰 이유는 효율성이다.</p>
<h3 id="hikaricp란"> HikariCP란?</h3>
<p>HikariCP란 Springboot 2.0부터 default로 설정되어 있는 DB Connection Pool로써 Zero-Overhead가 특징으로 높은 성능을 자랑하는 DBCP이다. 미리 정해놓은 만큼 Connection을 Connection Pool에 담아 놓고 요청이 들어오면 Thread가 Connection을 요청하고, Hikari는 Connection Pool내에 있는 Connection을 연결해주는 역할을 한다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>0124 - 0206</title>
      <link>ahnjs/TIL/2022/0124/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0124/</guid>
      <source url="ahnjs/TIL/rss.xml">0124 - 0206</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0124-0206"> 0124 - 0206</h1>
<h2 id="_0125-jpa-사용시-엔티티-상태-확인하기"> 0125 - JPA 사용시 엔티티 상태 확인하기</h2>
<p>JPA를 사용할 때 반드시 알아야 하는 것중 하나가 엔티티 객체의 상태 변화인데 JPA를 쓰면서 Transient(New), Persistent, Detached, Deleted 이런 상태 변화와 그 특징에 대한 공부를 한적이 없다면 JPA를 잘못쓰고 있을 가능성이 크다.</p>
<p>이 중에서도 Persistent 상태가 가장 중요한데, 하이버네이트가 한 트랜잭션 내에서 불필요한 쿼리를 줄요주는 역할을 하기 때문이다. 흔히 1차 캐시라고 부르는 Persistent Context가 해당 인스턴스를 이미 담고 있기 때문에 DB에서 쿼리를 하더라도 불필요한 select 쿼리가 발생하지 않는다.</p>
<div><pre><code><span>private</span> <span>void</span> <span>savePost</span><span>(</span><span>)</span> <span>{</span>
    <span>Post</span> post <span>=</span> <span>new</span> <span>Post</span><span>(</span><span>)</span><span>;</span>
    post<span>.</span><span>setTitle</span><span>(</span><span>"keesun"</span><span>)</span><span>;</span>
    
    <span>Post</span> newPost <span>=</span> postRepository<span>.</span><span>save</span><span>(</span>post<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>postRepository<span>.</span><span>findById</span><span>(</span>newPost<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>새 글을 저장하고 findById를 통해 id로로 저장했던 Post를 다시 가져오는 코드이다. 이 때 postRepository가 스프링 데이터 JPA를 사용하지 않고 스프링 JDBC를 사용해 구현하거나 스프링 데이터 JDBC를 사용해 구현했다면 이 코드는 분명히 insert 쿼리 이후에 select 쿼리가 발생한다.</p>
<p>하지만, postRepository를 스프링 데이터 JPA가 제공하는 JpaRepository 인터페이스를 상속받아 구현했다면, 이 코드는 insert 쿼리만 발생하고 select 쿼리는 발생하지 않는게 이론적으로 맞다. save()를 호출 했을 떄 newPost(post와 같은 인스턴스)가 Persistent 상태로 영속화 컨텍스트인 EntityManager(또는 하이버네이트의 Session)에 캐시에 캐시가 되기 떄문이다. 그래서 해당 id를 가지고 있는 Post 인스턴스를 DB에서 꺼내오는게 아니라 캐시하고 있는 메모리에서 꺼내주고, 따라서 select 쿼리는 발생하지 않는게 맞다.</p>
<p>그리고 실제 해당 객체가 Persistent 상태인지 확인하려면 EntityManager를 주입 받아서 contains 메소드를 통해 확인할 수 있다.</p>
<div><pre><code>entityManager<span>.</span><span>contains</span><span>(</span>post<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>확인</li>
</ul>
<div><pre><code><span>@Component</span>
<span>public</span> <span>class</span> <span>JpaRunner</span> <span>implements</span> <span>ApplicationRunner</span> <span>{</span>

    <span>@PersistenceContext</span>
    <span>EntityManager</span> entityManager<span>;</span>

    <span>@Autowired</span>
    <span>PostRepository</span> postRepository<span>;</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>ApplicationArguments</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>savePost</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Transactional</span>
    <span>private</span> <span>void</span> <span>savePost</span><span>(</span><span>)</span> <span>{</span>
        <span>Post</span> post <span>=</span> <span>new</span> <span>Post</span><span>(</span><span>)</span><span>;</span>
        post<span>.</span><span>setTitle</span><span>(</span><span>"keesun"</span><span>)</span><span>;</span>

        <span>Post</span> newPost <span>=</span> postRepository<span>.</span><span>save</span><span>(</span>post<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>postRepository<span>.</span><span>findById</span><span>(</span>newPost<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entityManager<span>.</span><span>contains</span><span>(</span>newPost<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ul>
<li>결과</li>
</ul>
<div><pre><code>2020-08-26 22:04:22.546  INFO 54359 --- [           main] m.w.demodomainclassconverter.App         : Started App in 2.062 seconds (JVM running for 2.458)
Hibernate: call next value for hibernate_sequence
Hibernate: insert into post (title, id) values (?, ?)
Hibernate: select post0_.id as id1_0_0_, post0_.title as title2_0_0_ from post post0_ where post0_.id=?
Optional[me.whiteship.demodomainclassconverter.Post@7ac48e10]
false
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>insert 쿼리 이후에 select 쿼리가 발생했고, EntityManager의 contains를 통해 Persistent 상태가 맞는지(EntityManager) 확인시 false가 출력됐다. 문제는 savePost 메소드에 트랜잭션이 적용되지 않아서 이다.</p>
<p>결론은 간단하지만 구체적으로 '왜 트랜잭션이 적용되지 않았지?'에 답하려면 스프링이 애노테이션 기반의 트랜잭션을 어떻게 처리하는지 이해해야 하는데 @Transaction이라는 애노테이션을 쓰는건 맞지만 private 메소드에 쓰는건 무의미하다. 오버라이딩이 가능한 메소드에 써야한다. 그렇다면 savePost() 메소드를 public으로 변경해보자.</p>
<div><pre><code><span>@Transactional</span>
<span>public</span> <span>void</span> <span>savePost</span><span>(</span><span>)</span> <span>{</span>
    <span>Post</span> post <span>=</span> <span>new</span> <span>Post</span><span>(</span><span>)</span><span>;</span>
    post<span>.</span><span>setTitle</span><span>(</span><span>"keesun"</span><span>)</span><span>;</span>

    <span>Post</span> newPost <span>=</span> postRepository<span>.</span><span>save</span><span>(</span>post<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>postRepository<span>.</span><span>findById</span><span>(</span>newPost<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entityManager<span>.</span><span>contains</span><span>(</span>newPost<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>public 메소드로 바꿨지만 이렇게 해도 savePost()에는 트랜잭션이 적용되지 않고 영속화 컨텍스트는 newPost를 캐싱하지 않는다. 그래서 결과는 private 메소드를 사용했을 때와 동일하다. 그 이유는 스프링의 트랜잭션 처리가 스프링 AOP를 기반으로 하고 있으며 스프링 AOP가 다이나믹 프록시를 기반으로 동작한다는 것을 알고 있다면 이렇게 해도 트랜잭션이 적용되지 않는 이유를 이해할 수 있을 것이다.</p>
<p>프록시 기반 AOP의 단점중에 하나인 프록시 내부에서 내부를 호출할 때는 부가적인 서비스(여기서는 그게 바로 트랜잭션)가 적용되지 않는다. 호출하려는 타겟을 감싸고 있는 프록시를 통해서만 부가적인 기능이 적용되는데 프록시 내부에서 내부를 호출 할 때는 감싸고 있는 영역을 거치지 않기 때문이다.</p>
<p>!(image)[https://www.whiteship.me/content/images/size/w1000/2020/08/Screen-Shot-2020-08-27-at-20.28.13.png]</p>
<p>프록시로 감싼 타겟(JpaRunner)를 외부에서 호출할 때 run()이라는 public 메소드를 호출하는데 (ApplicationRunner를 구현했기 때문에) 이 때 run() 메소드에는 트랜잭션이 적용되지 않는다. 왜냐면 @Transactional을 savePost()만 붙였기 때문이다. 그런데 그렇게 호출한 run()이 내부에서 @Transactional을 사용한 savePost()를 호출하더라도, JpaRunner 밖에서 호출이 되는게 아니라 프록시 내부에서 savePost()를 바로 호출하기 때문에 타겟을 감싼 트랜잭션이 적용되지 않는 것이다. 차라리 JpaRunner밖에서 savePost() 메소드를 바로 호출했다면 트랜잭션이 적용됐을 것이다.</p>
<p>해결하는 방식은 여러가지 방법이 있지만 제일 간단한 방법은 @Transactional을 run() 메소드로 옮기면 된다. 그럼 run()을 호출 할때부터 트랜잭션이 적용되면서 그 메소드에서 호출하는 다른 메소드도 전부 해당 트랜잭션 안에서 처리하기 때문에 insert 쿼리 이후에 select도 발생하지 않으며 EntityManager의 contains 메소드가 true를 릴턴하는 것을 확인할 수 있다.</p>
<div><pre><code><span>@Transactional</span>
<span>@Override</span>
<span>public</span> <span>void</span> <span>run</span><span>(</span><span>ApplicationArguments</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    <span>savePost</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>void</span> <span>savePost</span><span>(</span><span>)</span> <span>{</span>
    <span>Post</span> post <span>=</span> <span>new</span> <span>Post</span><span>(</span><span>)</span><span>;</span>
    post<span>.</span><span>setTitle</span><span>(</span><span>"keesun"</span><span>)</span><span>;</span>

    <span>Post</span> newPost <span>=</span> postRepository<span>.</span><span>save</span><span>(</span>post<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>postRepository<span>.</span><span>findById</span><span>(</span>newPost<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>entityManager<span>.</span><span>contains</span><span>(</span>newPost<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><br>
<h2 id="_0202-allargsconstructor-requiredargsconstructor의-staticname-옵션"> 0202 - AllArgsConstructor, RequiredArgsConstructor의 staticName 옵션</h2>
<h3 id="staticname-옵션"> staticName 옵션</h3>
<p>staticName 옵션을 사용하여 생성자를 private로 생성하고, private 생성자를 감싸고 있는 static factory 메소드를 추가 할 수 있다.</p>
<div><pre><code><span>@AllArgsConstructor</span><span>(</span>staticName <span>=</span> <span>"of"</span><span>)</span>
<span>public</span> <span>class</span> <span>TestDTO</span> <span>{</span>
    <span>private</span> <span>int</span> price<span>;</span>
    <span>private</span> <span>int</span> discount<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> amount<span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>

<span>@Getter</span>
<span>public</span> <span>class</span> <span>TestDTO</span> <span>{</span>
    <span>private</span> <span>int</span> price<span>;</span>
    <span>private</span> <span>int</span> discount<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> amount<span>;</span>

    <span>private</span> <span>TestDTO</span><span>(</span><span>int</span> amount<span>)</span><span>{</span>
        <span>this</span><span>.</span>amount <span>=</span> amount<span>;</span>
    <span>}</span>


    <span>public</span> <span>static</span> <span>TestDTO</span> <span>of</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
       <span>return</span> <span>new</span> <span>TestDTO</span><span>(</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>private 생성자가 생성되고, private 생성자를 감싸는 static factory 메소드 생성</p>
<div><pre><code><span>class</span> <span>TestDTOTest</span> <span>{</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test1</span><span>(</span><span>)</span><span>{</span>
        <span>TestDTO</span> testDTO <span>=</span> <span>TestDTO</span><span>.</span><span>of</span><span>(</span><span>4</span><span>)</span><span>;</span>
        <span>assertNotNull</span><span>(</span>testDTO<span>)</span><span>;</span>
        <span>assertEquals</span><span>(</span><span>0</span><span>,</span> testDTO<span>.</span><span>getPrice</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>assertEquals</span><span>(</span><span>0</span><span>,</span> testDTO<span>.</span><span>getDiscount</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>assertEquals</span><span>(</span><span>4</span><span>,</span> testDTO<span>.</span><span>getAmount</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"testDTO.getPrice() = "</span> <span>+</span> testDTO<span>.</span><span>getPrice</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"testDTO.getDiscount() = "</span> <span>+</span> testDTO<span>.</span><span>getDiscount</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"testDTO.getAmount() = "</span> <span>+</span> testDTO<span>.</span><span>getAmount</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h4 id="정적-팩토리-메소드의-장단점"> 정적 팩토리 메소드의 장단점</h4>
<p>장점</p>
<ul>
<li>이름이 있으므로 생성자에 비해 가독성이 좋다</li>
<li>호출할 때마다 새로운 객체를 생성할 필요가 없다</li>
<li>하위 자료형 객체를 반환할 수 있다</li>
<li>형인자 자료형(parameterized type) 객체를 만들 때 편하다</li>
</ul>
<p>단점</p>
<ul>
<li>정적 팩토리 메서드만 있는 클래스라면, 생성자가 없으므로 하위 클래스를 못 만든다</li>
<li>정적 팩토리 메서드는 다른 정적 메서드와 잘 구분되지 않는다</li>
</ul>
<div><pre><code><span>// 하위 자료형 객체를 반환</span>
<span>class</span> <span>OrderUtil</span> <span>{</span>

    <span>public</span> <span>static</span> <span>Discount</span> <span>createDiscountItem</span><span>(</span><span>String</span> discountCode<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>if</span><span>(</span><span>!</span><span>isValidCode</span><span>(</span>discountCode<span>)</span><span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"잘못된 할인 코드"</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 쿠폰 코드인가? 포인트 코드인가?</span>
        <span>if</span><span>(</span><span>isUsableCoupon</span><span>(</span>discountCode<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>Coupon</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span><span>(</span><span>isUsablePoint</span><span>(</span>discountCode<span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>Point</span><span>(</span><span>500</span><span>)</span><span>;</span>
        <span>}</span>
        <span>throw</span> <span>new</span> <span>Exception</span><span>(</span><span>"이미 사용한 코드"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>Coupon</span> <span>extends</span> <span>Discount</span> <span>{</span> <span>}</span>
<span>class</span> <span>Point</span> <span>extends</span> <span>Discount</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>할인 코드의 규칙에 따라 Coupon과 Point 객체를 선택적으로 리턴하고 있다.<br>
이를 위해서는 두 하위 클래스가 같은 인터페이스를 구현하거나, 같은 부모 클래스를 갖도록 하면 된다.</p>
<p>만약 파일이 분리하기 애매한 작은 클래스가 있다면 private class를 활용할 수도 있다.</p>
<div><pre><code><span>// java.util.Collections에서 EMPTY_MAP 부분</span>
<span>@SuppressWarnings</span><span>(</span><span>"rawtypes"</span><span>)</span>
<span>public</span> <span>static</span> <span>final</span> <span>Map</span> EMPTY_MAP <span>=</span> <span>new</span> <span>EmptyMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

<span>/**
 * Returns an empty map (immutable).  This map is serializable.
 */</span>
<span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
<span>public</span> <span>static</span> <span>final</span> <span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>emptyMap</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span><span>Map</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span><span>)</span> EMPTY_MAP<span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>EmptyMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>extends</span> <span>AbstractMap</span><span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>></span></span> <span>implements</span> <span>Serializable</span> <span>{</span>
    <span>/* 생략 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>EmptyMap 클래스는 java.util.Collections 내에 private static으로 선언되어 있으며, emptyMap이라는 정적 팩토리 메서드를 통해 캐스팅된 인스턴스를 얻을 수 있다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>0117 - 0123</title>
      <link>ahnjs/TIL/2022/0117/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0117/</guid>
      <source url="ahnjs/TIL/rss.xml">0117 - 0123</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0117-0123"> 0117 - 0123</h1>
<h2 id="_0117-grasp-객체지향-설계기법"> 0117 - GRASP 객체지향 설계기법</h2>
<h3 id="grasp-pattern-general-responsibility-assignment-software-patterns-이란"> GRASP Pattern(General Responsibility Assignment Software Patterns)이란?</h3>
<ul>
<li>Object-Oriented 디자인의 핵심은 각 객체에 책임을 부여하는 것</li>
<li>책임을 부여하는 원칙들을 말하고 있는 패턴</li>
</ul>
<p>구체적인 구조는 없지만, 철학을 배울 수 있다.<br>
총 9가지의 원칙을 가지고 있다.</p>
<ol>
<li>High Cohesion(의존성 높게, 즉 높은 응집력)</li>
</ol>
<ul>
<li>각 객체가 밀접하게 연관된 책임들만 가지도록 구성.</li>
<li>한 객체, 한 시스템이 자기 자신이 부여받은 책임만을 수행하도록 짜임새 있게 구성</li>
<li>자신이 부여 받은 책임을 충족시키기 위해 다른 객체나 시스템을 참조하는 일이 적으며 자연스럽게 Low Coupling이 된다.</li>
</ul>
<ol start="2">
<li>Low Coupling(의존성 낮게)</li>
</ol>
<ul>
<li>객체들간, 서브 시스템들간의 상호의존도가 낮게 책임을 부여</li>
<li>각 객체, 서브시스템의 재 사용성을 높이고, 시스템 관리에 편하게 한다.</li>
<li>Object-Oriented 시스템은 각 객체들간의 Communication을 통하여 비즈니스를 완성시킴.</li>
<li>각 객체들 사이에 Coupling이 존재하지 않을 수는 없다.</li>
</ul>
<ol start="3">
<li>Information Expert!***</li>
</ol>
<ul>
<li>책임을 수행할 수 있는 데이터를 가지고 있는 객체에 책임을 부여한다.</li>
<li>객체는 데이터와 처리로직이 함께 묶여 있는 것.</li>
<li>정보 은닉을 통해 자신의 데이터를 감추고 오직 Method로만 데이터를 처리하고, 외부에는 그 기능(책임)만을 제공한다.</li>
</ul>
<ol start="4">
<li>Polymorphism(다형성)</li>
</ol>
<ul>
<li>객체의 종류에 따라 행동양식이 바뀐다면, Polymorphism 기능을 사용</li>
<li>만약 객체의 종류에 따라 행동이 바뀐다면 객체의 종류를 체크하는 조건물을 사용하지 말고 Object-Oriented 시스템의 Polymorphism 기능을 사용하라.</li>
</ul>
<ol start="5">
<li>Pure Fabrication</li>
</ol>
<ul>
<li>도메인에 관련된 문제를 대표하는 것이 아니라면 기능적인 책임을 별도로 한 곳으로 관리하는 객체를 만든다.</li>
<li>데이터베이스 정보를 저장하거나, 로그 정보를 기록하는 책임에 대해 생각해 보자. 각 정보는 각각의 객체들이 가지고 있을 것이다.</li>
<li>시스템 전반적으로 사용하고 있는 기능이 있다며, 공통적인 기능을 제고항하는 책임을 한 곳으로 모아서 가상의 객체, 서브시스템을 만들어라.</li>
</ul>
<ol start="6">
<li>Indirection</li>
</ol>
<ul>
<li>두 객체 사이의 직접적인 Coupling을 피하고 싶으면, 그 사이에 다른 매개체를 통해 전달하는 것.</li>
<li>주로 다른 매개체는 인터페이스인 경우가 많다.
<ul>
<li>그런 특별한 경우는 아래에 설명된 Protected Variations 패턴이라고 부를 수 있다.</li>
</ul>
</li>
</ul>
<ol start="7">
<li>Protected Variations</li>
</ol>
<ul>
<li>변경될 여지가 있는 곳에 안정된 인터페이스를 정의해서 사용하자.</li>
</ul>
<ol start="8">
<li>Creator</li>
</ol>
<ul>
<li>객체의 생성은 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면, 컨텍스트를 알고 있는 객체에 부여.</li>
<li>Factory Pattern</li>
</ul>
<ol start="9">
<li>Controller</li>
</ol>
<ul>
<li>시스템 이벤트(사용자 요청)를 처리할 객체르 만들자.</li>
</ul>
<br>
<h2 id="_0118-sql-애너테이션"> 0118 - @Sql 애너테이션</h2>
<h3 id="sql"> @Sql</h3>
<p>테스트 클래스나 ㅌ테스트 메서드에 부탁하는 에너테이션이며, 지정된 특정 SQL 스크립트 혹은 Statement를 수행시킨다. 통합테스트에서 편리하게 DB 스키마 생성과 초기 데이터 삽입 및 데이터 초기화 등을 수행할 수 있다.</p>
<ul>
<li>사용 예제</li>
</ul>
<div><pre><code><span>@Sql</span><span>(</span><span>"classpath:/truncate.sql"</span><span>)</span>
<span>@ExtendWith</span><span>(</span><span>SpringExtension</span><span>.</span><span>class</span><span>)</span>
<span>@ContextConfiguration</span><span>(</span>classes <span>=</span> <span>AppConfig</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>class</span> <span>SqlTest</span> <span>{</span>
    <span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>각각의 테스트 메서드 실행 전 @Sql 에너테이션이 지정한 스크립트를 실행한다.</li>
<li>excutionPhase로 스크립트의 실행 시점을 조정할 수 있으며, 기본값은 BEFORE_TEST_METHOD다.</li>
<li>@Sql({&quot;a.sql&quot;, &quot;b.sql&quot;, &quot;c.sql&quot;}) 과 같이 복수의 스크립트 파일을 지정할 수 있다.</li>
</ul>
<br>
<h2 id="_0121-java-optional-바르게-쓰기"> 0121 - Java Optional 바르게 쓰기</h2>
<h3 id="optional을-만든-의도"> Optional을 만든 의도</h3>
<p>Brian Goetz는 스텍오버플로우에서 Optional을 만든 의도에 대해 다음과 같이 말했다.</p>
<blockquote>
<p>… it was not to be a general purpose Maybe type, as much as many people would have liked us to do so. Our intention was to provide a limited mechanism for library method return types where there needed to be a clear way to represent “no result” …<br>
Optional은 많은 사람들이 우리(자바 언어 설계자)에게 기대했던 범용적인 Maybe 타입과는 다르다. 라이브러리 메서드가 반환할 결과값이 ‘없음’을 명백하게 표현할 필요가 있는 곳에서 제한적으로 사용할 수 있는 메커니즘을 제공하는 것이 Optional을 만든 의도였다.</p>
</blockquote>
<ul>
<li>java9 API Note</li>
</ul>
<blockquote>
<p>API Note:
Optional is primarily intended for use as a method return type where there is a clear need to represent “no result,” and where using null is likely to cause errors. A variable whose type is Optional should never itself be null; it should always point to an Optional instance.<br>
메서드가 반환할 결과값이 '없음'을 명백하게 표현할 필요가 있고, null을 반환하면 에러를 유발할 가능성이 높은 상황에서 메서드의 반환 타입으로 Optional을 사용하자는 것이 Optional을 만든 주된 목적이다. Optional 타입의 변수의 값은 절대 null 이어서는 안 되며, 항상 Optional 인스턴스를 가르켜야 한다.</p>
</blockquote>
<h3 id="올바른-사용법-java8-기준"> 올바른 사용법 (java8 기준)</h3>
<ol>
<li>isPresent()-get() 대신 orElse()/orElseGet()/orElseThrow()</li>
</ol>
<p>비싼 Optional을 사용할 경우 코드라도 줄여야 한다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
<span>if</span> <span>(</span>member<span>.</span><span>isPresent</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> member<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>

<span>// 좋음</span>
<span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
<span>return</span> member<span>.</span><span>orElse</span><span>(</span><span>null</span><span>)</span><span>;</span>



<span>// 안 좋음</span>
<span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
<span>if</span> <span>(</span>member<span>.</span><span>isPresent</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    <span>return</span> member<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>NoSuchElementException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 좋음</span>
<span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
<span>return</span> member<span>.</span><span>orElseThrow</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>new</span> <span>NoSuchElementException</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><ol start="2">
<li>orElse(new ...) 대신 orElseGet(() -&gt; new ...)</li>
</ol>
<p>orElse(...)에서 ...는 Optional에 값이 있든 없든 무조건 실행된다. 따라서 ...가 새로운 객체를 생성하거나 새로운 연산을 수행하는 경우에는 orElse() 대신 orElseGet()을 사용한다. orElseGet(Supplier)에서 Supplier는 Optional에 값이 없을 때만 실행된다. 따라서 Optional에 값이 없을 때만 새 객체를 생성하거나 새 연산을 수해아므로 불필요한 오버헤드가 없다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
<span>return</span> member<span>.</span><span>orElse</span><span>(</span><span>new</span> <span>Member</span><span>(</span><span>)</span><span>)</span><span>;</span>  <span>// member에 값이 있든 없든 new Member()는 무조건 실행됨</span>

<span>// 좋음</span>
<span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
<span>return</span> member<span>.</span><span>orElseGet</span><span>(</span><span>Member</span><span>::</span><span>new</span><span>)</span><span>;</span>  <span>// member에 값이 없을 때만 new Member()가 실행됨</span>

<span>// 좋음</span>
<span>Member</span> EMPTY_MEMBER <span>=</span> <span>new</span> <span>Member</span><span>(</span><span>)</span><span>;</span>
<span>.</span><span>.</span><span>.</span>
<span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member <span>=</span> <span>.</span><span>.</span><span>.</span><span>;</span>
<span>return</span> member<span>.</span><span>orElse</span><span>(</span>EMPTY_MEMBER<span>)</span><span>;</span>  <span>// 이미 생성됐거나 계산된 값은 orElse()를 사용해도 무방</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start="3">
<li>단지 값을 얻을 목적이라면 Optional 대신 null 비교</li>
</ol>
<p>Optional은 비싸다. 따라서 단순히 값 또는 null을 얻을 목적이라면 Optional 대신 null 비교를 사용한다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>return</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>status<span>)</span><span>.</span><span>orElse</span><span>(</span>READY<span>)</span><span>;</span>

<span>// 좋음</span>
<span>return</span> status <span>!=</span> <span>null</span> <span>?</span> status <span>:</span> READY<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="4">
<li>Optional 대신 비어있는 컬렉션 반환</li>
</ol>
<p>Optional은 비싸다. 그리고 컬렉션은 null이 아니라 비어있는 컬렉션을 반환하는 것이 좋을 때가 많다. 따라서 컬렉션은 Optional로 감싸서 반환하지 말고 비어있는 컬렉션을 반환한다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>List</span><span><span>&lt;</span><span>Member</span><span>></span></span> members <span>=</span> team<span>.</span><span>getMembers</span><span>(</span><span>)</span><span>;</span>
<span>return</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>members<span>)</span><span>;</span>

<span>// 좋음</span>
<span>List</span><span><span>&lt;</span><span>Member</span><span>></span></span> members <span>=</span> team<span>.</span><span>getMembers</span><span>(</span><span>)</span><span>;</span>
<span>return</span> members <span>!=</span> <span>null</span> <span>?</span> members <span>:</span> <span>Collections</span><span>.</span><span>emptyList</span><span>(</span><span>)</span><span>;</span>

<span>// 안 좋음</span>
<span>public</span> <span>interface</span> <span>MemberRepository</span><span><span>&lt;</span><span>Member</span><span>,</span> <span>Long</span><span>></span></span> <span>extends</span> <span>JpaRepository</span> <span>{</span>
    <span>Optional</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>Member</span><span>></span><span>></span></span> <span>findAllByNameContaining</span><span>(</span><span>String</span> part<span>)</span><span>;</span>
<span>}</span>

<span>// 좋음</span>
<span>public</span> <span>interface</span> <span>MemberRepository</span><span><span>&lt;</span><span>Member</span><span>,</span> <span>Long</span><span>></span></span> <span>extends</span> <span>JpaRepository</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Member</span><span>></span></span> <span>findAllByNameContaining</span><span>(</span><span>String</span> part<span>)</span><span>;</span>  <span>// null이 반환되지 않으므로 Optional 불필요</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ol start="5">
<li>Optional을 필드로 사용 금지</li>
</ol>
<p>Optional은 필드에 사용할 목적으로 만들어지지 않았으며, Serializable을 구현하지 않았다. 따라서 Optional은 필드로 사용하지 말자.</p>
<div><pre><code><span>// 안 좋음</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>

    <span>private</span> <span>Long</span> id<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>Optional</span><span><span>&lt;</span><span>String</span><span>></span></span> email <span>=</span> <span>Optional</span><span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>// 좋음</span>
<span>public</span> <span>class</span> <span>Member</span> <span>{</span>

    <span>private</span> <span>Long</span> id<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> email<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="6">
<li>Optional을 생성자나 메서드 인자로 사용 금지</li>
</ol>
<p>Optional을 생성자나 메서드 인자로 사용하면, 호출할 때마다 Optional을 생성해서 인자로 전달해줘야 한다. 하지만 호출되는 쪽, 즉 api나 라이브러리 메서드에서는 인자가 Optional 이든 아니든 null 체크를 하는 것이 언제나 안전하다. 따라서 굳이 비싼 Optional을 인자로 사용하지 말고 호출되는 쪽에 null 체크 책임을 남겨둔다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>public</span> <span>class</span> <span>HRManager</span> <span>{</span>
    
    <span>public</span> <span>void</span> <span>increaseSalary</span><span>(</span><span>Optional</span><span><span>&lt;</span><span>Member</span><span>></span></span> member<span>)</span> <span>{</span>
        member<span>.</span><span>ifPresent</span><span>(</span>member <span>-></span> member<span>.</span><span>increaseSalary</span><span>(</span><span>10</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
hrManager<span>.</span><span>increaseSalary</span><span>(</span><span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>member<span>)</span><span>)</span><span>;</span>

<span>// 좋음</span>
<span>public</span> <span>class</span> <span>HRManager</span> <span>{</span>
    
    <span>public</span> <span>void</span> <span>increaseSalary</span><span>(</span><span>Member</span> member<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>member <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            member<span>.</span><span>increaseSalary</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
hrManager<span>.</span><span>increaseSalary</span><span>(</span>member<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ol start="7">
<li>Optional을 컬렉션의 원소로 사용 금지</li>
</ol>
<p>컬렉션에는 많은 원소가 들어갈 수 있다. 따라서 비싼 Optional을 원소로 사용하지 말고 원소를 꺼낼때나 사용할 때 null 체크하는 것이 좋다. 특히 Map은 getOrDefault(), putIfAbsent(), computeIfAbsent(), computeIfPresent() 처럼 null 체크가 포함된 메서드를 제공하므로, Map의 원소로 Optional을 사용하지 말고 Map이 제공하는 메서드를 활용하는 것이 좋다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Optional</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> sports <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
sports<span>.</span><span>put</span><span>(</span><span>"100"</span><span>,</span> <span>Optional</span><span>.</span><span>of</span><span>(</span><span>"BasketBall"</span><span>)</span><span>)</span><span>;</span>
sports<span>.</span><span>put</span><span>(</span><span>"101"</span><span>,</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>someOtherSports<span>)</span><span>)</span><span>;</span>
<span>String</span> basketBall <span>=</span> sports<span>.</span><span>get</span><span>(</span><span>"100"</span><span>)</span><span>.</span><span>orElse</span><span>(</span><span>"BasketBall"</span><span>)</span><span>;</span>
<span>String</span> unknown <span>=</span> sports<span>.</span><span>get</span><span>(</span><span>"101"</span><span>)</span><span>.</span><span>orElse</span><span>(</span><span>""</span><span>)</span><span>;</span>

<span>// 좋음</span>
<span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> sports <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
sports<span>.</span><span>put</span><span>(</span><span>"100"</span><span>,</span> <span>"BasketBall"</span><span>)</span><span>;</span>
sports<span>.</span><span>put</span><span>(</span><span>"101"</span><span>,</span> <span>null</span><span>)</span><span>;</span>
<span>String</span> basketBall <span>=</span> sports<span>.</span><span>getOrDefault</span><span>(</span><span>"100"</span><span>,</span> <span>"BasketBall"</span><span>)</span><span>;</span>
<span>String</span> unknown <span>=</span> sports<span>.</span><span>computeIfAbsent</span><span>(</span><span>"101"</span><span>,</span> k <span>-></span> <span>""</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ol start="8">
<li>of(), ofNullable() 혼동 주의</li>
</ol>
<p>of(X)는 X가 null이 아님이 확실할 때만 사용해야 하며, X가 null이면 NFE이 발생한다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>return</span> <span>Optional</span><span>.</span><span>of</span><span>(</span>member<span>.</span><span>getEmail</span><span>(</span><span>)</span><span>)</span><span>;</span>  <span>// member의 email이 null이면 NPE 발생</span>

<span>// 좋음</span>
<span>return</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span>member<span>.</span><span>getEmail</span><span>(</span><span>)</span><span>)</span><span>;</span>


<span>// 안 좋음</span>
<span>return</span> <span>Optional</span><span>.</span><span>ofNullable</span><span>(</span><span>"READY"</span><span>)</span><span>;</span>

<span>// 좋음</span>
<span>return</span> <span>Optional</span><span>.</span><span>of</span><span>(</span><span>"READY"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol start="9">
<li>Optional<T> 대신 OptionalInt, OptionalLong, OptionalDouble</li>
</ol>
<p>Optional에 담길 값이 int, long, double이라면 Optional<T>를 사용하면 Boxing/Unboxing이 발생한다.</p>
<div><pre><code><span>// 안 좋음</span>
<span>Optional</span><span><span>&lt;</span><span>Integer</span><span>></span></span> count <span>=</span> <span>Optional</span><span>.</span><span>of</span><span>(</span><span>38</span><span>)</span><span>;</span>  <span>// boxing 발생</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span> <span>;</span> i <span>&lt;</span> count<span>.</span><span>get</span><span>(</span><span>)</span> <span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>  <span>// unboxing 발생</span>

<span>// 좋음</span>
<span>OptionalInt</span> count <span>=</span> <span>OptionalInt</span><span>.</span><span>of</span><span>(</span><span>38</span><span>)</span><span>;</span>  <span>// boxing 발생 안 함</span>
<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span> <span>;</span> i <span>&lt;</span> count<span>.</span><span>getAsInt</span><span>(</span><span>)</span> <span>;</span> i<span>++</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>  <span>// unboxing 발생 안 함</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><br>
<h2 id="_0122-java-serializable"> 0122 - Java Serializable</h2>
<h3 id="자바-직렬화"> 자바 직렬화</h3>
<p>간단하게는 Java 내부 시스템에서 사용되는(또는 JVM 메모리에 올려진) 객체나 데이터를 외부에서 사용할 수 있도록 Byte 형태로 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 이야기한다.</p>
<p>객체 직렬화는 객체의 상태를 바이트 스트림으로 변환하는데 사용되는 프로세스로, 디스크/파일로 유지되거나 네트워크 동신을 통해 실행중인 다른 Java 가상머신으로 전송될 수 있다. 역직렬화란 이러한 바이트 스트림을 다시 객체형태로 변환하는 작업을 말한다. 생성된 바이트는 플랫폼에 독립적이다.</p>
<ul>
<li>예제</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>io<span>.</span></span><span>Serializable</span><span>;</span>

<span>public</span> <span>class</span> <span>Member</span> <span>implements</span> <span>Serializable</span> <span>{</span>

    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>String</span> email<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Member</span><span>(</span><span>String</span> name<span>,</span> <span>String</span> email<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>email <span>=</span> email<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"Member{name='%s', email='%s', age='%s',"</span><span>,</span> name<span>,</span> email<span>,</span> age<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>직렬화 및 역직렬화 방법</li>
</ul>
<div><pre><code><span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayInputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ByteArrayOutputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectInputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>io<span>.</span></span><span>ObjectOutputStream</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Base64</span><span>;</span>

<span>// ObjectOutputStream 객체와 ObjectInputStream 객체를 사용</span>
<span>public</span> <span>class</span> <span>ObjectSerializableExam</span><span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>Member</span> member <span>=</span> <span>new</span> <span>Member</span><span>(</span><span>"임준영"</span><span>,</span> <span>"a790077714@gmail.com"</span><span>,</span> <span>30</span><span>)</span><span>;</span>
        <span>byte</span><span>[</span><span>]</span> serializedMember<span>;</span>

        <span>try</span><span>(</span><span>ByteArrayOutputStream</span> baos <span>=</span> <span>new</span> <span>ByteArrayOutputStream</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>try</span><span>(</span><span>ObjectOutputStream</span> oos <span>=</span> <span>new</span> <span>ObjectOutputStream</span><span>(</span>baos<span>)</span><span>)</span> <span>{</span>
                oos<span>.</span><span>writeObject</span><span>(</span>member<span>)</span><span>;</span>
                <span>// 직렬화된 member 객체</span>
                serializedMember <span>=</span> baos<span>.</span><span>toByteArray</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>// base64로 인코딩한 문자열</span>
        <span>String</span> base64Member <span>=</span> <span>Base64</span><span>.</span><span>getEncoder</span><span>(</span><span>)</span><span>.</span><span>encodeToString</span><span>(</span>serializedMember<span>)</span><span>;</span>

        <span>// base64로 디코딩한 문자열</span>
        <span>byte</span><span>[</span><span>]</span> deserializedMember <span>=</span> <span>Base64</span><span>.</span><span>getDecoder</span><span>(</span><span>)</span><span>.</span><span>decode</span><span>(</span>base64Member<span>)</span><span>;</span>

        <span>try</span><span>(</span><span>ByteArrayInputStream</span> bais <span>=</span> <span>new</span> <span>ByteArrayInputStream</span><span>(</span>deserializedMember<span>)</span><span>)</span> <span>{</span>
            <span>try</span><span>(</span><span>ObjectInputStream</span> ois <span>=</span> <span>new</span> <span>ObjectInputStream</span><span>(</span>bais<span>)</span><span>)</span> <span>{</span>
                <span>Object</span> objectMember <span>=</span> ois<span>.</span><span>readObject</span><span>(</span><span>)</span><span>;</span>
                <span>// member 객체로 역직렬화</span>
                <span>Member</span> readMember <span>=</span> <span>(</span><span>Member</span><span>)</span> objectMember<span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>member<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><ul>
<li>문자 형태의 직렬화 방법<br>
직접 데이터를 문자열 형태로 확인 가능한 직렬화 방법. 범용적인 API나 데이터를 변환하여 추출할 때 많이 사용. 표형태의 다량의 데이터를 직렬화시 CSV가 많이 쓰이고 구조적인 데이터는 이전엔 XML 최근에는 JSON을 많이 사용한다.</li>
</ul>
<h3 id="serialversionuid-사용-시-주의할점"> serialVersionUID 사용 시 주의할점</h3>
<p>serialVersionUID는 Java 직렬화 및 역지렬화 할때 필요한 버전 정보이다. 만약 객체를 직렬화하고 클래스에 멈버변수가 추가된다면 java.io.InvalidClassException 예외가 발생한다. Java 직렬화 스펙을 살펴보면 다음과 같다.</p>
<ul>
<li>serialVersionUID은 필수 값은 아니다.</li>
<li>호환 가능한 클래스는 serialVersionUID 값이 고정되어 있다.</li>
<li>serialVersionUID가 선언되어 있지 않으면 클래스의 기본 해쉬값을 사용한다.</li>
</ul>
<p>위의 스펙을 살펴보면 변경에 취약한 클래스가 변경되면 역직렬화 시에 예외가 발생할 수 있으니 개발자가 serialVersionUID 값을 직접 관리해주어야 혼란을 줄일 수 있다는 것을 의미한다. 하지만 그럼에도 불구하고 다른 문제가 발생할 수 있다. 만약 기존의 직렬화된 객체의 멤버 변수의 타입이 바뀐다면 마찬가지로 예외가 발생한다. 이걸 보면 Java직렬화는 상당히 타입에 엄격하다는 것을 확인할 수 있다. 즉, 특별한 문제가 없으면 Java 직렬화 버전 SerialVersionUID 값은 개발 시 직접 관리해줘야 한다. 값이 동일하다면 멤버 변수 및 메서드 추가는 크게 문제가 되지 않으며 멤버 변수 제거 및 이름 변경은 오류는 발생하지 않고 데이터가 누락된다.</p>
<h4 id="결론"> 결론</h4>
<p>최근에는 Json형태로 데이터를 저장하는 경우가 많아서 직렬화를 잘 사용하지 않는데 Json형태로 저장하는 것은 Class에서 취득할 수 있는 부분까지 저장하는 것이고 private까지 저장하는 것은 아니다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>0211 - 0220</title>
      <link>ahnjs/TIL/2022/0211/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0211/</guid>
      <source url="ahnjs/TIL/rss.xml">0211 - 0220</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0211-0220"> 0211 - 0220</h1>
<h2 id="_0213-쿼리-캐시"> 0213 - 쿼리 캐시</h2>
<ul>
<li>쿼리 캐시란, SELECT 쿼리문을 이용하여 조회한 값을 저장하고 있다가, 같은 쿼리 문을 요청하였을 때 미리 캐싱된 값을 반환하는 DBMS 기능이다</li>
<li>일반적인 웹사이트와 같이 쓰기 (WRITE)보다, 읽는(READ) 횟수가 많은 환경에서 유용하다</li>
<li>하지만, 멀티 코어 시스템 및 처리량이 높은 환경에서는 확장성이 좋지 않으므로 기본적으로 사용되지 않도록 설정된다</li>
</ul>
<h3 id="쿼리캐시-기능-사용하기"> 쿼리캐시 기능 사용하기</h3>
<ul>
<li>쿼리 캐시 기능을 사용할 수 있는지 확인하려면, 기본적으로 have_query_cache 설정이 되어 있어야 한다</li>
</ul>
<div><pre><code><span>SHOW</span> VARIABLES <span>LIKE</span> <span>'HAVE_QUERY_CACHE'</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>조회 결과 yes로 나온다면, 쿼리 캐시 기능을 사용할 수 있다는 뜻이다.</li>
</ul>
<div><pre><code><span>SHOW</span> VARIABLES <span>LIKE</span> <span>'QUERY_CACHE_TYPE'</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>그 다음에는 현재 시스템에서 쿼리 캐시 기능을 사용하고 있는지를 확인할 수 있다.</li>
</ul>
<h3 id="쿼리캐시가-되지-않는-경우"> 쿼리캐시가 되지 않는 경우</h3>
<p>아래와 같은 함수를 사용하면, 기본적으로 쿼리가 캐싱되지 않는다.</p>
<div><pre><code>BENCHMARK<span>(</span><span>)</span>
CONNECTION_ID<span>(</span><span>)</span>
CONVERT_TZ<span>(</span><span>)</span>
CURDATE<span>(</span><span>)</span>
<span>CURRENT_DATE</span><span>(</span><span>)</span>
<span>CURRENT_TIME</span><span>(</span><span>)</span>
<span>CURRENT_TIMESTAMP</span><span>(</span><span>)</span>
CURTIME<span>(</span><span>)</span>
<span>DATABASE</span><span>(</span><span>)</span>
ENCRYPT<span>(</span><span>)</span> <span>(</span>one parameter<span>)</span>
FOUND_ROWS<span>(</span><span>)</span>
GET_LOCK<span>(</span><span>)</span>
LAST_INSERT_ID<span>(</span><span>)</span>
LOAD_FILE<span>(</span><span>)</span>
MASTER_POS_WAIT<span>(</span><span>)</span>
<span>NOW</span><span>(</span><span>)</span>
RAND<span>(</span><span>)</span>
RELEASE_LOCK<span>(</span><span>)</span>
SLEEP<span>(</span><span>)</span>
SYSDATE<span>(</span><span>)</span>
UNIX_TIMESTAMP<span>(</span><span>)</span>
<span>(</span><span>no</span> parameters<span>)</span>
<span>USER</span><span>(</span><span>)</span>
UUID<span>(</span><span>)</span>
UUID_SHORT<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><ul>
<li>또한 쿼리에 아래와 같은 구문이 있을 경우 쿼리가 캐싱되지 않는다.</li>
</ul>
<div><pre><code><span>SELECT</span> SQL_NO_CACHE <span>.</span><span>.</span><span>.</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>INTO</span> <span>OUTFILE</span> <span>.</span><span>.</span><span>.</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>INTO</span> <span>DUMPFILE</span> <span>.</span><span>.</span><span>.</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>FOR</span> <span>UPDATE</span>
<span>SELECT</span> <span>*</span> <span>FROM</span> <span>.</span><span>.</span><span>.</span> <span>WHERE</span> autoincrement_column <span>IS</span> <span>NULL</span>
<span>SELECT</span> <span>.</span><span>.</span><span>.</span> <span>LOCK</span> <span>IN</span> <span>SHARE</span> <span>MODE</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="쿼리캐시-크기를-제한하기"> 쿼리캐시 크기를 제한하기</h3>
<div><pre><code><span>SHOW</span> VARIABLES <span>LIKE</span> <span>'query_cache_size'</span><span>;</span>

<span>SET</span> <span>GLOBAL</span> query_cache size <span>=</span> <span>80000000</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>쿼리 캐시 크기 설정</li>
</ul>
<h3 id="캐시-설정-및-의미"> 캐시 설정 및 의미</h3>
<div><pre><code><span>SHOW</span> <span>STATUS</span> <span>LIKE</span> <span>'Qcache%'</span><span>;</span>
<span>+</span><span>-------------------------+----------+</span>
<span>|</span> Variable_name           <span>|</span> <span>Value</span>    <span>|</span>
<span>+</span><span>-------------------------+----------+</span>
<span>|</span> Qcache_free_blocks      <span>|</span> <span>1158</span>     <span>|</span>
<span>|</span> Qcache_free_memory      <span>|</span> <span>3760784</span>  <span>|</span>
<span>|</span> Qcache_hits             <span>|</span> <span>31943398</span> <span>|</span>
<span>|</span> Qcache_inserts          <span>|</span> <span>42998029</span> <span>|</span>
<span>|</span> Qcache_lowmem_prunes    <span>|</span> <span>34695322</span> <span>|</span>
<span>|</span> Qcache_not_cached       <span>|</span> <span>652482</span>   <span>|</span>
<span>|</span> Qcache_queries_in_cache <span>|</span> <span>4628</span>     <span>|</span>
<span>|</span> Qcache_total_blocks     <span>|</span> <span>11123</span>    <span>|</span>
<span>+</span><span>-------------------------+----------+</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>
<li>Qcache_inserts는 현재, 캐싱된 쿼리의 값을 의미한다.</li>
<li>Qcache_hits는 쿼리를 캐싱하여, 캐싱된 값을 반환한 값을 의미한다</li>
<li>Qcache_lowmem_prunes는 메모리 값이 부족하여, 캐시에서 이전에 있던 값을 제거한 값이다</li>
<li>Qcache_lowmem_prunes 값을 줄이려면 앞서 말했던, query_cache_limit 값을 적절히 설정해줘야한다.</li>
</ul>
<h4 id="결론"> 결론</h4>
<ul>
<li>그 밖에도, query_cache_wlock_invalidate 옵션을 끄면, WRITE락이 걸려있더라도 캐싱된 값을 반환하게 하여, 경합 상태에서도 기다리지 않고 값을 읽을 수 있다</li>
<li>캐시된 쿼리를 잘 이용하면, 성능을 높일 수 있다</li>
<li>실제 SQL문은 대소문자를 구분하지 않지만, 캐싱된 쿼리 값을 반환받기 위해서는 대소문자까지 같아야 하므로, 팀 내에서 쿼리문을 통일성 있게 작성하는 노력을 해야할 것이다. 그 밖에도 동일한 쿼리라는 것을 인식하려면 여러 값들이 일정해야한다</li>
<li>쿼리 캐시 값의 크기를 크게 늘리면, 읽기 속도는 빨라지겠지만, 락 경합 때문에 쓰기 속도는 느려질 수 있다. 최적값을 찾아 적용해야 한다.</li>
</ul>
<br>
<h2 id="_0214-jackson-상세-정리"> 0214 - Jackson 상세 정리</h2>
<h3 id="jackson과-기존-gson-or-simplejson의-차이"> Jackson과 기존 GSON or SimpleJSON의 차이</h3>
<p>결론 적으로 차이는 없다. Jackson도 ObjectMapper API를 사용하여, 여타 GSON Ehsms SimpleJSON과 같이 객체에 데이터를 세팅해줘야 한다. 특별한 점은 Spring 프레임워크와 Jackson의 관계에서의 장점이 있다. Spring 3.0 이후부터, Jackson과 관련된 API를 제공함으로써, Jackson 라이브러리를 사용할때, 자동화 처리가 가능하게 되었다.</p>
<h3 id="jackson-동작"> Jackson 동작</h3>
<p>Spring 3.0 이후로 컨트롤러의 리턴 방식이 @ResponseBody 형식이라면, Spring은 MessageConverter API를 통해, 컨트롤러가 리턴하는 객체를 후킹 할 수 있다.<br>
Jackson은 JSON 데이터를 출력하기 위한 MappingJacksonHttpMessageConverter를 제공한다. 만약 우리가 스프링 MessageConverter를 MappingJacksonHttpMessageConverter으로 등록한다면, 컨트롤러가 리턴하는 객체를 다디 뜯어(자바 리플렉션 사용), Jackson의 ObjectMapper API로 JSON객체를 만들고 난 후, 출력하여 JSON 데이터를 완성한다. 나아가 Spring 3.1 이후로 classpath에 Jackson라이브러리가 존재한다면 자동적으로 MessageConverter가 등록된다</p>
<div><pre><code><span>@RequestMapping</span><span>(</span><span>"/json"</span><span>)</span>
<span>@ResponseBody</span>
<span>public</span> <span>Object</span> <span>printJSON</span><span>(</span><span>)</span> <span>{</span>
    <span>Person</span> person <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"Person"</span><span>,</span> <span>"Developer"</span><span>)</span><span>;</span>
    <span>return</span> person<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="jackson-특징"> Jackson 특징</h3>
<ul>
<li>Jackson은 기본적으로 프로퍼티로 동작한다</li>
<li>Java는 프로퍼티를 제공하는 문법이 없으므로 Getter와 Setter를 기준으로 작동한다(멤버변수의 유무가 아닌)</li>
</ul>
<h4 id="jackson의-데이터-매핑을-getter가-아닌-멤버변수-변경"> Jackson의 데이터 매핑을 Getter가 아닌 멤버변수 변경</h4>
<ul>
<li>Jackson은 @JsonProperty API를 통해 변경이 가능하다</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>@JsonProperty</span><span>(</span><span>"name"</span><span>)</span>
    <span>private</span> <span>String</span> myName <span>=</span> <span>"Person"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="jackson의-데이터-매핑-법칙-변경하기"> Jackson의 데이터 매핑 법칙 변경하기</h4>
<p>매번 멤버변수로 변경하기 위해 @JsonProperty를 선언하는 방버이 아닌 데이터 매핑 법칙을 변경할 수 있다</p>
<ul>
<li>@JsonAutoDetect API를 통해 변경</li>
</ul>
<div><pre><code><span>@JsonAutoDetect</span><span>(</span>fieldVisibility <span>=</span> <span>JsonAutoDetect<span>.</span>Visibility</span><span>.</span>ANY<span>)</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> myName <span>=</span> <span>"Person"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>@JsonAutoDetect는 멤버변수 뿐만 아니라, Getter, Setter의 데이터 매핑 정책도 정할 수 있다.</li>
</ul>
<div><pre><code><span>@JsonAutoDetect</span><span>(</span>fieldVisibility <span>=</span> <span>JsonAutoDetect<span>.</span>Visibility</span><span>.</span>ANY<span>)</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> myName <span>=</span> <span>"Person"</span><span>;</span>
    
    <span>public</span> <span>String</span> <span>getJob</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Developer"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>Getter를 제외하고 싶다면, @JsonIgnore API를 사용 할 수 있다.</li>
</ul>
<div><pre><code><span>@JsonAutoDetect</span><span>(</span>fieldVisibility <span>=</span> <span>JsonAutoDetect<span>.</span>Visibility</span><span>.</span>ANY<span>)</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> myName <span>=</span> <span>"Person"</span><span>;</span>
    
    <span>@JsonIgnore</span>
    <span>public</span> <span>String</span> <span>getJob</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Developer"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>@JsonAutoDetect</span><span>(</span>fieldVisibility <span>=</span> <span>JsonAutoDetect<span>.</span>Visibility</span><span>.</span>ANY<span>,</span> getterVisibility <span>=</span> <span>JsonAutoDetect<span>.</span>Visibility</span><span>.</span>NON_PRIVATE<span>)</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
   <span>private</span> <span>String</span> myName <span>=</span> <span>"Person"</span><span>;</span>
   
   <span>public</span> <span>String</span> <span>getJob</span><span>(</span><span>)</span> <span>{</span>
       <span>return</span> <span>"Developer"</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>Getter 정책으로 private만 바인딩에 제외 할 수 있다.</li>
</ul>
<h4 id="jackson의-데이터-상태에-따른-포함-관계-설정"> Jackson의 데이터 상태에 따른 포함 관계 설정</h4>
<ul>
<li>만약 Jackson 데이터 매핑시 NULL 값과 같은 특정 데이터 상태인 경우를 제외하고 싶을 땐 @JsonInclude API를 사용한다</li>
<li>NULL을 클래스 전반적으로 제외하고 싶다면, 클래스 위에 선언한다</li>
<li>특정 프로퍼티에 적용하고 싶다면 프로퍼티 위에 선언한다</li>
</ul>
<div><pre><code><span>@JsonInclude</span><span>(</span><span>JsonInclude<span>.</span>Include</span><span>.</span>NON_NULL<span>)</span>
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> myName <span>=</span> <span>"Person"</span><span>;</span>
    
    <span>public</span> <span>String</span> <span>getJob</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Developer"</span><span>;</span>
    <span>}</span>
<span>}</span>
​
<span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> myName <span>=</span> <span>"Person"</span><span>;</span>
    
    <span>@JsonInclude</span><span>(</span><span>JsonInclude<span>.</span>Include</span><span>.</span>NON_NULL<span>)</span>
    <span>public</span> <span>String</span> <span>getJob</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"Developer"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>JsonInclude.Include 속성은 NON_NULL 뿐만 아니라 몇몇 개가 더 존재한다.</li>
</ul>
<br>
<h2 id="_0215-jsonproperty-jsonnaming"> 0215 - @JsonProperty, @JsonNaming</h2>
<ul>
<li>JSON데이터를 주고 받을때 CamelCase &lt;-&gt; snake_case 변경하기 위해 사용</li>
<li>@JsonProperty</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>JsonData1</span> <span>{</span>
    <span>@JsonProperty</span><span>(</span><span>"json_data1"</span><span>)</span>
    <span>private</span> <span>String</span> jsonData1<span>;</span>
    <span>@JsonProperty</span><span>(</span><span>"json_data2"</span><span>)</span>
    <span>private</span> <span>String</span> jsonData2<span>;</span>
<span>}</span>

<span>// {"json_data1":"123","json_data2":"456"}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>@JsonNaming</li>
</ul>
<div><pre><code><span>@JsonNaming</span><span>(</span>value <span>=</span> <span>PropertyNamingStrategy<span>.</span>SnakeCaseStrategy</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>class</span> <span>JsonData2</span> <span>{</span>
    <span>private</span> <span>String</span> jsonData1<span>;</span>
    <span>private</span> <span>String</span> jsonData2<span>;</span>
<span>}</span>

<span>// {"json_data1":"가나다","json_data2":"마바사"}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0228 - 0313</title>
      <link>ahnjs/TIL/2022/0228/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0228/</guid>
      <source url="ahnjs/TIL/rss.xml">0228 - 0313</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0228-0313"> 0228 - 0313</h1>
<h2 id="_0303-jackson-다형성-관련-애노테이션"> 0303 - Jackson - 다형성 관련 애노테이션</h2>
<p>Jackson에서는 다형성 처리를 위해 세가지 애노테이션을 사용한다.</p>
<ul>
<li>@JsonTypeInfo : 직렬화시 포함할 타입 정보의 세부 사항을 나타낸다.</li>
<li>@JsonSubTypes : 애노테이션이 달린 타입의 하위 타입을 지정한다.</li>
<li>@JsonTypeName : 애노테이션이 달린 타입의 논리적 이름을 지정한다.</li>
</ul>
<p>예시</p>
<div><pre><code><span>public</span> <span>class</span> <span>Zoo</span> <span>{</span>
    <span>public</span> <span>Animal</span> animal<span>;</span>

    <span>public</span> <span>Zoo</span><span>(</span><span>Animal</span> animal<span>)</span> <span>{</span>
        <span>this</span><span>.</span>animal <span>=</span> animal<span>;</span>
    <span>}</span>

    <span>@JsonTypeInfo</span><span>(</span>
            use <span>=</span> <span>JsonTypeInfo<span>.</span>Id</span><span>.</span>NAME<span>,</span>
            include <span>=</span> <span>JsonTypeInfo<span>.</span>As</span><span>.</span>PROPERTY<span>,</span>
            property <span>=</span> <span>"type"</span><span>)</span>
    <span>@JsonSubTypes</span><span>(</span><span>{</span>
            <span>@JsonSubTypes.Type</span><span>(</span>value <span>=</span> <span>Dog</span><span>.</span><span>class</span><span>,</span> name <span>=</span> <span>"dog"</span><span>)</span><span>,</span>
            <span>@JsonSubTypes.Type</span><span>(</span>value <span>=</span> <span>Cat</span><span>.</span><span>class</span><span>,</span> name <span>=</span> <span>"cat"</span><span>)</span>
    <span>}</span><span>)</span>
    <span>public</span> <span>static</span> <span>class</span> <span>Animal</span> <span>{</span>
        <span>public</span> <span>String</span> name<span>;</span>
    <span>}</span>

    <span>@JsonTypeName</span><span>(</span><span>"dog"</span><span>)</span>
    <span>public</span> <span>static</span> <span>class</span> <span>Dog</span> <span>extends</span> <span>Animal</span> <span>{</span>
        <span>public</span> <span>double</span> barkVolume<span>;</span>

        <span>public</span> <span>Dog</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
            <span>super</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@JsonTypeName</span><span>(</span><span>"cat"</span><span>)</span>
    <span>public</span> <span>static</span> <span>class</span> <span>Cat</span> <span>extends</span> <span>Animal</span> <span>{</span>
        <span>public</span> <span>int</span> lives<span>;</span>
        <span>boolean</span> likesCream<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>PolymorphicTests</span> <span>{</span>
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>WhenPolymorphicBeanProvided_ThenSerialize_ExpectCorrect</span><span>(</span><span>)</span> <span>throws</span> <span>JsonProcessingException</span> <span>{</span>
        <span>// when</span>
        <span>Zoo<span>.</span>Dog</span> dog <span>=</span> <span>new</span> <span>Zoo<span>.</span>Dog</span><span>(</span><span>"lacy"</span><span>)</span><span>;</span>
        <span>Zoo</span> zoo <span>=</span> <span>new</span> <span>Zoo</span><span>(</span>dog<span>)</span><span>;</span>

        <span>// then</span>
        <span>String</span> json <span>=</span> <span>new</span> <span>ObjectMapper</span><span>(</span><span>)</span><span>.</span><span>writeValueAsString</span><span>(</span>zoo<span>)</span><span>;</span>

        <span>// expected</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>json<span>)</span><span>;</span>
        <span>assertThat</span><span>(</span>json<span>,</span> <span>containsString</span><span>(</span><span>"type"</span><span>)</span><span>)</span><span>;</span>
        <span>assertThat</span><span>(</span>json<span>,</span> <span>containsString</span><span>(</span><span>"dog"</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><br>
<h2 id="_0307-jdk-dynamic-proxy와-cglib"> 0307 - JDK Dynamic Proxy와 CGLIB</h2>
<h3 id="spring-aop가-제공하는-두-가지-aop-proxy"> Spring AOP가 제공하는 두 가지 AOP Proxy</h3>
<p>Spring AOP는 프록시 기반으로 JDK Dynamic Proxy와 CGLIB을 활용하여 AOP를 제공한다</p>
<h4 id="ioc-컨테이너와-aop-proxy의-관계"> IoC 컨테이너와 AOP Proxy의 관계</h4>
<p>먼저 Spring AOP는 Proxy의 메커니즘을 기반으로 AOP Proxy를 제공한다</p>
<p><img src="https://gmoon92.github.io/md/img/aop/jdk-dynamic-proxy-and-cglib/aop-proxy-mechanism.png" alt="image"></p>
<p>다음 그림처럼 Spring AOP는 사용자의 특정 호출 시점에 IoC 컨테이너에 의해 AOP를 할 수 있는 Proxy Bean을 생성해준다. 동적으로 생성된 Proxy Bean은 타깃의 메소드가 호출되는 시점에 부가기능을 추가할 메소드를 자체적으로 판단하고 가로채어 부가기능을 주입하는데, 이처럼 호출 시점에 동적으로 위빙을 한다 하여 런타임 위빙(Runtime Weaving)이라 한다.</p>
<p>따라서 Spring AOP는 런타임 위빙의 방식을 기반으로 하고 있으며, Spring에선 런타임 위빙을 할 수 있도록 상황에 따라 JDK Dynamic Proxy와 CGLIB 방식을 통해 Proxy Bean을 생성을 해준다.</p>
<h4 id="두-가지-aop-proxy는-어떠한-상황에-생성하게-되나"> 두 가지 AOP Proxy는 어떠한 상황에 생성하게 되나</h4>
<p>Spring은 AOP Proxy를 생성하는 과정에서 자체 검증 로직을 통해 다깃의 인터페이스 유무를 판단한다.</p>
<blockquote>
<p>Target이란 횡단기능(Advice)이 적용될 객체(Object)를 뜻한다.</p>
</blockquote>
<p><img src="https://gmoon92.github.io/md/img/aop/jdk-dynamic-proxy-and-cglib/aop-proxy-mechanism2.png" alt="image"></p>
<p>이때 만약 타깃이 하나 이상의 인터페이스를 구현하고 있는 클래스라면 JDK Dynamic Proxy의 방식으로 생성되고 인터페이스를 구현하지 않은 클래스라면 CGLIB의 방식으로 AOP Proxy를 생성한다</p>
<h3 id="spring-aop의-근간이-되는-jdk-dynamic-proxy-방식"> Spring AOP의 근간이 되는 JDK Dynamic Proxy 방식</h3>
<p>우선 JDK Dynamic Proxy란 Java의 리플렉션 패키지에 존재하는 Proxy라는 클래스를 통해 생성된 Proxy 객체를 의미한다. 리플랙션의 Proxy 클래스가 동적으로 Proxy를 생성해준다하여 JDK Dynamic Proxy라 부른다. 이 클래스를 사용하여 프록시를 생성하기 위해선 몇가지 조건이 있지만, 그 중 핵심은 타깃의 인터페이스를 기준으로 Proxy를 생성해준다는 점이다</p>
<p>무엇보다 Spring AOP는 JDK Dynamic Proxy를 기반으로 AOP 기술을 구현했을 만큼, JDK Dynamic Proxy가 어떻게 Proxy를 생성하는지에 대한 부분은 Spring AOP를 통해 Aspect를 구현한다면 중요한 부분이다.</p>
<h4 id="jdk-dynamic-proxy의-proxy"> JDK Dynamic Proxy의 Proxy</h4>
<p>먼저 JDK Dynamic Proxy를 사용하여 Proxy 객체를 생성하는 방법은 간단하다</p>
<div><pre><code><span>Object</span> proxy <span>=</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span><span>ClassLoader</span>       <span>// 클래스로더</span>
                                    <span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span>        <span>// 타깃의 인터페이스</span>
                                    <span>,</span> <span>InvocationHandler</span> <span>// 타깃의 정보가 포함된 Handler</span>
              										  <span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>단순히 리플랙션의 Proxy 클래스의 newProxyInstance 메소드를 사용하면 된다. JDK Dynamic Proxy가 이 파라미터를 가지고 Proxy 객체를 생성해주는 과정은 다음과 같다</p>
<p><img src="https://gmoon92.github.io/md/img/aop/jdk-dynamic-proxy-and-cglib/jdk-dynamic-proxy1.png" alt="image"></p>
<ol>
<li>타깃의 인터페이스를 자체적인 검증 로직을 통해 ProxyFactory에 의해 타깃의 인터페이스를 상속한 Proxy 객체 생성</li>
<li>Proxy 객체에 InvocationHandler를 포함시켜 하나의 객체로 반환</li>
</ol>
<p>다음과 같이 Proxy를 생성하는 과정에서 핵심적인 부분은, 무엇보다 인터페이스를 기준으로 Proxy 객체를 생성해준다는 점이다. 따라서 구현체는 인터페이스를 상속받아야하고, @Autowired를 통해 생성된 Proxy Bean을 사용하기 위해선 반드시 인터페이스의 타입으로 지정해줘야 한다.</p>
<p>이러한 Proxy의 구조를 이해하지 못한다면 다음과 같은 상황이 벌어질 수 있다.</p>
<div><pre><code><span>@Controller</span>
<span>public</span> <span>class</span> <span>UserController</span><span>{</span>
  <span>@Autowired</span>
  <span>private</span> <span>MemberService</span> memberService<span>;</span> <span>// &lt;- Runtime Error 발생...</span>
  <span>.</span><span>.</span><span>.</span>
<span>}</span>

<span>@Service</span>
<span>public</span> <span>class</span> <span>MemberService</span> <span>implements</span> <span>UserService</span><span>{</span>
  <span>@Override</span>
  <span>public</span> <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> <span>findUserId</span><span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span></span> params<span>)</span><span>{</span>
    <span>.</span><span>.</span><span>.</span>isLogic
    <span>return</span> params<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>MemberService 클래스는 인터페이스를 상속받고 있기 때문에 Spring은 JDK Dynamic Proxy 방식으로 Proxy Bean을 생성해준다. 다음과 같은 코드를 실행하면 런타임 입셉션이 발생한다. 여기서 런타임에러가 발생되는 부부은 <code>@Autowired MemberService memberService</code> 부분이다.</p>
<p>JDK Dynamic Proxy는 인터페이스 타입으로 DI를 받아줘야 하기 때문에, <code>@Autowired private UserService</code>로 형식을 구성해줘야 한다.</p>
<h4 id="인터페이스-기준-그리고-내부적인-검증-코드"> 인터페이스 기준 그리고 내부적인 검증 코드</h4>
<p>다른 관점에서 보자면 JDK Dynamic Proxy는 Proxy 패턴의 관점을 구현한 구현체라 할 수 있다.</p>
<p>이 Proxy 패턴은 접근제어의 목적으로 Proxy를 구성한다는 점ㅇ도 중요하지만, 무엇보다 사용자의 요청이 기존의 타깃을 그대로 바라볼 수 있도록 타깃에 대한 위임코드 Proxy 객체에 작성해줘야 한다. 생성된 Proxy 객체의 타깃에 대한 위임코드는 바로 InvocationHAndler에 작성해줘야 한다.</p>
<p><img src="https://gmoon92.github.io/md/img/aop/jdk-dynamic-proxy-and-cglib/jdk-dynamic-proxy2.png" alt="image"></p>
<p>따라서 사용자의 요청이 최종적으로 생성된 Proxy의 메소드를 통해 호출할 때 내부적으로 invoke에 대한 검증과정이 이뤄진다. 결과적으로 코드는 다음과 같다.</p>
<div><pre><code><span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> proxyMethod<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
  <span>Method</span> targetMethod <span>=</span> <span>null</span><span>;</span>
  <span>// 주입된 타깃 객체에 대한 검증 코드</span>
  <span>if</span> <span>(</span><span>!</span>cachedMethodMap<span>.</span><span>containsKey</span><span>(</span>proxyMethod<span>)</span><span>)</span> <span>{</span>
    targetMethod <span>=</span> target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span>proxyMethod<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> proxyMethod<span>.</span><span>getParameterTypes</span><span>(</span><span>)</span><span>)</span><span>;</span>
    cachedMethodMap<span>.</span><span>put</span><span>(</span>proxyMethod<span>,</span> targetMethod<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    targetMethod <span>=</span> cachedMethodMap<span>.</span><span>get</span><span>(</span>proxyMethod<span>)</span><span>;</span>
  <span>}</span>

  <span>// 타깃의 메소드 실행</span>
  <span>Ojbect</span> retVal <span>=</span> targetMethod<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
  <span>return</span> retVal<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>이 과정에서 검증과정이 이뤄지는 까닭은 다름아닌 Proxy가 기본적으로 인터페이스에 대한 Proxy만을 생성해주기 때문이다. 따라서 개발자가 타깃에 대한 정보를 잘 못 주입할 경우 대비하여 JDK Dynamic Proxy는 내부적으로 주입된 타깃에 대한 검증코드를 형성하고 있다.</p>
<h3 id="cglib-code-generator-library"> CGLib(Code Generator Library)</h3>
<p>CGLib은 Code Generator Library의 약자로, 클래스의 바이트코드를 조작하여 Proxy 객체를 생성해주는 라이브러리이다.</p>
<p>Spring은 CGLib을 사용하여 인터페이스가 아닌 타깃의 클래스에 대해서도 Proxy를 생성해준다. CGLib은
Enhancer라는 클래스를 통해 Proxy를 생성할 수 있다.</p>
<div><pre><code><span>Enhancer</span> enhancer <span>=</span> <span>new</span> <span>Enhancer</span><span>(</span><span>)</span><span>;</span>
         enhancer<span>.</span><span>setSuperclass</span><span>(</span><span>MemberService</span><span>.</span><span>class</span><span>)</span><span>;</span> <span>// 타깃 클래스</span>
         enhancer<span>.</span><span>setCallback</span><span>(</span><span>MethodInterceptor</span><span>)</span><span>;</span>     <span>// Handler</span>
<span>Object</span> proxy <span>=</span> enhancer<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span> <span>// Proxy 생성</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><img src="https://gmoon92.github.io/md/img/aop/jdk-dynamic-proxy-and-cglib/cglib1.png" alt="image"></p>
<p>다음과 같이 CGLib은 타깃의 클래스를 상속받아 Proxy를 생성한다. 이 과정에서 CGLib은 타깃 클래스에 포함된 모든 메소드를 재정의하여 Proxy를 생성해준다.<br>
이 때문에 CGLib은 Final 메소드 또는 클래스에 대해 재정의를 할 수 없으므로 Proxy를 생성할 수 없다는 단점이 있지만, CGLib은 바이트 코드로 조작하여 Proxy를 생성해주기 때문에 성능에 대한 부분이 JDK Dynamic Proxy보다 좋다.</p>
<h4 id="invoke의-차이-성능의-차이"> invoke의 차이, 성능의 차이</h4>
<p>성능의 차이의 근본적인 이유는 CGLib은 타깃에 대한 정보를 제공 받기 때문이다.</p>
<p>따라서 CGLib은 제공받은 타깃 클래스에 대한 바이트 코드를 조작하여 Proxy를 생성하기 때문에, Handler안에서 타깃의 메소드를 호출할 때 다음과 같은 코드가 형성된다.</p>
<div><pre><code><span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> proxyMethod<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
  <span>Method</span> targetMethod <span>=</span> target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getMethod</span><span>(</span>proxyMethod<span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> proxyMethod<span>.</span><span>getParameterTypes</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>Ojbect</span> retVal <span>=</span> targetMethod<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
  <span>return</span> retVal<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol>
<li>메소드가 처음 호출되었을 때 동적으로 타깃의 클래스의 바이트 코드를 조작</li>
<li>이후 호출시엔 조작된 바이트 코드를 재사용</li>
</ol>
<p>CGLib은 성능이 좋긴하지만, Spring은 JDK Dynamic Proxy를 기반으로 Proxy를 생성해주고 있다. 하지만 어느 어느 시점 부터 Spring Boot에선 문제가 되었던 부분들이 개선되어 안정화가 되었기 때문에 CGLib을 방식으로 Proxy를 생성해주고 있다.</p>
<br>
<h2 id="_0308-리플렉션-api-reflection-api"> 0308 - 리플렉션 API (Reflection API)</h2>
<h3 id="리플렉션-api란"> 리플렉션 API란?</h3>
<ul>
<li>구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메서드. 타입, 변수 등등)에 접근할 수 있게 해주는 자바 API이다.</li>
<li>리플렉션 API는 자바 코드를 통해 로드된 클래스의 필드/메서드/생성자를 찾을 수 있게 지원한다.</li>
<li>또한 클래스의 접근 제한자와 상관없이 클래스의 필드/메서드/생성자를 사용할 수 있게 지원한다.</li>
</ul>
<blockquote>
<p>힙 영역에 로드된 Class 타입의 객체를 통해, 원하는 클래스의 인스턴스를 생성할 수 있게 지원하고, 인스턴스의 필드와 메서드를 접근 제어자와 상관없이 사용할 수 있도록 지원하는 API.</p>
</blockquote>
<h3 id="클래스의-정보-조회"> 클래스의 정보 조회</h3>
<ol>
<li>직접 선언</li>
</ol>
<div><pre><code><span>Class</span><span><span>&lt;</span><span>Book</span><span>></span></span> bookClass <span>=</span> <span>Book</span><span>.</span><span>class</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>인스턴스를 이용한 getClass() 메소드</li>
</ol>
<div><pre><code><span>Book</span> book <span>=</span> <span>new</span> <span>Book</span><span>(</span><span>)</span><span>;</span>
<span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Book</span><span>></span></span> bookClassFromInstance <span>=</span> book<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="3">
<li>Class.forName() 메소드</li>
</ol>
<div><pre><code><span>try</span> <span>{</span>
	<span>//주로 JDBC 예제에서 많이 봄</span>
	<span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> bookClassFromPackageString <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"org.example.Book"</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span><span>ClassNotFoundException</span> e<span>)</span> <span>{</span>
	e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="class-타입을-이용한-클래스-정보-조회"> Class&lt;?&gt; 타입을 이용한 클래스 정보 조회</h3>
<h4 id="필드-정보-조회"> 필드 정보 조회</h4>
<ul>
<li>(Field[]) getFields() : 클래스에 선언된 필드들 반환(public 접근지시자만)</li>
<li>(Field) getField(String name) : name에 해당하는 필드를 반환(없다면 NoSuchFieldException)</li>
<li>(Field[]) getDeclaredFields() : 클래스에 선언된 모든 필드들 반환(private 까지도 포함)</li>
<li>(Field) getDeclaredField(String name) : name에 해당하는 필드를 반환(없으면 NoSuchFieldEception, priavte 포함)</li>
</ul>
<h4 id="메소드-접근"> 메소드 접근</h4>
<div><pre><code><span>Method</span><span>[</span><span>]</span> methods <span>=</span> bookClass<span>.</span><span>getMethods</span><span>(</span><span>)</span><span>;</span>
<span>Arrays</span><span>.</span><span>stream</span><span>(</span>methods<span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span> <span>//Object 상속 메소드 포함.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="생성자-접근"> 생성자 접근</h4>
<div><pre><code><span>Constructor</span><span>[</span><span>]</span> constructors <span>=</span> bookClass<span>.</span><span>getConstructors</span><span>(</span><span>)</span><span>;</span>
<span>Arrays</span><span>.</span><span>stream</span><span>(</span>constructors<span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="부모클래스-접근"> 부모클래스 접근</h4>
<div><pre><code><span>Class</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>MyBook</span><span>></span></span> superClass <span>=</span> <span>MyBook</span><span>.</span><span>class</span><span>.</span><span>getSuperclass</span><span>(</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>superClass<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="인터페이스-접근"> 인터페이스 접근</h4>
<div><pre><code><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> implementsInterface <span>=</span> <span>MyBook</span><span>.</span><span>class</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>;</span>
<span>Arrays</span><span>.</span><span>stream</span><span>(</span>implementsInterface<span>)</span><span>.</span><span>forEach</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="리플렉션-api-사용이유"> 리플렉션 API 사용이유</h3>
<p>캡슐화와 은닉성을 무시하면서도 사용하는 이유는, 런타임에 비로소 객체가 생성되어야 할 필요성이 있기 때문인다.</p>
<br>
<h2 id="_0309-querydsl-기본-사용법"> 0309 - QueryDSL 기본 사용법</h2>
<ul>
<li>QueryDSL은 HQL(Hibernate Query Language) 쿼리를 타입에 안전하게 생성 및 관리할 수 있게 해주는 프레임워크다.</li>
<li>자바 코드 기반으로 쿼리를 작성하게 도와준다.</li>
</ul>
<h3 id="querydsl-예제"> QueryDSL 예제</h3>
<h3 id="gradle-설정"> gradle 설정</h3>
<div><pre><code>plugins <span>{</span>
    <span>// ...</span>
    id <span>"com.ewerk.gradle.plugins.querydsl"</span> version <span>"1.0.10"</span> <span>// 추가</span>
    <span>// ...</span>
<span>}</span>

<span>// ...</span>

dependencies <span>{</span>
    <span>// ...</span>
    implementation <span>'com.querydsl:querydsl-jpa'</span> <span>// 추가</span>
    <span>// ...</span>
<span>}</span>

<span>// ...</span>

<span>// queryDSL이 생성하는 QClass 경로 설정</span>
def querydslDir <span>=</span> <span>"$buildDir/generated/querydsl"</span>

querydsl <span>{</span>
    jpa <span>=</span> <span>true</span>
    querydslSourcesDir <span>=</span> querydslDir
<span>}</span>

sourceSets <span>{</span>
    main<span>.</span>java<span>.</span>srcDir querydslDir
<span>}</span>

configurations <span>{</span>
    querydsl<span>.</span>extendsFrom compileClasspath
<span>}</span>

compileQuerydsl <span>{</span>
    options<span>.</span>annotationProcessorPath <span>=</span> configurations<span>.</span>querydsl
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><h4 id="q클래스-만들기"> Q클래스 만들기</h4>
<p><img src="https://media.vlpt.us/images/tigger/post/3e5a5eb6-de64-4387-b045-5af37e427a86/image.png" alt="image">
Tasks -&gt; other -&gt; compileJava 실행시 지정해둔 build/지정경로에 Q클래스가 생성</p>
<h4 id="config-설정"> Config 설정</h4>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>QueryDSLConfig</span> <span>{</span>

    <span>@PersistenceContext</span>
    <span>private</span> <span>EntityManager</span> entityManager<span>;</span>

    <span>@Bean</span>
    <span>public</span> <span>JPAQueryFactory</span> <span>jpaQueryFactory</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>JPAQueryFactory</span><span>(</span>entityManager<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="기본-사용법"> 기본 사용법</h4>
<ol>
<li>Post 엔티티</li>
</ol>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>Post</span> <span>{</span>

    <span>@Id</span>
    <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>IDENTITY<span>)</span>
    <span>private</span> <span>Long</span> id<span>;</span>

    <span>@Column</span><span>(</span>nullable <span>=</span> <span>false</span><span>)</span>
    <span>private</span> <span>String</span> title<span>;</span>

    <span>@Column</span><span>(</span>nullable <span>=</span> <span>false</span><span>)</span>
    <span>private</span> <span>String</span> content<span>;</span>

    <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="2">
<li>PostRepository</li>
</ol>
<div><pre><code><span>public</span> <span>interface</span> <span>PostRepository</span> <span>extends</span> <span>JpaRepository</span><span><span>&lt;</span><span>Post</span><span>,</span> <span>Long</span><span>></span></span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="3">
<li>PostRepositorySupport</li>
</ol>
<div><pre><code><span>@Repository</span>
<span>public</span> <span>class</span> <span>PostRepositorySupport</span> <span>extends</span> <span>QuerydslRepositorySupport</span> <span>{</span>

    <span>private</span> <span>final</span> <span>JPAQueryFactory</span> jpaQueryFactory<span>;</span>

    <span>public</span> <span>PostRepositorySupport</span><span>(</span><span>final</span> <span>JPAQueryFactory</span> jpaQueryFactory<span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>Post</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>jpaQueryFactory <span>=</span> jpaQueryFactory<span>;</span>
    <span>}</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Post</span><span>></span></span> <span>findByTitle</span><span>(</span><span>final</span> <span>String</span> title<span>)</span> <span>{</span>
        <span>return</span> jpaQueryFactory<span>.</span><span>selectFrom</span><span>(</span>post<span>)</span>
                <span>.</span><span>where</span><span>(</span>post<span>.</span>title<span>.</span><span>eq</span><span>(</span>title<span>)</span><span>)</span>
                <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><ul>
<li>이떄 selectFrom(post)의 post는 아까 만든 Q클래스에서 사용한다</li>
</ul>
<h4 id="spring-data-jpa-custom-repository-적용-사용법"> Spring Data Jpa Custom Repository 적용 사용법</h4>
<p>위와 같이 사용하면 항상 2개의 Repository(QueryDSL의 Custom Repository, JpaRepository를 상속한 Repository)를 의존성으로 받아야한다.</p>
<ol>
<li>CustomizedPostRepository</li>
</ol>
<div><pre><code><span>public</span> <span>interface</span> <span>CustomizedPostRepository</span> <span>{</span>
    <span>List</span><span><span>&lt;</span><span>Post</span><span>></span></span> <span>findByTitle</span><span>(</span><span>final</span> <span>String</span> title<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>CustomizedPostRepositoryImpl</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>CustomizedPostRepositoryImpl</span> <span>implements</span> <span>CustomizedPostRepository</span> <span>{</span>

    <span>private</span> <span>final</span> <span>JPAQueryFactory</span> jpaQueryFactory<span>;</span>

    <span>private</span> <span>CustomizedPostRepositoryImpl</span><span>(</span><span>final</span> <span>JPAQueryFactory</span> jpaQueryFactory<span>)</span> <span>{</span>
        <span>this</span><span>.</span>jpaQueryFactory <span>=</span> jpaQueryFactory<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>List</span><span><span>&lt;</span><span>Post</span><span>></span></span> <span>findByTitle</span><span>(</span><span>final</span> <span>String</span> title<span>)</span> <span>{</span>
        <span>return</span> jpaQueryFactory<span>.</span><span>selectFrom</span><span>(</span>post<span>)</span>
                <span>.</span><span>where</span><span>(</span>post<span>.</span>title<span>.</span><span>eq</span><span>(</span>title<span>)</span><span>)</span>
                <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="3">
<li>PostRepository</li>
</ol>
<div><pre><code><span>public</span> <span>interface</span> <span>PostRepository</span> <span>extends</span> <span>JpaRepository</span><span><span>&lt;</span><span>Post</span><span>,</span> <span>Long</span><span>></span></span><span>,</span> <span>CustomizedPostRepository</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>이렇게 구성하면 <code>CustomizedPostRepositoryImpl</code>의 코드를 사용할 수 있다. <code>PostRepository</code>는 어떻게 <code>CustomizedPostRepository</code>를 상속받아서 <code>CustomizedPostRepositoryImpl</code>의 코드를 사용할 수 있을까?</p>
<p>Spring 공식문서를 보면 커스텀한 Repostory는 별도의 설정을 하지 않았다면 <code>~Impl</code>접미사를 붙여야만 스프링이 찾을 수 있다. 관련해서는 <code>spring-data</code>에 포함된 <code>RepositoryConfigurationSourceSupport</code>클래스와 <code>AnnotationRepositoryConfigurationSource</code>클래스의 내부 코드를 보면 알 수 있다.</p>
<blockquote>
<p>The most important part of the class name that corresponds to the fragment interface is the Impl postfix.</p>
</blockquote>
<br>
<h2 id="_0310-openapi와-swagger-redoc란"> 0310 - OpenAPI와 Swagger/redoc란</h2>
<h3 id="openapi-spec"> OpenAPI Spec</h3>
<p><code>OpenAPI Specification(OAS)</code>은 RESTful API를 기술하는 표준으로 서비스에서 제공하는 API의 기능과 End Point를 개발자나 시스템이 자동으로 발견하고 처리하는데 필요한 정보를 제공한다.</p>
<p>OAS는 json이나 yml형식으로 기술해야 하며 OAS파일을 읽어서 디플로이 해주는 도구(ex. swagger-ui)를 사용하면 브라우저에서 편리하게 API 문서를 볼 수 있다.</p>
<p>OAS는 예전에는 Swagger spec으로 불렸으며 3.0 부터 <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md" target="_blank" rel="noopener noreferrer">OpenAPI 3.0 Specification<i>Content not supported</i></a>라는 이름으로 표준화 되었다</p>
<h3 id="swagger"> Swagger</h3>
<p>Swagger는 OpenAPI Spec에 맞게 디자인하고 문서화하고 빌드하기 위한 도구들의 모음으로 다음과 같은 구성요소로 이루어져 있다.</p>
<ul>
<li>Swagger Editor - 브라우저 기반의 편집기로 OpenAPI spec을 쉽게 작성할 수 있도록 도와준다.</li>
<li>Swagger UI - OpenAPI spec문서를 디플로이하고 브라우저에서 예쁘게 표시할 수 있도록 해준다. swagger-ui와 비슷한 라이브러리로 redoc이 있다.</li>
<li>Swagger Codegen - OpenAPI spec에 맞게 서버나 클라이언트의 stub code를 생성해준다. 개발자는 생성된 코드에 비즈니스 로직에 집중해서 구현하면 된다.</li>
</ul>
<h3 id="redoc"> Redoc</h3>
<p><a href="https://github.com/Redocly/redoc" target="_blank" rel="noopener noreferrer">redoc<i>Content not supported</i></a>은 OpenAPI spec 파일을 읽어서 디플로이해주는 도구로 Swagger-UI와 비슷한 역할을 수행한다.</p>
<p>설치와 사용이 아주 간편한 장점이 있지만 swagger-ui랑 달리 브라우저에서 API 테스트 기능을 해볼수는 없다는 단점이 있다.</p>
<br>
<h2 id="_0311-자바-로그-프레임워크"> 0311 - 자바 로그 프레임워크</h2>
<h3 id="로그-시스템"> 로그 시스템</h3>
<p>로그 시스템은 소프트웨어의 이벤트를 기록 함으로써, 소프트 웨어 동작 상태를 파악하고 문제가 발생했을때 이 동작 파악을 위해서 소프트웨어의 문제를 찾아내고 해결하기 위해서 디자인 되었다.<br>
주로 로그 파일이라는 형태로 하나의 파일에 이벤트들을 기록하였다.</p>
<p>그러나 소프트웨어 스택이 OS, 미들웨어, 사용자 어플리케이션(자바나 파이썬등으로 구현된 애플리케이션)으로 점점 다중화되고 시스템이 대형화 되면서 한대가 아니라 여러대의 서버에 로그를 기록하고 또한 마이크로 서비스 아키텍처로 인하여 서버 컴포넌트가 분산됨에 따라서 로그를 수집해야할 포인트가 많아지게 되었따. 이로 인해서 로그 시스템이 분산 환경을 지원해야 할 필요가 되었고, 단순히 파일로 로그를 기록하는 것만으로는 이러한 여러시스템과 다중 계층에 대한 모니터링이 불가능하게 되었다.</p>
<p>또한 데이터 분석의 중요성이 대두됨에 따라서, 에러등의 동작 파아성의 로그 뿐만 아니라 사용자의 앤티비티를 수집하여 데이터 분석에 사용하기 위해서 데이터 수집 역시 로그 시스템을 통하기 시작했다.</p>
<h4 id="좋은-로그-시스템"> 좋은 로그 시스템</h4>
<ul>
<li>로그 메시지는 애플리케이션의 동작을 잘 이해할 수 있도록 충분히 구체적이어야 한다.</li>
<li>로그 메시지를 기록하는데 성능 저하가 없어야 한다.</li>
<li>어떠한 배포 환경이라도 로그를 수집하고 저장할 수 있도록 충분히 유연해야 한다. (분산 환경 지원, 대용량 데이타 지원등..)</li>
</ul>
<h3 id="자바-로깅-프레임워크"> 자바 로깅 프레임워크</h3>
<p>자바는 역사가 오래된 만큼 많은 로깅 프레임웍을 가지고 있다. log4j, logback, log4j2, apache common logging, SLF4J 등 다양한 프레임워크들이 있다.</p>
<h4 id="slf4j"> SLF4J</h4>
<p>SLF4J는 (Simple Logging Facade for Java)의 약자로 이름이 뜻하는 것과 같이 로깅에 대한 Facade 패턴이다. SLF4J는 자체가 로깅 프레임워크가 아니라, 다양한 로깅 프레임워크를 같은 API를 사용해서 접근할 수 있도록 해주는 추상화 계층이다. 그래서 다른 로그 프레임워크와 같이 사용해야 하는데, 보통 Log4J, Logback, Log4J2등이 많이 사용된다. 즉 애플리케이션은 SLF4J API 인터페이스를 통해서 호출하지만, 실제로 호출되는 로깅 프레임워크는 다른 프레임워크가 호출된다는 이야기다. 이렇게 추상화를 통해서 용도와 목적에 맞게 다른 로깅프레임워크로 쉽게 전환이 가능함은 물론이고, 로깅에 필요한 코드들을 추상화해주기 때문에, 훨씬 쉽고 간단하게 로깅이 가능하다. apache common logging 역시, SLF4J와 같이 다른 로깅 프레임워크 들을 추상화 해주는 기능을 제공한다.</p>
<h4 id="log4j"> Log4J</h4>
<p>Log4J는 이중에서 가장 오래된 로그프레임워크로 로그 프레임워크에 대한 초반 개념을 설정했다고 볼 수 있다. 현재는 개발이 중지되고, Log4J2로 새로운 버전으로 변경되었다.</p>
<h4 id="logback"> Logback</h4>
<p>아마 현재 국내에서 가장 널리 많이 사용되고 있는 로그 프레임워크일것이다. Log4J 개발자가 개발한 로그 프레임워크로 주로 Log4J 성능 부분에 대한 개선 작업이 많이 이루어 졌다. SLF4J와 네이티브로 연동이 가능하다.</p>
<h4 id="log4j2"> Log4J2</h4>
<p>가장 근래에 나온 프레임워크로 Logback 보다 후에 나오고, 가장 빠른 성능을 제공한다. Logback과 SLF4J사이의 연동 문제를 해결하였으면 비동기 로깅을 제공하여, 특히 멀티 쓰레드 환경에서 높은 성능을 제공한다.</p>
<blockquote>
<p>또한 근래의 로깅 시스템들은 로그를 파일로 기록하기 보다는 ELK(Elastic Search)나 Kafka등 외부 시스템으로 로그를 전송하여 모으는 형태를 많이 취하기 떄문에 이에 대한 연동을 Appender를 통해서 제공한다.</p>
</blockquote>
<p>제공되는 Appender는 다음과 같다.</p>
<ul>
<li>Console</li>
<li>File, RollingFile, MemoryMappedFile</li>
<li>Flume, Kafka, JDBC, JMS, Socket, ZeroMQ</li>
<li>SMTP(emails on errors, woo!)</li>
<li>...much more</li>
</ul>
]]></content:encoded>
      <enclosure url="https://gmoon92.github.io/md/img/aop/jdk-dynamic-proxy-and-cglib/aop-proxy-mechanism.png" type="image/png"/>
    </item>
    <item>
      <title>0221 - 0227</title>
      <link>ahnjs/TIL/2022/0221/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0221/</guid>
      <source url="ahnjs/TIL/rss.xml">0221 - 0227</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0221-0227"> 0221 - 0227</h1>
<h2 id="_0222-restful-api-post와-put의-차이"> 0222 - RESTful API POST와 PUT의 차이</h2>
<h3 id="http-post"> HTTP POST</h3>
<h4 id="post의-정의"> POST의 정의</h4>
<ul>
<li>Request(요청)에 포함된 Entity(Http body에 해당)을 Request-URI에 정의된 리소스의 하위(Suboridiate) Entity로 새롭게 생성하는 요청을 서버에 보낼때 사용되는 Http Method이다.</li>
</ul>
<p>따라서 Request-URI는 리소스의 Entity를 나타내는 Collection URI여야 한다.</p>
<blockquote>
<p>예를 들어, 신발들의 정보를 저장하는 shoes가 있다. 그리고 각 신발의 정보들은 shoes라는 큰 카테고리 밑에 하위 item으로 등록되고 저장될 것이다. 그렇다면, shoes는 신발들이 모인 Collection이다. 이걸 URI로 적용해본다면 신발 정보의 Collection-URI는 /shoes가 된다.</p>
</blockquote>
<p>POST는 /shoes 라는 collection URI의 하위에 새로운 신발(Entity)을 Create(생성)할 때 사용되는 http Method라고 할 수 있다.</p>
<h4 id="post의-특징"> POST의 특징</h4>
<ul>
<li>
<p>POST Request는 Idempotent(멱등) 하지 않다 :<br>
Idempotent(멱등) 하지 않다 = 여러번의 재시도에 대한 모든 결과값이 동일하지 않다는 것이다. 즉, POST로 동일한 entity의 Request를 N번 보낸다면, N개의 다른 리소스들이 생성되는 것이다.</p>
</li>
<li>
<p>POST Request의 Response는 Caching 가능 하다 :<br>
POST request는 Cache-Control or Expires가 Http header 올바르게 정의되어 있다면 Response(응답) 값을 캐싱해도 된다. 대신 Response를 캐시로 응답 했다면, HTTP 300으로 해당 응답이 캐시에서 왔따는 것을 표시해줘야 한다.</p>
</li>
</ul>
<h3 id="http-put"> HTTP PUT</h3>
<h4 id="put의-정의"> PUT의 정의</h4>
<ul>
<li>Request-URI에 있는 Resource가 존재한다면, Request에 있는 Entity에 값으로 리소스를 Update(갱신)한다.</li>
</ul>
<p>만약 Resource가 존재하지 않고, Request-URI와 Resource-URI가 올바르다면 리소스를 Create(생성) 할 때 사용되는 Http Method이다.</p>
<blockquote>
<p>if resource 존재 -&gt; Update(갱신) else -&gt; Create(생성)</p>
</blockquote>
<h4 id="put의-특징"> PUT의 특징</h4>
<ul>
<li>
<p>Resource Identifier :<br>
PUT은 기존의 /shoes 라는 collection URI에 더하여, /shoes/{shoe_id}로 해당 resource의 Resource Identifier를 나타내줘야 한다.</p>
</li>
<li>
<p>PUT Request는 Idempotent(멱등) 하다 :<br>
PUT request로는 새로운 정보가 계속되서 생성되지 않는다. 여러번 재시도를 하더라도, 동일한 결과 값을 받는다. 즉 PUT request는 idempotent(멱등)하다.</p>
</li>
<li>
<p>POST Request의 Response는 Caching 할 수 없다 :<br>
PUT request는 idempotent하다. 하지만 Response(응답) 값을 캐싱하면 안된다.</p>
</li>
</ul>
<h4 id="patch와의-차이"> PATCH와의 차이</h4>
<ul>
<li>PATCH는 수정만 담당하며 리소스의 일부분만 수정할 때 사용하고, PUT은 리소스의 모든 속성을 수정하기 위해 사용한다.</li>
</ul>
<h3 id="post-put-예시"> POST &amp; PUT 예시</h3>
<div><pre><code>POST /shoes
= Http Body에 있는 정보로 새로운 Shoe 하위 Resource 생성

PUT /shoes/{존재하는_SHOE_ID}
= 존재하는_SHOE_ID에 존재하던 정보를 Overwrite(덮어쓰기)해서 정보를 갱신

PUT /shoes/{존재하지_않는_SHOE_ID}
= 존재하지_않는_SHOE_ID로 새로운 Resource 생성
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><br>
<h2 id="_0227-interface-vs-abstract"> 0227 - Interface vs Abstract</h2>
<p>Interface와 Abstract Class는 상속(extends)받거나, 구현(implements)하는 Class가 Interface나 Abstract Class 안에 있는 Abstract Method를 구현하도록 강제하는 공통점을 가지고 있다. 그렇다면 차이점은 존재 목적이 다른 부분이다.</p>
<h3 id="interface"> Interface</h3>
<p>interface는 부모, 자식 관계인 상속 관계에 얽메이지 않고, 공통 기능이 필요 할때, Abstract Method를 정의해놓고 구현하는 Class에서 각 기능들을 Overriding하여 여러가지 형태로 구현할 수 있기에 다형성과 연관되어 있다.</p>
<p>interface는 해당 인터페이스를 구현하는 Class들에 대해 동일한 method, 동작을 강제하기위해 존재한다.</p>
<blockquote>
<p>Java에서 다중 상속이 안되어 발생하는 Abstract Class의 한계도 보완해줄 수 있다.
Interface의 implements에는 제한이 없어 다중 구현이 가능하다.
하지만 모든 Class가 Interface를 이용한다면, 공통적으로 필요한 기능도 implements하는 모든 Class에서 Overriding해 재정의해야 하는 번거로움이 존재한다.</p>
</blockquote>
<p>interface는 각각 다른 Abstract Class를 상속하는 Class들의 공통 기능을 명시할때 사용하면 편리하다</p>
<h3 id="abstract-class"> Abstract Class</h3>
<p>Abstract Class는 부모와 자식 즉, 상속 관계에서 Abstract Class를 상속(extends)받으며 같으 부모를 상속받는 자식 Class들 간에 공통 기능을 각각 구현하고, 확장시키며 상속과 관련되어 있다. 상속은 Super Class의 기능을 이용, 확장 하기 위해 사용된다.</p>
<div><pre><code>Abstract Class는 IS - A &quot;~이다&quot;이고, Interface는 HAS - A &quot;~를 할 수 있는&quot;이다.
</code></pre>
<div><span>1</span><br></div></div><p>Abstract Class를 상속하여 Class들간의 구분이 가능해진다. Java에서는 다중 상속을 지원하지 않기 때문에 Abstract Class 만으로 구현하는 Abstract Method를 강제하는데는 한계가 존재한다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>0314 - 0320</title>
      <link>ahnjs/TIL/2022/0314/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0314/</guid>
      <source url="ahnjs/TIL/rss.xml">0314 - 0320</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0314-0320"> 0314 - 0320</h1>
<h2 id="_0314-spring-boot-maven-plugin"> 0314 - spring-boot-maven-plugin</h2>
<div><pre><code><span><span><span>&lt;</span>dependencies</span><span>></span></span>
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
 
    <span><span><span>&lt;</span>dependency</span><span>></span></span>
        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-test<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
        <span><span><span>&lt;</span>scope</span><span>></span></span>test<span><span><span>&lt;/</span>scope</span><span>></span></span>
    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
<span><span><span>&lt;/</span>dependencies</span><span>></span></span>
 
<span><span><span>&lt;</span>build</span><span>></span></span>
    <span><span><span>&lt;</span>plugins</span><span>></span></span>
        <span><span><span>&lt;</span>plugin</span><span>></span></span>
            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
        <span><span><span>&lt;/</span>plugin</span><span>></span></span>
    <span><span><span>&lt;/</span>plugins</span><span>></span></span>
<span><span><span>&lt;/</span>build</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>플러그인 등록 유무에 따른 jar파일 내의 META-INF/MANIFEST.MF 정보</p>
</blockquote>
<ul>
<li>Main-Class : Springboot application이기 때문에 Main-Class의 Value에 Springboot의 org.springframework.boot.loader.JarLauncher로 지정</li>
<li>Start-Class : 어플리케이션의 MainClass를 Start-Class의 Value에 정의한다.</li>
<li>Spring-Boot-Classes : 컴파일된 class파일들이 위치한 경로를 정의한다.</li>
<li>Spring-Boot-Lib : pom.xml에 추가한 의존하고 있는 라이브러리들이 위치한 경로를 정의한다.</li>
</ul>
<p>위와 같은 정보들을 spring-boot-maven-plugin이 추가해준다.</p>
<p>spring-boot-maven-plugin은 단순히 MANIFEST.MF에 추가적인 정보를 등록해주는 것만은 아니다. 이플러그인의 핵심은 패키징할 때 다음과 같이 실행 가능한 jar파일로 구조를 변경해준다. (spring-boot-maven-plugin은 BOOT-INF에 컴파일된 class파일을 두는 특이한 구조를 갖추고있다. 그리고 JarLauncher가 이 구조에 있는 class파일/jar파일을 로딩하는 역할을 한다.)</p>
<br>
<h2 id="_0315-swagger-3-변경-사항"> 0315 - swagger 3 변경 사항</h2>
<ol>
<li>springdoc-openapi-ui 종속성 추가</li>
</ol>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springdoc<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>springdoc-openapi-ui<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>1.6.6<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="2">
<li>annotations 변경</li>
</ol>
<ul>
<li>@Api → @Tag</li>
<li>@ApiIgnore → @Parameter(hidden = true) or @Operation(hidden = true) or @Hidden</li>
<li>@ApiImplicitParam → @Parameter</li>
<li>@ApiImplicitParams → @Parameters</li>
<li>@ApiModel → @Schema</li>
<li>@ApiModelProperty(hidden = true) → @Schema(accessMode = READ_ONLY)</li>
<li>@ApiModelProperty → @Schema</li>
<li>@ApiOperation(value = &quot;foo&quot;, notes = &quot;bar&quot;) → @Operation(summary = &quot;foo&quot;, description = &quot;bar&quot;)</li>
<li>@ApiParam → @Parameter</li>
<li>@ApiResponse(code = 404, message = &quot;foo&quot;) → @ApiResponse(responseCode = &quot;404&quot;, description = &quot;foo&quot;)</li>
</ul>
<ol start="3">
<li>config 변경</li>
</ol>
<div><pre><code><span>@Bean</span>
<span>public</span> <span>GroupedOpenApi</span> <span>publicApi</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>GroupedOpenApi</span><span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>.</span><span>group</span><span>(</span><span>"springshop-public"</span><span>)</span>
            <span>.</span><span>pathsToMatch</span><span>(</span><span>"/public/**"</span><span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>@Bean</span>
<span>public</span> <span>GroupedOpenApi</span> <span>adminApi</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>GroupedOpenApi</span><span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>.</span><span>group</span><span>(</span><span>"springshop-admin"</span><span>)</span>
            <span>.</span><span>pathsToMatch</span><span>(</span><span>"/admin/**"</span><span>)</span>
            <span>.</span><span>addMethodFilter</span><span>(</span>method <span>-></span> method<span>.</span><span>isAnnotationPresent</span><span>(</span><span>Admin</span><span>.</span><span>class</span><span>)</span><span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>@Bean</span>
<span>public</span> <span>OpenAPI</span> <span>springShopOpenAPI</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>OpenAPI</span><span>(</span><span>)</span>
            <span>.</span><span>info</span><span>(</span><span>new</span> <span>Info</span><span>(</span><span>)</span><span>.</span><span>title</span><span>(</span><span>"SpringShop API"</span><span>)</span>
            <span>.</span><span>description</span><span>(</span><span>"Spring shop sample application"</span><span>)</span>
            <span>.</span><span>version</span><span>(</span><span>"v0.0.1"</span><span>)</span>
            <span>.</span><span>license</span><span>(</span><span>new</span> <span>License</span><span>(</span><span>)</span><span>.</span><span>name</span><span>(</span><span>"Apache 2.0"</span><span>)</span><span>.</span><span>url</span><span>(</span><span>"http://springdoc.org"</span><span>)</span><span>)</span><span>)</span>
            <span>.</span><span>externalDocs</span><span>(</span><span>new</span> <span>ExternalDocumentation</span><span>(</span><span>)</span>
            <span>.</span><span>description</span><span>(</span><span>"SpringShop Wiki Documentation"</span><span>)</span>
            <span>.</span><span>url</span><span>(</span><span>"https://springshop.wiki.github.org/docs"</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>https://www.baeldung.com/spring-rest-openapi-documentation<br>
https://springdoc.org/</p>
<br>
<h2 id="_0316-valid와-validated를-이용한-유효성-검증의-동작-원리-및-사용법-예시-1-2"> 0316 - @Valid와 @Validated를 이용한 유효성 검증의 동작 원리 및 사용법 예시 (1/2)</h2>
<p>Spring으로 개발을 하다 보면 DTO 또는 객체를 검증해야 한다. 이를 별도의 검증 클래스로 만들어 사용할 수 있지만 간단한 검증의 경우에는 JSR 표준을 이용해 간견ㄹ하게 처리할 수 있따.</p>
<h3 id="_1-valid와-validated"> 1. @Valid와 @Validated</h3>
<h4 id="valid를-이용한-유효성-검증"> [ @Valid를 이용한 유효성 검증 ]</h4>
<h5 id="valid의-개념-및-사용법"> &lt; @Valid의 개념 및 사용법 &gt;</h5>
<p>@Valid는 JSR-303 표준 스펙으로써 <code>제약 조건이 부여된 객체에 대해 빈 검증기(Bean Validator)를 이용해서 검증하도록 지시하는 어노테이션</code>이다. Spring에서는 LocalValidatorFactoryBean을 이용해 JSR 표준의 검증 기능을 사용할 수 있는데, LocalValidatorFactoryBean은 JSR-303의 검증 기능을 이용할 수 있도록 해주는 일종의 어댑터에 해당한다.<br>
JSR 표준의 빈 검증 기술의 특징은 객체의 필드에 달린 제약조건 어노테이션을 참고해 검증을 편리하게 할 수 있다는 것이다. 이 빈 검증 기능을 이용하려면 LocalValidatorFactoryBean을 빈으로 등록하고 ValidationService를 제공해주어야 하는데, SpringBoot에서는 의존성만 추가하면 검증을 위한 빈들이 자동으로 등록된다.</p>
<h5 id="valid의-동작-원리"> &lt; @Valid의 동작 원리 &gt;</h5>
<p>모든 요청은 프론트 컨트롤러인 디스패처 서블릿을 통해 컨트롤러로 전달된다. 그리고 컨트롤러의 메소드 호출하는 과정에는 메소드의 값을 처리해주는 ArgumentResolver가 동작하는데, @Valid 역시 ArgumentResolver에 의해 처리가 된다.<br>
대표적으로 @RequestBody가 있는 경우에는 Json 메세지를 객체로 변환해주는 작업이 ArgumentResolver의 구현체인 RequestResponseBodyMethodProcessor가 처리하며, 이 내부에서 @Valid로 시작하는 어노테이션이 있을 경우에 유효성 검사를 진행한다. (이러한 이유로 @Valid가 ㅇ아니라 커스톰 어노테이션인 @Valid커스텀네임여도 동작한다.) 만약 ModelAttribute를 사용중이라면 ModelAttributeMethodProcessor에 의해 @Valid가 처리된다. 그리고 검증에 오류가 있다면 MethodArgumentNotValidException 예외가 발생하게 되고, 디스패처 서블릿에 기본으로 등록된 예외 리졸벼(Exception Resolver)인 DefaultHandlerExceptionResolver에 의해 400 BadRequest에러가 발생한다.</p>
<p>이러한 이유로 @Valid는 기본적으로 컨트롤러에서만 동작하며 기본적으로 다른 계층에서는 검증이 되지 않는다. 다른 계층에서 파라미터를 검증하기 위해서는 @Validated와 결합되어야 한다.</p>
<h4 id="validated를-이용한-유효성-검증"> [ @Validated를 이용한 유효성 검증 ]</h4>
<h5 id="validated의-개념-및-사용법"> &lt; @Validated의 개념 및 사용법 &gt;</h5>
<p>파라미터의 유효성 검증은 컨트롤러에서 처리하고 서비스나 레포지토리 계층에서는 유효성 검증을 하지 않는 것이 바람직하다. 하지만 개발을 진행하다보면 불가피하게 다른 곳에서 파라미터를 검증해야 할 수 있다.<br>
Spring에서는 이런 경우를 위해 <code>AOP기반으로 메소드를의 요청을 가로채서 유효성 검증을 진행</code> 할 수 있는 @Validated를 제공하고 있다. @Validated는 JSR 표준 기술이 아니며 Spring 프레임워크에서 제공하는 어노테이션 및 기능이다.<br>
다음과 같이 클래스 레벨에 @Validated를 붙여주고, 유효성을 검증할 메소드의 파라미터에 @Valid를 분여주면 유효성 검증이 진행된다.</p>
<div><pre><code><span>@Service</span>
<span>@Validated</span>
<span>public</span> <span>class</span> <span>UserService</span> <span>{</span>
    <span>public</span> <span>void</span> <span>addUser</span><span>(</span><span>@Valid</span> <span>UserRequestDto</span> userRequestDto<span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span><span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h5 id="validated의-동작-원리"> &lt; @Validated의 동작 원리 &gt;</h5>
<p>특정 ArgumentResolver에 의해 유효성 검사가 진행되었던 @Valid와 달리 @Validated는 AOP 기반으로 메소드 요청을 인터셉터하여 처리된다. @Validated를 클래스 레벨에 선언하면 해당 클래스에 유효성 검증을 위한 인터셉터가 등록된다. 그리고 해당 클래스의 메소드들이 호출될 때 AOP의 포인트 컷으로써 요청을 가로채서 인터셉터를 통해 유효성 검증을 진행한다 (물론 이러한 동작을 위해 @Validated가 붙은 클래스는 CGLib 기반으로 바이트 조작이 된다.)<br>
이러한 이유로 @Validated를 사용하면 컨트롤러, 서비스, 레포지토리 등 계층에 무관하게 스프링 빈이라면 유효성 검증을 진행할 수 있다. 물론 @Validated에 의한 예외 클래스도 다른데 @Valid에 의한 예외 클래스는 MethodArgumentNotValidException이며, @Validated에 의한 예외 클래스는 ConstrainViolationException이다. 이러한 정보를 알고 있으면 나중에 예외 처리를 할 때 도움이 된다.</p>
<h5 id="validated의-또-다른-기능-유효성-검증-그룹의-지정"> &lt; Validated의 또 다른 기능(유효성 검증 그룹의 지정) &gt;</h5>
<p>객체를 검증하기 위한 방법이 클래스에 따라 달라질 수 있다. 예를 들면 일반 사용자의 요청과 관리자의 요청을 보내는 경우에 같은 객체로 요청이 오지만 다른 방식으로 검증해야 하는 경우이다. 이런 경우에는 검증에 사용할 제약 조건이 2가지로 나누어져야 한다.<br>
Spring에서는 이런 경우를 위해 제약 조건 어노테이션에 조건이 적용될 검증 그룹을 지정하여 적용할 수 있는 기능 역시 @Validated를 통해 제공하고 있다.<br>
검증 그룹을 지정하기 위해서는 (내용이 없는)마커 인터페이스를 간단히 정의해야 한다. 위의 예시의 경우에는 사용자인 경우와 관리자인 경우를 분리해야 하므로 다음과 같은 2개의 마커 인터페이스를 만들 수 있다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>UserValidationGroup</span> <span>{</span><span>}</span>
<span>public</span> <span>interface</span> <span>AdminValidationGroup</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>그리고 해당 제약 조건이 적용될 그룸을 groups로 지정해줄 수 있다. 제약 조건이 적용될 그룹이 여러 개라면 {}를 이용해 그룹의 이름을 모두 넣어주면 된다.</p>
<div><pre><code><span>@NotEmpty</span><span>(</span>groups <span>=</span> <span>{</span><span>UserValidationGroup</span><span>.</span><span>class</span><span>,</span> <span>AdminValidationGroup</span><span>.</span><span>class</span><span>}</span><span>)</span>
<span>private</span> <span>String</span> name<span>;</span>

<span>@NotEmpty</span><span>(</span>groups <span>=</span> <span>UserValidationGroup</span><span>.</span><span>class</span><span>)</span>
<span>private</span> <span>String</span> userId<span>;</span>

<span>@NotEmpty</span><span>(</span>groups <span>=</span> <span>AdminValidationGroup</span><span>.</span><span>class</span><span>)</span>
<span>private</span> <span>String</span> adminId<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>그리고 컨트롤러에서도 다음과 같이 제약조건 검증을 적용할 클래스를 지정해주면 된다.</p>
<div><pre><code><span>@PostMapping</span><span>(</span><span>"/user/add"</span><span>)</span> 
<span>public</span> <span>ResponseEntity</span><span><span>&lt;</span><span>Void</span><span>></span></span> <span>addUser</span><span>(</span><span>@RequestBody</span> <span>@Validated</span><span>(</span><span>UserValidationGroup</span><span>.</span><span>class</span><span>)</span> <span>UserRequestDto</span> userRequestDto<span>)</span> <span>{</span> 
    <span>.</span><span>.</span><span>.</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>만약 위와 같이 UserValidationGroup을 @Validated의 파라미터로 넣어주었다면 UserValidationGroup에 해당하는 제약 조건만 검증이 된다. 만약 @Validated에 특정 마커를 지정해주지 않았거나, groups가 지정되어 있는데 @Valid를 이용한다면 다음과 같이 처리된다.</p>
<ul>
<li>@Validated에 특정 클래스를 지정하지 않는 경우 : groups가 없는 속성들만 처리</li>
<li>@Valid or @Valdated에 특정 클래스를 지정한 경우 : 지정된 클래스를 groups로 가진 제약사항만 처리</li>
</ul>
<h4 id="다양한-제약-조건-어노테이션"> [ 다양한 제약 조건 어노테이션 ]</h4>
<p>JSR 표준 스펙은 다양한 제약 조건 어노테이션을 제공하고 있는데, 대표적인 어노테이션으로는 다음과 같은 것들이 있다.</p>
<div><pre><code>@NotNull: 해당 값이 null이 아닌지 검증함
@NotEmpty: 해당 값이 null이 아니고, 빈 스트링(&quot;&quot;) 아닌지 검증함(&quot; &quot;은 허용됨)
@NotBlank: 해당 값이 null이 아니고, 공백(&quot;&quot;과 &quot; &quot; 모두 포함)이 아닌지 검증함
@AssertTrue: 해당 값이 true인지 검증함
@Size: 해당 값이 주어진 값 사이에 해당하는지 검증함(String, Collection, Map, Array에도 적용 가능)
@Min: 해당 값이 주어진 값보다 작지 않은지 검증함
@Max: 해당 값이 주어진 값보다 크지 않은지 검증함
@Pattern: 해당 값이 주어진 패턴과 일치하는지 검증함
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>그 외에도 주어진 값이 이메일 형식에 해당하는지 검증하는 @Email 등 다양한 어노테이션을 제공하고 있는데, 필요한 어노테이션이 있는지는 <a href="https://javaee.github.io/javaee-spec/javadocs/javax/validation/constraints/package-summary.html" target="_blank" rel="noopener noreferrer">자바공식문서<i>Content not supported</i></a>를 참고하면 된다<br>
그 외에도 hibernate의 Validator는 해당 값이 URL인지를 검증하는 @URL 등과 같은 어노테이션을 제공하고 있다. 즉, 우리가 필요로 하는 대부분의 제약 사항 어노테이션은 이미 구현되어 있으므로 찾아서 활용한다.</p>
<h3 id="valid와-validated-유효성-검증-차이"> @Valid와 @Validated 유효성 검증 차이</h3>
<h4 id="valid"> @Valid</h4>
<ul>
<li>JSR-303 자바 표준 스펙</li>
<li>특정 ArgumentResolver를 통해 진행되어 컨트롤러 메소드의 유효성 검증만 가능</li>
<li>유효성 검증에 실패할 경우 MethodArgmentNotValidException이 발생</li>
</ul>
<h4 id="validated"> @Validated</h4>
<ul>
<li>자바 표준 스펙이 아닌 스프링 프레임워크가 제공</li>
<li>AOP 기반으로 스프링 빈의 유효성 검증을 위해 사용되며 클래스에는 @Validated를, 메소드에는 @Valid를 붙여준다</li>
<li>유효성 검증에 실패할 경우 ConstraintViolationException이 발생</li>
</ul>
<p>별개로 Message Interpolator를 이용하면 유효성 검증이후 메세지를 다국어 처리 할 수 도 있다.</p>
<p>https://mangkyu.tistory.com/174</p>
<br>
<h2 id="_0320-커스텀-애노테이션-custom-annotation-로-직접-유효성-검사"> 0320 - 커스텀 애노테이션(Custom Annotation)로 직접 유효성 검사</h2>
<h4 id="검증을-위한-커스텀-어노테이션-생성"> [ 검증을 위한 커스텀 어노테이션 생성 ]</h4>
<div><pre><code><span>@Target</span><span>(</span><span>{</span>FIELD<span>}</span><span>)</span>
<span>@Retention</span><span>(</span>RUNTIME<span>)</span>
<span>@Constraint</span><span>(</span>validatedBy <span>=</span> <span>PhoneValidator</span><span>.</span><span>class</span><span>)</span>
<span>@Documented</span>
<span>public</span> <span>@interface</span> <span>Phone</span> <span>{</span>
    <span>String</span> <span>message</span><span>(</span><span>)</span> <span>default</span> <span>"Invalid Phone"</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>groups</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Payload</span><span>></span></span><span>[</span><span>]</span> <span>payload</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>@Target({FIELD}) : 해당 어노테이션을 필드에만 선언 가능함</li>
<li>@Retention(RUNTIME) : 해당 어노테이션이 유지되는 시간으로써 런타임까지 유효함</li>
<li>@Constraint(validatedBy = PhoneValidator.class) : PhoneValidator를 통해 유효성 검사를 진행함</li>
<li>@Documented : JavaDoc 생성시 Annotation에 대한 정보도 함께 생성</li>
</ul>
<p>아래의 3가지 속성들은 JSR-303 표준 어노테이션등리 갖는 공통 속성들이다. 해당 속성들은 각각 다음의 역할을 한다.</p>
<ul>
<li>message : 유효하지 않을 경우 반환할 메세지</li>
<li>groups : 유효성 검증이 진행될 그룹</li>
<li>payload : 유효성 검증 시에 전달할 메타 정보</li>
</ul>
<h4 id="검증을-위한-validator-구현"> [ 검증을 위한 Validator 구현 ]</h4>
<p>구현할 Validator는 JSR에서 제공하는 javax.validation의 ConstraintValidator 인터페이스를 구현해주어야 한다. 해당 인터페이스는 다음과 같이 생성되어 있다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>ConstraintValidator</span><span><span>&lt;</span><span>A</span> <span>extends</span> <span>Annotation</span><span>,</span> <span>T</span><span>></span></span> <span>{</span> 
    
    <span>default</span> <span>void</span> <span>initialize</span><span>(</span><span>A</span> constraintAnnotation<span>)</span> <span>{</span> 

    <span>}</span> 
    
    <span>boolean</span> <span>isValid</span><span>(</span><span>T</span> value<span>,</span> <span>ConstraintValidatorContext</span> context<span>)</span><span>;</span> 

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>위의 인터페이스는 2가지 제네릭 타입을 받고 있는데, 순서대로 적용될 어노테이션과 적용될 타입에 해당된다. 또한 ConstraintValidator가 갖는 메소드들은 각각 다음의 역할을 한다.</p>
<ul>
<li>initialize : Valdator를 초기화하기 위한 메소드</li>
<li>isValid : 유효성을 검증하는 메소드</li>
</ul>
<p>intialize는 기본적으로 default 메소드로 구현되어 있으므로 초기화할 작업이 없다면 따로 구현해주지 않아도 된다. initialize는 isValid가 처음 호출될 때 1회 호출된다. isValid에는 우리가 검증할 로직을 구현주면 된다.<br>
이제 연락처를 검증하기 위한 Validator를 구현하면 다음과 같다.</p>
<div><pre><code><span>public</span> <span>class</span> <span>PhoneValidator</span> <span>implements</span> <span>ConstraintValidator</span><span><span>&lt;</span><span>Phone</span><span>,</span> <span>String</span><span>></span></span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>String</span> value<span>,</span> <span>ConstraintValidatorContext</span> context<span>)</span> <span>{</span>
        <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"\\d{3}-\\d{4}-\\d{4}"</span><span>)</span><span>;</span> <span>// 예제</span>
        <span>Matcher</span> matcher <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span>value<span>)</span><span>;</span>
        <span>return</span> matcher<span>.</span><span>matches</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0321 - 0328</title>
      <link>ahnjs/TIL/2022/0321/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0321/</guid>
      <source url="ahnjs/TIL/rss.xml">0321 - 0328</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0321-0328"> 0321 - 0328</h1>
<h2 id="_0321-자바-표준-jls-jsr-jep"> 0321 - 자바 표준 (JLS, JSR, JEP)</h2>
<p>자바 스펙 관련해서 JSR-123, JLS-123 처럼 스펙을 확인할 수 있다. 이런 스펙뒤에는 '자바 커뮤니티 프로세스(JCP, Java Community Process)'가 있다.</p>
<h3 id="자바-강화-제안-java-enhancement-proposal-jep"> 자바 강화 제안 (Java Enhancement Proposal, JEP)</h3>
<p>자바 코어 기술을 강화하기위한 제안 문서다. 이 제안들은 대부분 이어서 설명할 JSR이나 JLS같은 명세로 정리할 상태는 아니다. OpenJDK/JDK의 업데이트에 포함될 수 있는 제안 목록들이다.<br>
채택된 JEP는 특정 JDK릴리즈에 포함될 수 있으며, 모든 JEP가 승인되어 업데이트에 포함되는건 아니다.<br>
JEP에 제안되는 목록들이 JDK의 로드맵이 된다.</p>
<p>일반적으로 실행 가능한 것과 실행 불가능한 것들을 나누고 명세가 생성될 수 있는 지점까지 명확하게 하기 위해 프로토타이핑이 필요하다.</p>
<h3 id="자바-요청-명세서-java-specification-request-jsr"> 자바 요청 명세서(Java Specification Request, JSR)</h3>
<p>JCP의 새 명세를 만들기 위해 구성된 팀원들을 위해 만들어진 문서다. 일반적인 JSR의 주제는 이미 성숙된 기술과 관련이 있다. 다시 말해서 분류될 수 있는 상태에 있다.<br>
다만 이명세들은 항상 자바와 관련되어 있음에도 때론 명세들이 Java SE 또는 Java EE 기술의 핵심이 되지는 않는다.</p>
<h3 id="자바-언어-명세서-java-language-specification-jls"> 자바 언어 명세서(Java Language Specification, JLS)</h3>
<p>자바 언어 명세서를 뜻한다. JLS는 자바 프로그래밍 언어를 위한 문법과 정상적인/비정상적인 규칙들을 보여준다. 그리고 정상적인 프로그램을 실행하기위한 프로그램 방법들도 보여준다.</p>
<blockquote>
<p>JEP가 지속적으로 나오고 그 JEP중 JSR로 승격될만한 것을 선별한 다음 승격한다.<br>
이러한 JSR을 구체화 해서 버전별로 정의해둔 것이 JLS 문서이다.</p>
</blockquote>
<br>
<h2 id="_0322-elementcolleciton-collectiontable"> 0322 - @ElementColleciton, @CollectionTable</h2>
<h3 id="값-타입-컬렉션"> 값 타입 컬렉션</h3>
<p>말 그대로 값 타입을 컬렉션에 담아서 사용하는 것이다. (@OneToMany 처럼 엔티티를 컬렉션으로 사용하는 것이 아닌, Integer, String, 임베디드 타입 같은 값 타입을 컬렉션으로 사용하는 것이다.)</p>
<p>관계형 데이터베이스는 컬렉션을 담을 수 있는 구조가 없다. 따라서 이를 저장하기 위해서는 별도의 테이블을 만들어서 저장해야 하는데, 개념적으로 보면 1대 N관계 이다. (값 타입을 저장하는 테이블은, 값 타입을 소유한 엔티티의 기본 키와, 모든 값 타입 필드를 묶어서 PK로 사용하며, 엔티티의 기본키를 PK겸 FK로 사용한다.)</p>
<h3 id="elementcolleciton"> @ElementColleciton</h3>
<p>값 타입 컬렉션을 매핑할 때 사용한다. @Entity가 아닌 Basic Type이나 Embeddable Class로 정의된 컬렐션을 테이블로 생성하며 One-To-Many 관계를 다룬다.<br>
@ElementColleciton은 @CollectionTable과 함께 사용한다.</p>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>StudyGroup</span> <span>{</span>
    <span>@Id</span> 
    <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>IDENTITY<span>)</span>
    <span>private</span> <span>Long</span> id<span>;</span>
 
    <span>// Basic type</span>
    <span>@ElementCollection</span><span>(</span>fetch <span>=</span> <span>FetchType</span><span>.</span>LAZY<span>)</span>
    <span>@Column</span><span>(</span>name <span>=</span> <span>"TOPIC_NAME"</span><span>)</span><span>//String인 경우에 한해서 예외적으로 허용, 이외 타입은 @AttributeOverride를 사용해서 테이블 속성을 재정의한다.</span>
    <span>private</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> topicTags <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
 
    <span>// Embedded type</span>
    <span>@ElementCollection</span>
    <span>@CollectionTable</span><span>(</span>name<span>=</span><span>"study_group_member"</span><span>,</span> joinColumns <span>=</span> <span>@JoinColumn</span><span>(</span>name<span>=</span> <span>"study_group_id"</span><span>,</span> referencedColumnName <span>=</span> <span>"id"</span><span>)</span><span>)</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>StudyGroupMember</span><span>></span></span> members <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>StudyGroupMember</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@Embeddable</span>
<span>public</span> <span>class</span> <span>StudyGroupMember</span> <span>{</span>
    <span>private</span> <span>UUID</span> memberId<span>;</span>
    <span>private</span> <span>Boolean</span> isOwner<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>값 타입 컬렉션은 조회 시 지연로딩 전략을 사용한다.</li>
<li>값 타입은 그 생명주기를 부모 엔티티에 의해 관리된다. 즉 영속성 전이(Cascade ALL) + 고아 객체 제거 기능을 필수로 가진다.</li>
</ul>
<h3 id="elementcollection과-entity의-onetomany-차이"> @ElementCollection과 @Entity의 @OneToMany 차이</h3>
<ul>
<li>
<p>@ElementCollection</p>
<ul>
<li>연관된 부모 Entity 하나에만 연관되어 관리된다.</li>
<li>항상 부모와 함께 저장되고 삭제되므로 cascade 옵션은 제공하지 않는다.</li>
<li>부모 Entity Id와 추가 컬럼(basic or embedded 타입)으로 구성된다.</li>
<li>기본적으로 식별자 개념이 없으므로 컬렉션 값 변경 시, 전체 삭제 후 새로 추가한다.</li>
</ul>
</li>
<li>
<p>@Entity 연관</p>
<ul>
<li>다른 Entity에 의해 관리될 수도 있다.</li>
<li>join table이나 컬럼은 보통 ID만으로 연관을 맺는다.</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0323-docker-compose-기본-사용법"> 0323 - docker compose 기본 사용법</h2>
<h3 id="docker-compose란"> docker compose란?</h3>
<p>docker compose는 여러 개의 docker container를 모아서 관리하기 위한 툴이다.<br>
웹 서비스는 일반적으로 프론트엔드 서버, 벡엔드 서버, 데이터베이스 서버로 구성되기 때문에 각 서버를 Docker container로 연결하여 동작시키고 docker compose를 사용하여 해당 컨테이너들을 관리하는 것이다.</p>
<h3 id="docker-compose-yml"> docker-compose.yml</h3>
<p>docker- compose.yml은 장황한 도커 실행 옵션을 미리 적어둔 문서이다.<br>
프로젝트 루트에 파일을 만들고, 실행 설정을 적어준다. 그래야 터미널에서 토커 명령어를 사용하여 컨테이너를 실행하거나 죽일 수 있다.</p>
<ul>
<li>시스템 안에서 가동하는 여러 서버들의 구성을 모아서 정의</li>
</ul>
<div><pre><code>- version :  버전 지정  
- services :  서비스 정의  
- image :  이미지 지정  
- build :  Dockerfile 위치 지정
- command :  container 에서 작동하는 명령
- entrypoint : container 에서 작동하는 명령
- depends_on : 서비스간 의존관계 설정
- environment : 컨테이너 안 환경변수 설정
- container_name : 컨테이너 이름 설정
- volumes : 컨테이너에 볼륨 Mount
- volumes_from : 다른 컨테이너로부터 모든 볼륨 마운트
- links : 다른 컨테이너와 연결
- ports : Host 에 컨테이너가 공개하는 포트지정
- expose : 컨테이너끼리 공개하는 포트 지정
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="docker-compose-기본-명령어"> docker-compose 기본 명령어</h3>
<ul>
<li>docker-compose up [옵션] [서비스명] : 컨테이너를 생성 및 실행한다.</li>
</ul>
<div><pre><code>-d : 백그라운드 실행
--No-deps : 링크 서비스 실행하지 않음
--build : 이미지 빌드
-t : 타임아웃을 지정(기본 10초)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>docker-compose ps : 현재 동작중인 컨테이너들의 상태를 확인할 수 있다.</li>
<li>docker-compose logs : 컨테이너들의 로그를 출력한다.</li>
<li>docker-compose run [서비스명] [명령] : docker-compose up 명령어를 이용해 생성 및 실행된 컨테이너에서 임의의 명령을 실행하기 위해 사용한다. 컨테이너들을 모두 삭제할 경우 docker-compose start가 아닌, docker-compose up으로 다시 컨테이너들을 생성해주어야 한다.</li>
<li>docker-compose (start/stop/pause/unpause/restart) : 여러개의 서비스 또는 특정 서비스를 시작/정지/일시정지/재시작을 할 수 있다. 각각의 설정뒤에 서비스명을 붙이면 특정 서비스만 제어할 수 있다.</li>
<li>docker-compose rm : docker-compose로 생성한 컨테이너들을 일괄 삭제한다.(삭제 전, 관련 컨테이너들을 종료 시켜두어야 한다.)</li>
<li>docker-compose kill : 실행중인 컨테이너를 강제로 정지시킨다. kill 뒤에는 서비스를 지정하여 특정 서비스만 kill할 수 있다. -s 옵션을 사용하여 시그널을 지정해줄 수 있다.</li>
<li>docker-compose down : 네트워크 정보, 볼륨, 컨테이너들을 일괄 정지 및 삭제 처리한다. (만약 docker-compose down —rmi all 명령을 사용한다면 모든 이미지까지 삭제 한다.)</li>
<li>docker-compse port [서비스명] [프라이빗 포트번호] : 서비스 프라이빗 포트 번호의 설정을 확인할 수 있다.</li>
<li>docker-compose config : 구성 파일의 내용을 확인할 수 있다. docker-compose.yml의 내용을 출력</li>
</ul>
<br>
<h2 id="_0327-가변인자-varargs"> 0327 - 가변인자(varargs)</h2>
<ul>
<li>형태</li>
</ul>
<div><pre><code><span>public</span> <span>void</span> <span>test</span><span>(</span>string<span>.</span><span>.</span><span>.</span> parameter<span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="오버로딩"> 오버로딩</h3>
<p>자바에서는 파라미터 개수가 다르면 다른 메소드로 인신한다.<br>
동일한 기능을 하지만 파라미터가 가변적으로 변경되는 경우 오버로딩을 사용한다.</p>
<div><pre><code><span>// 파라미터가 한 개인 경우</span>
<span>public</span> <span>void</span> <span>search</span><span>(</span><span>String</span> one<span>)</span> <span>{</span><span>}</span>

<span>// 파라미터가 두 개인 경우</span>
<span>public</span> <span>void</span> <span>search</span><span>(</span><span>String</span> one<span>,</span> <span>String</span> two<span>)</span> <span>{</span><span>}</span>

<span>// 파라미터가 세 개인 경우</span>
<span>public</span> <span>void</span> <span>search</span><span>(</span><span>String</span> one<span>,</span> <span>String</span> two<span>,</span> <span>String</span> three<span>)</span> <span>{</span><span>}</span>

<span>// Map을 사용하는 경우</span>
<span>public</span> <span>void</span> <span>search</span><span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> param<span>)</span> <span>{</span><span>}</span>

<span>// 배열을 사용하는 경우</span>
<span>public</span> <span>void</span> <span>search</span><span>(</span><span>String</span><span>[</span><span>]</span> param<span>)</span> <span>{</span><span>}</span>

<span>// List를 사용하는 경우</span>
<span>public</span> <span>void</span> <span>search</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> param<span>)</span> <span>{</span><span>}</span>

<span>// VO객체를 사용하는 경우</span>
<span>public</span> <span>void</span> <span>search</span><span>(</span><span>ParamVO</span> param<span>)</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="가변인자"> 가변인자</h3>
<p>가변인자를 사용하면 동적으로 파라미터를 받을 수 있으며 자바 1.5부터 지원된다. 사용법은 변수 타입 뒤에 기호(...)를 붙여주면 됩니다.</p>
<p>가변인자를 가지고 있는 메소드를 호출할 때는 아래 방법 모두 가능하다</p>
<div><pre><code><span>public</span> <span>void</span> <span>callMethod</span><span>(</span><span>)</span> <span>{</span>
	
    <span>// 파라미터가 없음</span>
    <span>test</span><span>(</span><span>)</span><span>;</span>
    
    <span>// 파라미터가 한개</span>
    <span>test</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
    
    <span>// 파라미터가 두개</span>
    <span>test</span><span>(</span><span>"A"</span><span>,</span> <span>"B"</span><span>)</span><span>;</span>
    
    <span>// 배열로 전달</span>
    <span>test</span><span>(</span><span>new</span> <span>String</span><span>[</span><span>]</span><span>{</span><span>"A"</span><span>,</span> <span>"B"</span><span>,</span> <span>"C"</span><span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>void</span> <span>test</span><span>(</span><span>String</span><span>.</span><span>.</span><span>.</span> param<span>)</span> <span>{</span>

	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"param: "</span> <span>+</span> param<span>)</span><span>;</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>다른 파라미터와 가변인자를 같이 사용하는 경우에는 가변인자를 제일 뒤에 위치 시켜야 한다.</p>
<div><pre><code><span>public</span> <span>void</span> <span>test2</span><span>(</span><span>String</span> name<span>,</span> <span>String</span><span>.</span><span>.</span><span>.</span> param<span>)</span> <span>{</span>

	<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"param: "</span> <span>+</span> param<span>)</span><span>;</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0404 ~ 0410</title>
      <link>ahnjs/TIL/2022/0404/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0404/</guid>
      <source url="ahnjs/TIL/rss.xml">0404 ~ 0410</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0404-0410"> 0404 ~ 0410</h1>
<h2 id="_0404-try-with-resource"> 0404 - try-with-resource</h2>
<p>자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다.<br>
ex) InputStream, OutputStream, java.sql.Connection<br>
자원 닫기는 클라이언트가 놓치기 쉬워서 예측할 수 없는 성능 문제로 이어지기도 한다.<br>
전통적으로 자원이 제대로 닫힘을 보장하는 수단으로 try-finally가 쓰였다.</p>
<h3 id="try-finally"> try-finally</h3>
<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>firstLineOfFile</span><span>(</span><span>String</span> path<span>)</span> <span>throw</span> <span>IOException</span> <span>{</span>
    <span>BufferedReader</span> br <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>FileReader</span><span>(</span>path<span>)</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>return</span> br<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        br<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>자원이 둘 이상이면 지저분하다.</li>
</ul>
<div><pre><code><span>static</span> <span>void</span> <span>copy</span><span>(</span><span>String</span> src<span>,</span> <span>String</span> dst<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
	<span>InputStream</span> in <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>src<span>)</span><span>;</span>
	<span>try</span> <span>{</span>
		<span>OutputStream</span> out <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>dst<span>)</span><span>;</span>
		<span>try</span> <span>{</span>
			<span>byte</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>byte</span><span>[</span>BUFFER_SIZE<span>]</span><span>;</span>
			<span>int</span> n<span>;</span>
			<span>while</span> <span>(</span><span>(</span>n <span>=</span> in<span>.</span><span>read</span><span>(</span>buf<span>)</span><span>)</span> <span>>=</span> <span>0</span><span>)</span>
			out<span>.</span><span>write</span><span>(</span>buf<span>,</span> <span>0</span><span>,</span> n<span>)</span><span>;</span>
		<span>}</span> <span>finally</span> <span>{</span>
			out<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span> <span>finally</span> <span>{</span>
		in<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="try-with-resources"> try-with-resources</h3>
<p>이 구조를 사용하려면 해당 자원이 <code>AutoCloseable</code> 인터페이스를 구현해야한다.<br>
(AutoCloseable: 단순히 void를 반환하는 close 메서드 하나만 정의한 인터페이스) 닫아야 하는 자원을 뜻하는 클래스를 작성한다면 AutoCloseable을 반드시 구현해야 한다.</p>
<div><pre><code><span>// try-with-resources에서도 catch 절을 쓸 수 있다</span>
<span>public</span> <span>static</span> <span>String</span> <span>firstLineOfFile</span><span>(</span><span>String</span> path<span>)</span> <span>throw</span> <span>IOException</span> <span>{</span>
    <span>try</span> <span>(</span><span>BufferedReader</span> br <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>FileReader</span><span>(</span>path<span>)</span><span>)</span><span>)</span> <span>{</span>
        <span>return</span> br<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
        <span>return</span> defaultVal<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>// 복수의 자원을 처리하는 try-with-resources</span>
<span>static</span> <span>void</span> <span>copy</span><span>(</span><span>String</span> src<span>,</span> <span>String</span> dst<span>)</span> <span>throws</span> <span>IOException</span> <span>{</span>
	<span>try</span> <span>(</span><span>InputStream</span> in <span>=</span> <span>new</span> <span>FileInputStream</span><span>(</span>src<span>)</span><span>;</span>
		<span>OutputStream</span> out <span>=</span> <span>new</span> <span>FileOutputStream</span><span>(</span>dst<span>)</span><span>)</span> <span>{</span>
		<span>byte</span><span>[</span><span>]</span> buf <span>=</span> <span>new</span> <span>byte</span><span>[</span>BUFFER_SIZE<span>]</span><span>;</span>
		<span>int</span> n<span>;</span>
		<span>while</span> <span>(</span><span>(</span>n <span>=</span> in<span>.</span><span>read</span><span>(</span>buf<span>)</span><span>)</span> <span>>=</span> <span>0</span><span>)</span>
		out<span>.</span><span>write</span><span>(</span>buf<span>,</span> <span>0</span><span>,</span> n<span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>try-with-resources를 사용할 경우 close를 알아서 호출해주며, close호출에서 예외가 발생했을 때, close에서 발생한 예외는 숨겨지고 첫번째 예외가 기록된다. 이렇게 실전에서는 예외 하나만 보존되고 여러 개의 다른 예외가 숨겨질 수 있다. 이렇게 숨겨진 예외들은 스택 추적 내역에 suppressed 꼬리표를 달고 출력된다.</li>
</ul>
<br>
<h2 id="_0407-busy-waiting"> 0407 - busy-waiting</h2>
<h3 id="busy-waiting-이란"> Busy Waiting 이란</h3>
<ul>
<li>원하는 자원을 얻기 위해 기다리는 것이 아니라 권한을 얻을 떄까지 확인하는 것을 의미한다.</li>
</ul>
<h4 id="사용하는-경우"> 사용하는 경우</h4>
<ul>
<li>자원의 권한을 얻는데 많은 시간이 소됴되지 않는 상황인 경우.</li>
<li>Context Switching 비용보다 성능적으로 더 우수한 상황인 경우.</li>
</ul>
<h4 id="단점"> 단점</h4>
<ul>
<li>권한 획들을 위해 많은 CPU를 낭비한다</li>
</ul>
<h4 id="다른방법"> 다른방법</h4>
<ul>
<li>지속적으로 확인하는 Busy Waiting이 아닌 Sleeping 이라는 방법을 사용할 수 있다.</li>
</ul>
<h3 id="sleeping-이란"> Sleeping 이란</h3>
<ul>
<li>권한을 얻기 위해 기다리는 시간을 wait queue에 실행 중인 Thread 정보를 담고 다른 Thread에게 CPU를 양보하는 것을 의미한다.</li>
<li>커널은 권한 이벤트가 발생하면 Wait queue에 담긴 Thread를 깨워 CPU를 부여합니다.</li>
</ul>
<h4 id="사용하는-경우-2"> 사용하는 경우</h4>
<ul>
<li>기다리는 시간이 예측이 불가능한 상황인 경우</li>
</ul>
<h4 id="단점-2"> 단점</h4>
<ul>
<li>wait queue에 넣는 비용 + Context Switching 비용이 드는 단점이 있다.</li>
</ul>
<br>
<h2 id="_0409-entitylisteners"> 0409 - @EntityListeners</h2>
<h3 id="jpa-entitylistener란"> JPA EntityListener란</h3>
<p><a href="https://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/listeners.html" target="_blank" rel="noopener noreferrer">하이버네이트 문서<i>Content not supported</i></a>에서는 JPA Entity에 이벤트가 발생할 때 콜백을 처리하고 코드를 실행하는 방법이라고 소개하고 있따.</p>
<p>JPA에서는 아래의 7가지 이벤트를 제공한다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FboeHCs%2Fbtq0A3iSjTq%2FjqQu1hIoskodVKc7xZDUw1%2Fimg.png" alt="image"></p>
<ul>
<li>@PrePersist : Persist(insert)메서드가 호출되기 전에 실행되는 메서드</li>
<li>@PreUpdate : merge메서드가 호출되기 전에 실행되는 메서드</li>
<li>@PreRemove : Delete메서드가 호출되기 전에 실행되는 메서드</li>
<li>@PostPersist : Persist(insert)메서드가 호출된 이후에 실행되는 메서드</li>
<li>@PostUpdate : merge메서드가 호출된 후에 실행되는 메서드</li>
<li>@PostRemove : Delete메서드가 호출된 후에 실행되는 메서드</li>
<li>@PostLoad : Select조회가 일어난 직후에 실행되는 메서드</li>
</ul>
<h3 id="예제"> 예제</h3>
<div><pre><code><span>// Auditable.java</span>
<span>public</span> <span>interface</span> <span>Auditable</span> <span>{</span>
    <span>LocalDateTime</span> <span>getCreatedAt</span><span>(</span><span>)</span><span>;</span>
    <span>LocalDateTime</span> <span>getUpdatedAt</span><span>(</span><span>)</span><span>;</span>

    <span>void</span> <span>setCreatedAt</span><span>(</span><span>LocalDateTime</span> createdAt<span>)</span><span>;</span>
    <span>void</span> <span>setUpdatedAt</span><span>(</span><span>LocalDateTime</span> updatedAt<span>)</span><span>;</span>
<span>}</span>

<span>// MyEntityListener.java</span>
<span>public</span> <span>class</span> <span>MyEntityListener</span> <span>{</span>
    <span>@PrePersist</span>
    <span>public</span> <span>void</span> <span>prePersist</span><span>(</span><span>Object</span> o<span>)</span><span>{</span>
        <span>if</span><span>(</span>o <span>instanceof</span> <span>Auditable</span><span>)</span><span>{</span>
            <span>(</span><span>(</span><span>Auditable</span><span>)</span> o<span>)</span><span>.</span><span>setCreatedAt</span><span>(</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>(</span><span>(</span><span>Auditable</span><span>)</span> o<span>)</span><span>.</span><span>setUpdatedAt</span><span>(</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>@PreUpdate</span>
    <span>public</span> <span>void</span> <span>preUpdate</span><span>(</span><span>Object</span> o<span>)</span><span>{</span>
        <span>if</span><span>(</span>o <span>instanceof</span> <span>Auditable</span><span>)</span><span>{</span>
            <span>(</span><span>(</span><span>Auditable</span><span>)</span> o<span>)</span><span>.</span><span>setUpdatedAt</span><span>(</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>// User.java</span>
<span>@Entity</span>
<span>@NoArgsConstructor</span>
<span>@Data</span>
<span>@EntityListeners</span><span>(</span>value <span>=</span> <span>{</span><span>MyEntityListener</span><span>.</span><span>class</span><span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>User</span> <span>implements</span> <span>Auditable</span><span>{</span>
		<span>.</span><span>.</span><span>.</span>

		<span>@Column</span><span>(</span>updatable <span>=</span> <span>false</span><span>)</span>
    <span>private</span> <span>LocalDateTime</span> createdAt<span>;</span>

    <span>private</span> <span>LocalDateTime</span> updatedAt<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h3 id="entitylisteners에서-di하는-방법"> EntityListeners에서 DI하는 방법</h3>
<h4 id="_1-applicationcontext"> 1. ApplicationContext</h4>
<div><pre><code><span>public</span> <span>class</span> <span>PersonEntityListener</span> <span>{</span>
    <span>@Autowired</span>
    <span>private</span> <span>ApplicationContext</span> applicationContext<span>;</span>
    <span>@PrePersist</span>
    <span>public</span> <span>void</span> <span>prePersist</span><span>(</span><span>Person</span> person<span>)</span> <span>{</span>
        <span>PersonRepository</span> personRepository <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>PersonRepository</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"prePersist : "</span> <span>+</span> personRepository<span>)</span><span>;</span>
        person<span>.</span><span>setCreatedTime</span><span>(</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>ApplicationContext를 주입 받아 getBean을 통해 가져온다.</li>
</ul>
<h4 id="_2-lazypermalink"> 2. @LazyPermalink</h4>
<div><pre><code><span>public</span> <span>class</span> <span>PersonEntityListener</span> <span>{</span>
    <span>@Lazy</span>
    <span>@Autowired</span>
    <span>private</span> <span>PersonRepository</span> personRepository<span>;</span>
    <span>@PrePersist</span>
    <span>public</span> <span>void</span> <span>prePersist</span><span>(</span><span>Person</span> person<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"prePersist : "</span> <span>+</span> personRepository<span>)</span><span>;</span>
        person<span>.</span><span>setCreatedTime</span><span>(</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>@Lazy를 추가하여, context refresh 시점에는 proxy 상태였다가, 해당 Repository가 처음 사용될 때 초기화가 될 수 있게 변경</li>
</ul>
<h4 id="_3-bootstrapmode-deferred-or-lazy"> 3. BootstrapMode Deferred or Lazy</h4>
<div><pre><code><span>@EnableJpaRepositories</span><span>(</span>bootstrapMode <span>=</span> <span>BootstrapMode</span><span>.</span>DEFERRED<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>spring</span><span>:</span>
  <span>data</span><span>:</span>
    <span>jpa</span><span>:</span>
      <span>repositories</span><span>:</span>
        <span>bootstrap-mode</span><span>:</span> deferred
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>BootstrapMode를 Deffrred로 설정하게 되면, JPaRepositories를 proxy로 생성해준다.</li>
<li>또한, Spring context가 load하는 thread와 다른 thread를 이용해서 작업이 지행되고, ContextRefreshedEvent에 trigger에 의해서 repository가 초기화가 진행된다.</li>
<li>결론은 @Lazy와 비슷하게 동작 하지만 application이 시작전에 Repository 들이 초기화가 보장되어 있고, load속도도 빨라진다.</li>
</ul>
<h4 id="참고"> 참고</h4>
<p>https://milenote.tistory.com/79
https://kangwoojin.github.io/programing/jpa-entity-listeners/</p>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FboeHCs%2Fbtq0A3iSjTq%2FjqQu1hIoskodVKc7xZDUw1%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0329 ~ 0403</title>
      <link>ahnjs/TIL/2022/0328/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0328/</guid>
      <source url="ahnjs/TIL/rss.xml">0329 ~ 0403</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0329-0403"> 0329 ~ 0403</h1>
<h2 id="_0329-requestmapping"> 0329 - @RequestMapping</h2>
<p>요청을 특정 메서드와 매핑하기 위해 사용.</p>
<ul>
<li>name : 해당 어노테이션에게 별칭을 붙이기 위해 사용</li>
<li>value : 처리할 uri 패턴들(String 배열)을 기입</li>
</ul>
<div><pre><code>?: matches one character
*: matches zero or more characters within a path segment
**: match zero or more path segments
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>path : value와 같은 목적</li>
<li>method : 특정 http method만 요청을 처리하고자 할 때 사용</li>
<li>params : 특정 파라미터가 존재하는 경우만 요청을 처리하고자 할 때 사용</li>
</ul>
<div><pre><code>RequestMapping(value=&quot;hello&quot;, params=&quot;id&quot;): /hello?id=123 처리 가능
RequestMapping(value=&quot;hello&quot;, params=&quot;id=1234&quot;): /hello?id=123 처리 불가능, /hello?id=1234 처리 가능
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>headers : 특정 헤더가 존재하는 경우만 요청을 처리하고자 할 때 사용</li>
<li>consumes : 특정 타입의 바디를 가지는 요청만을 처리하고자 할 때 사용</li>
<li>produces : 응답의 타입을 특정 타입으로 설정하고자 할 때 사용</li>
</ul>
<br>
<h2 id="_0330-query-dsl-세팅-by-gradle"> 0330 - query dsl 세팅 by gradle</h2>
<p>query dsl 설정은 대표적으로 2가지이다. <code>querydsl plugin</code>을 이용하는 방법과 <code>annotationProcessor</code>을 이용하여 생성하는 방법이 있다.</p>
<h3 id="querydsl-plugin"> querydsl plugin</h3>
<div><pre><code>ext {
    set(&#39;queryDSL&#39;, &#39;4.3.1&#39;)
}

dependencies {
    implementation &quot;com.querydsl:querydsl-jpa:${queryDSL}&quot;
    
    annotationProcessor &quot;com.querydsl:querydsl-apt:${queryDSL}:jpa&quot;
    // 또는
    annotationProcessor &quot;com.querydsl:querydsl-apt:${dependencyManagement.importedProperties[&#39;querydsl.version&#39;]}:jpa&quot;

    annotationProcessor &#39;org.hibernate.javax.persistence:hibernate-jpa-2.1-api:1.0.2.Final&#39;
    annotationProcessor &#39;javax.annotation:javax.annotation-api:1.3.2&#39;
    ...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="annotationprocessor"> annotationProcessor</h3>
<div><pre><code>plugins {
    ...
    id &quot;com.ewerk.gradle.plugins.querydsl&quot; version &quot;1.0.10&quot;
}

compileQuerydsl{
    options.annotationProcessorPath = configurations.querydsl
}

configurations {
    ...
    querydsl.extendsFrom compileClasspath
}

def querydslSrcDir = &#39;src/querydsl/generated&#39;

querydsl {
    library = &quot;com.querydsl:querydsl-apt&quot;
    jpa = true
    querydslSourcesDir = querydslSrcDir
}

sourceSets {
    main {
        java {
            srcDirs = [&#39;src/main/java&#39;, querydslSrcDir]
        }
    }
}

project.afterEvaluate {
    project.tasks.compileQuerydsl.options.compilerArgs = [
            &quot;-proc:only&quot;,
            &quot;-processor&quot;, project.querydsl.processors() +
                    &#39;,lombok.launch.AnnotationProcessorHider$AnnotationProcessor&#39;
    ]
}

dependencies {
    implementation(&quot;com.querydsl:querydsl-jpa&quot;) // querydsl
    implementation(&quot;com.querydsl:querydsl-apt&quot;) // querydsl
    ...
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h3 id="차이점"> 차이점</h3>
<h4 id="compliequerydsl-시점"> complieQuerydsl 시점</h4>
<ul>
<li>querydsl plugin을 사용하게 되면, querydsl을 생성하는 방법은 gradle option에 있는 compileQuerydsl 사용하거나, build를 통해서 compile이 되어야 생성된다.</li>
<li>해당 방식을 이용하게 되면, compileJava 시점에 querydsl QModel이 생성이 된다.</li>
<li>즉, intellij에 Run, Debug를 통해서 서버를 실행할 때도 자동으로 최신 querydsl QModel을 생성하게 된다.</li>
</ul>
<h4 id="cache-유무"> Cache 유무</h4>
<ul>
<li>gradle의 cache를 사용하기 위해서는 org.gradle.caching=true 설정을 해주어야 한다.</li>
<li>querydsl plugin을 이용해서도 cache가 가능한지는 모르겠지만 annotationProcessor 방식을 이용하면 Cache가 가능하다.</li>
<li>그 이유는 compileJava 부분에 QModel을 생성하기에 변경이 발생하지 않는다면 gradle에서 증분 컴파일 옵셔에 의해서 cache key를 사용할 수 있게 된다.</li>
</ul>
<h4 id="마치며"> 마치며</h4>
<ul>
<li>cache를 타기 위해서는 같은 부분에 변경이 없어야지만 cache를 이용하기에 무조건 좋아지는 것은 아니다.</li>
<li>또한, build시에 gradle cache key를 매번 변경시키는 로직이 포함되어 있다면, cache를 이용하지 못 한다.(ex: download files, springboot-buildInfo etc)</li>
<li>querydsl plugin은 더 이상 개발이 되고 있는지 모르겠고, gradle에서 deprecated된 compile을 사용하고 있어 추후 gradle version을 올릴때 제약사항이 될꺼 같아 변경하는 것이 좋아보인다.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0411 ~ 0417</title>
      <link>ahnjs/TIL/2022/0411/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0411/</guid>
      <source url="ahnjs/TIL/rss.xml">0411 ~ 0417</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0411-0417"> 0411 ~ 0417</h1>
<h2 id="_0411-dfs-bfs의-설명-차점"> 0411 - DFS, BFS의 설명, 차점</h2>
<blockquote>
<p>BFS, DFS 두가지 모두 그래프를 탐색하는 방법이다.</p>
</blockquote>
<p>그래프란, 정점(node)와 그 정점을 연결하는 간선(edge)으로 이루어진 자료구조의 일종을 말하며, 그래프를 탐색한다는 것은 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것을 말한다.</p>
<h3 id="dfs-깊이-우선-탐색-depth-first-search"> DFS 깊이 우선 탐색 (Depth-First Search)</h3>
<p><img src="https://velog.velcdn.com/images%2Flucky-korma%2Fpost%2F30737a15-9adf-49a6-96a0-98c211cab1cc%2FR1280x0.gif" alt="image"></p>
<p>루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식을 말한다.<br>
예를 들어, 미로찾기를 할 때 최대한 한 방향으로 갈 수 있을 때까지 쭉 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와서 그 갈림길부터 다시 다른 방향으로 탐색을 진행하는 것이 깊이 우선 탐색 방식이라고 할 수 있다.</p>
<ul>
<li>모든 노드를 방문하고자 하는 경우에 이 방법을 선택함</li>
<li>깊이 우선 탐색(DFS)이 너비 우선 탐색(BFS)보다 좀 더 간단함</li>
<li>검색 속도 자체는 너비 우선 탐색(BFS)에 비해서 느림</li>
</ul>
<h3 id="bfs-너비-우선-탐색-breadth-first-search"> BFS 너비 우선 탐색 (Breadth-First Search)</h3>
<p><img src="https://velog.velcdn.com/images%2Flucky-korma%2Fpost%2F2112183b-bfcd-427e-8072-c9dc983180ba%2FR1280x0-2.gif" alt="image"></p>
<p>루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법으로, 시작 정점으로부터 가장운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법.<br>
주로 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택.<br>
ex) 지구 상에 존재하는 모든 친구 관계를 그래프로 표현한 후 Sam과 Eddie사이에 존재하는 경로를 찾는 경우</p>
<ul>
<li>깊이 우선 탐색의 경우 - 모든 친구 관계를 다 살펴봐야 할지도 모름</li>
<li>너비 우선 탐색의 경우 - Sam과 가까운 관계부터 탐색</li>
</ul>
<h3 id="dfs-bfs-비교"> DFS, BFS 비교</h3>
<p><img src="https://velog.velcdn.com/images%2Flucky-korma%2Fpost%2Fe2ef7ac3-14e6-42e7-a768-224c5f773e29%2FR1280x0-3.gif" alt="image"></p>
<ul>
<li>DFS(깊이우선탐색) : 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색 -&gt; 스택 또는 재귀함수로 구현</li>
<li>BFS(너비우선탐색) : 현재 정점에서 연결된 가까운 점들부터 탐색 -&gt; 큐를 이용해서 구현</li>
</ul>
<h3 id="dfs-bfs의-시간복잡도"> DFS, BFS의 시간복잡도</h3>
<p>두 방식 모두 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일하다.<br>
DFS와 BFS 둘 다 다음 노드가 방문하였는지를 확인하는 시간과 각 노드를 방문하는 시간을 합하면 된다.</p>
<h3 id="깊이-우선-탐색과-너비-우선-탐색-활요한-문제-유형-응용"> 깊이 우선 탐색과 너비 우선 탐색 활요한 문제 유형/응용</h3>
<ul>
<li>그래프의 모든 정점을 방문하는 것이 주요한 문제<br>
: 단순히 모든 정점을 방문하는 것이 중요한 문제의 경우 두 가지 방법 중 어느 것을 사용해요 상관없다.</li>
<li>경로의 특징을 저장해둬야 하는 문제<br>
: 예를 들면 각 정점에 숫자가 적혀있고 a부터 b까지 경로를 구하는데 경로에 같은 숫자가 있으면 안된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 떄는 DFS를 사용한다.(BFS는 경로의 특징을 가지지 못한다)</li>
<li>최단거리를 구해야 하는 문제<br>
: 미로 찾기 등 최단거리를 구해야 하는 경우, BFS가 유리하다. 이유는 깊이 우선 탐색으로 경로를 검색할 경우 처음부터 발견되는 해답이 최단거리가 아닐 수 있지만, 너비 우선 탐색으로 현재 노드에서 가까운 곳부터 찾기 때문에 경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리이기 때문이다.</li>
<li>검색 대상 그래프가 정말 크다면 -&gt; DFS를 고려</li>
<li>검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS</li>
</ul>
<br>
<h2 id="_0412-passwordencoder"> 0412 - PasswordEncoder</h2>
<p>Spring Security에서는 비밀번호를 안전하게 저장할 수 있도록 비밀번호의 단방향 암호화를 지원하는 <code>PasswordEncoder</code> 인터페이스와 구현체들을 제공한다. 이 인터페이스는 아래와 같이 심플하게 구성되어 있다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>PasswordEncoder</span> <span>{</span>
	
　　<span>// 비밀번호를 단방향 암호화</span>
　　<span>String</span> <span>encode</span><span>(</span><span>CharSequence</span> rawPassword<span>)</span><span>;</span>
	
　　<span>// 암호화되지 않은 비밀번호(raw-)와 암호화된 비밀번호(encoded-)가 일치하는지 비교</span>
　　<span>boolean</span> <span>matches</span><span>(</span><span>CharSequence</span> rawPassword<span>,</span> <span>String</span> encodedPassword<span>)</span><span>;</span>
	
　　<span>// 암호화된 비밀번호를 다시 암호화하고자 할 경우 true를 return하게 설정</span>
　　<span>default</span> <span>boolean</span> <span>upgradeEncoding</span><span>(</span><span>String</span> encodedPassword<span>)</span> <span>{</span> <span>return</span> <span>false</span><span>;</span> <span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Spring Security 5.3.3에서 공식 지원하는 PasswordEncoder 구현 클래스들은 아래와 같다.</p>
<ul>
<li>BcryptPasswordEncoder : BCrypt 해시 함수를 사용해 비밀번호를 암호화</li>
<li>Argon2PasswordEncoder : Argon2 해시 함수를 사용해 비밀번호를 암호화</li>
<li>Pbkdf2PasswordEncoder : PBKDF2 해시 함수를 사용해 비밀번호를 암호화</li>
<li>SCryptPasswordEncoder : SCrypt 해시 함수를 사용해 비밀번호를 암호화</li>
</ul>
<p>위 4개의 PasswordEncoder는 Password를 encode할 때, 매번 임의의 salt를 생성해서 encode하게 되어 있다.</p>
<p>예를 들어 BCryptPasswordEncoder Class의 코드를 보면 다음과 같다.</p>
<div><pre><code><span>/*
* BCryptPasswordEncoder.encode() : 암호화
*/</span>
<span>public</span> <span>String</span> <span>encode</span><span>(</span><span>CharSequence</span> rawPassword<span>)</span> <span>{</span>

　　<span>if</span> <span>(</span>rawPassword <span>==</span> <span>null</span><span>)</span> <span>{</span>
　　　　<span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"rawPassword cannot be null"</span><span>)</span><span>;</span>
　　<span>}</span>
	
　　<span>String</span> salt<span>;</span>
　　
   <span>if</span> <span>(</span>random <span>!=</span> <span>null</span><span>)</span> <span>{</span>
   　　salt <span>=</span> <span>BCrypt</span><span>.</span><span>gensalt</span><span>(</span>version<span>.</span><span>getVersion</span><span>(</span><span>)</span><span>,</span> strength<span>,</span> random<span>)</span><span>;</span>
   <span>}</span> <span>else</span> <span>{</span>
   　　salt <span>=</span> <span>BCrypt</span><span>.</span><span>gensalt</span><span>(</span>version<span>.</span><span>getVersion</span><span>(</span><span>)</span><span>,</span> strength<span>)</span><span>;</span>
   <span>}</span>
   <span>return</span> <span>BCrypt</span><span>.</span><span>hashpw</span><span>(</span>rawPassword<span>.</span><span>toString</span><span>(</span><span>)</span><span>,</span> salt<span>)</span><span>;</span>
<span>}</span>

<span>/**
* BCrypt.gensalt() : Salt 생성
*/</span>
<span>public</span> <span>static</span> <span>String</span> <span>gensalt</span><span>(</span><span>String</span> prefix<span>,</span> <span>int</span> log_rounds<span>,</span> <span>SecureRandom</span> random<span>)</span> <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>

　<span>StringBuilder</span> rs <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
　<span>byte</span> rnd<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>byte</span><span>[</span>BCRYPT_SALT_LEN<span>]</span><span>;</span> <span>// 16byte(128bit) 크기의 Salt 생성</span>

  <span>if</span> <span>(</span><span>!</span>prefix<span>.</span><span>startsWith</span><span>(</span><span>"$2"</span><span>)</span> <span>||</span> <span>(</span>prefix<span>.</span><span>charAt</span><span>(</span><span>2</span><span>)</span> <span>!=</span> <span>'a'</span> <span>&amp;&amp;</span> prefix<span>.</span><span>charAt</span><span>(</span><span>2</span><span>)</span> <span>!=</span> <span>'y'</span> <span>&amp;&amp;</span> prefix<span>.</span><span>charAt</span><span>(</span><span>2</span><span>)</span> <span>!=</span> <span>'b'</span><span>)</span><span>)</span> <span>{</span>
      <span>throw</span> <span>new</span> <span>IllegalArgumentException</span> <span>(</span><span>"Invalid prefix"</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>if</span> <span>(</span>log_rounds <span>&lt;</span> <span>4</span> <span>||</span> log_rounds <span>></span> <span>31</span><span>)</span> <span>{</span>
      <span>throw</span> <span>new</span> <span>IllegalArgumentException</span> <span>(</span><span>"Invalid log_rounds"</span><span>)</span><span>;</span>
  <span>}</span>

　random<span>.</span><span>nextBytes</span><span>(</span>rnd<span>)</span><span>;</span>

　rs<span>.</span><span>append</span><span>(</span><span>"$2"</span><span>)</span><span>;</span>
　rs<span>.</span><span>append</span><span>(</span>prefix<span>.</span><span>charAt</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>
　rs<span>.</span><span>append</span><span>(</span><span>"$"</span><span>)</span><span>;</span>
　<span>if</span> <span>(</span>log_rounds <span>&lt;</span> <span>10</span><span>)</span>
      rs<span>.</span><span>append</span><span>(</span><span>"0"</span><span>)</span><span>;</span>
  
  rs<span>.</span><span>append</span><span>(</span>log_rounds<span>)</span><span>;</span>
  rs<span>.</span><span>append</span><span>(</span><span>"$"</span><span>)</span><span>;</span>
  <span>encode_base64</span><span>(</span>rnd<span>,</span> rnd<span>.</span>length<span>,</span> rs<span>)</span><span>;</span>

  <span>return</span> rs<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><h3 id="bcryptpasswordencoder"> BCryptPasswordEncoder</h3>
<p>BCrypt 해시 함수를 사용해 비밀번호를 해시하는 PasswordEncoder이다. Bruteforce attack이나 Rainbow table attack과 같은 Password Cracking에 대한 저항력을 높이기 위해 의도적으로 느리게 설정되어 있다.</p>
<blockquote>
<p>전문 장비를 이용하면 한 계정에 대한 비밀번호 입력을 1초에 수억번 이상으로 시도할 수 있다. 따라서 이런 유형의 공격을 어렵게 만들기 위해 1개의 암호를 확인하는데 약 1초 정도의 시간이 걸리도록 하는 것을 권장한다. 각 시스템별로 성능 차이가 있기 때문에 PasswordEncoder가 암호를 해독하는데 걸리는 시간은 달라질 수 있다. 따라서 시스템에 맞게 테스트하면서 속도를 조정해줘야 한다.</p>
</blockquote>
<p>BCryptPasswordEncoder의 속도는 강도(strength)를 조정해서 조절할 수 있다. 강도는 4~31까지 설정할 수 있으며, BcryptPasswordEncoder는 default 강도로 아래와 같이 10을 사용한다.</p>
<div><pre><code><span>public</span> <span>BCryptPasswordEncoder</span><span>(</span><span>BCryptVersion</span> version<span>,</span> <span>int</span> strength<span>,</span> <span>SecureRandom</span> random<span>)</span> <span>{</span>
  
  <span>if</span> <span>(</span>strength <span>!=</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> <span>(</span>strength <span>&lt;</span> <span>BCrypt</span><span>.</span>MIN_LOG_ROUNDS <span>||</span> strength <span>></span> <span>BCrypt</span><span>.</span>MAX_LOG_ROUNDS<span>)</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Bad strength"</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>this</span><span>.</span>version <span>=</span> version<span>;</span>
  <span>this</span><span>.</span>strength <span>=</span> strength <span>==</span> <span>-</span><span>1</span> <span>?</span> <span>10</span> <span>:</span> strength<span>;</span> <span>// 지정하지 않으면 강도를 10으로 설정</span>
  <span>this</span><span>.</span>random <span>=</span> random<span>;</span>
<span>}</span>

<span>// 강도설정</span>
<span>// Create an encoder with strength 16</span>
<span>BCryptPasswordEncoder</span> encoder <span>=</span> <span>new</span> <span>BCryptPasswordEncoder</span><span>(</span><span>16</span><span>)</span><span>;</span>
<span>String</span> result <span>=</span> encoder<span>.</span><span>encode</span><span>(</span><span>"myPassword"</span><span>)</span><span>;</span>
<span>assertTrue</span><span>(</span>encoder<span>.</span><span>matches</span><span>(</span><span>"myPassword"</span><span>,</span> result<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="argon2passwordencoder"> Argon2PasswordEncoder</h3>
<p>Argon2 해시 함수를 사용해 비밀번호를 해시하는 PasswordEncoder이다. Argon2는 Paasword Hasing Competition의 우승자로 Password Craking을 방지하기 위해 다른 PasswordEncoder와 마찬가지로 의도적으로 느리게 실행되도록 설정되어 있다.</p>
<div><pre><code><span>// Create an encoder with all the defaults</span>
<span>Argon2PasswordEncoder</span> encoder <span>=</span> <span>new</span> <span>Argon2PasswordEncoder</span><span>(</span><span>)</span><span>;</span>
<span>String</span> result <span>=</span> encoder<span>.</span><span>encode</span><span>(</span><span>"myPassword"</span><span>)</span><span>;</span>
<span>assertTrue</span><span>(</span>encoder<span>.</span><span>matches</span><span>(</span><span>"myPassword"</span><span>,</span> result<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="pbkdf2passwordencoder"> Pbkdf2PasswordEncoder</h3>
<p>PBKDF2 해시 함수를 사용해 비밀번호를 해시하는 PasswordEncoder이다. FIPS 인증(Federal Information Processing Standards, 미 연방 시스템 내에서 중요한 데이터를 보호하기 위한 필요 표준)이 필요한 경우 이 PasswordEncoder를 선택하는것이 좋다.</p>
<div><pre><code><span>// Create an encoder with all the defaults</span>
<span>Pbkdf2PasswordEncoder</span> encoder <span>=</span> <span>new</span> <span>Pbkdf2PasswordEncoder</span><span>(</span><span>)</span><span>;</span>
<span>String</span> result <span>=</span> encoder<span>.</span><span>encode</span><span>(</span><span>"myPassword"</span><span>)</span><span>;</span>
<span>assertTrue</span><span>(</span>encoder<span>.</span><span>matches</span><span>(</span><span>"myPassword"</span><span>,</span> result<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="scryptpasswordencoder"> SCryptPasswordEncoder</h3>
<p>SCrypt 해시 함수를 사용해 비밀번호를 해시하는 PasswordEncoder이다.</p>
<div><pre><code><span>SCryptPasswordEncoder</span> encoder <span>=</span> <span>new</span> <span>SCryptPasswordEncoder</span><span>(</span><span>)</span><span>;</span>
<span>String</span> result <span>=</span> encoder<span>.</span><span>encode</span><span>(</span><span>"myPassword"</span><span>)</span><span>;</span>
<span>assertTrue</span><span>(</span>encoder<span>.</span><span>matches</span><span>(</span><span>"myPassword"</span><span>,</span> result<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><br>
<h2 id="_0414-stringutils를-사용하는-이유"> 0414 - StringUtils를 사용하는 이유</h2>
<p><code>.split()</code> <code>.toCharArray()</code> <code>equals()</code> 등 String 메소드를 사용할 때 바로 호출하는 것보다 StringUtils 라이브러리를 활용하는 것을 권장한다.</p>
<div><pre><code><span>String</span> arr<span>[</span><span>]</span><span>,</span> str <span>=</span> <span>"hello-world"</span><span>;</span> 

arr <span>=</span> <span>"hello-world"</span><span>.</span><span>split</span><span>(</span><span>"-"</span><span>)</span><span>;</span> <span>// (X) warning</span>
arr <span>=</span> str<span>.</span><span>split</span><span>(</span><span>"-"</span><span>)</span><span>;</span> <span>// (X) warning</span>

arr <span>=</span> <span>StringUtils</span><span>.</span><span>(</span><span>"hello-world"</span><span>,</span> <span>"-"</span><span>)</span><span>;</span> <span>// (O) null-safe</span>
arr <span>=</span> <span>StringUtils</span><span>.</span><span>(</span>str<span>,</span> <span>"-"</span><span>)</span><span>;</span> <span>// (O) null-safe</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="stringutils-라이브러리는-null-safe하다"> StringUtils 라이브러리는 Null-Safe하다.</h4>
<p>String 클래스의 경우 str1.equals(str2); 에서 str1이 null이면 NullPointerException 예외가 발생하지만, StringUtils 클래스의 경우 StringUtils.equals(str1,str2) 에서 st1이 null 이어도 예외가 발생하지 않고 null을 반환한다.</p>
<ul>
<li>컬렉션인 경우
CollectionUtils.isEmpty() 또는 CollectionUtils.isNotEmpty()을 사용한다.</li>
</ul>
<br>
<h2 id="_0415-converter"> 0415 - @Converter</h2>
<p>@Converter를 사용하면 엔티티의 데이터를 변환해서 데이터베이스에 저장할 수 있다.</p>
<h3 id="converter-사용법"> Converter 사용법</h3>
<div><pre><code><span>@Entity</span>
<span>class</span> <span>Member</span><span>{</span>
    <span>@Id</span> <span>@GeneratedValue</span>
    <span>private</span> <span>Integer</span> id<span>;</span>

    <span>@Convert</span><span>(</span>converter<span>=</span><span>BooleanToYNConverter</span><span>.</span><span>class</span><span>)</span>
    <span>private</span> <span>boolean</span> useYn<span>;</span>
<span>}</span>

<span>@Converter</span>
<span>class</span> <span>BooleanToYNConverter</span> <span>implements</span> <span>AttributeConverter</span><span><span>&lt;</span><span>Boolean</span><span>,</span> <span>String</span><span>></span></span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>String</span> <span>convertToDatabaseColumn</span><span>(</span><span>Boolean</span> attribute<span>)</span><span>{</span>
        <span>return</span> <span>(</span>attribute <span>!=</span> <span>null</span> <span>&amp;&amp;</span> attribute<span>)</span> <span>?</span> <span>"Y"</span> <span>:</span> <span>"N"</span><span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>Boolean</span> <span>convertToEntityAttribute</span><span>(</span><span>String</span> dbData<span>)</span><span>{</span>
        <span>return</span> <span>"Y"</span><span>.</span><span>eqauls</span><span>(</span>dbData<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ul>
<li>AttributeConverter&lt;엔티티컬럼타입, 데이터베이스 컬럼 타입&gt;</li>
</ul>
<h4 id="클래스-레벨-설정"> 클래스 레벨 설정</h4>
<div><pre><code><span>@Entity</span>
<span>@Converter</span><span>(</span>converter <span>=</span> <span>BooleanToYNConverter</span><span>.</span><span>class</span><span>,</span> attributeName <span>=</span> <span>"useYn"</span><span>)</span>
<span>class</span> <span>Member</span><span>{</span>
    <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="글로벌-설정"> 글로벌 설정</h4>
<div><pre><code><span>@Converter</span><span>(</span>autoApply <span>=</span> <span>true</span><span>)</span>
<span>class</span> <span>BooleanToYNConverter</span> <span>implements</span> <span>AttributeConverter</span><span><span>&lt;</span><span>Boolean</span><span>,</span> <span>String</span><span>></span></span><span>{</span>
    <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>모든 Boolean 타입에 설정</li>
</ul>
<br>
<h2 id="_0417-ecs-fagate"> 0417 - ECS, Fagate</h2>
<h3 id="amazon-ecs-elastic-container-service-fks"> Amazon ECS(Elastic Container Service)fks?</h3>
<ul>
<li>클러스터에서 컨테이너를 쉽게 실행, 중지 및 관리할 수 있게 해주는 컨테이너 관리 서비스.</li>
<li>간단한 API 호출을 사용하여 컨테이너 기반 애플리케이션을 시작하고 중지할 수 있다.</li>
</ul>
<h3 id="aws-fargate란"> AWS Fargate란</h3>
<ul>
<li>
<p>별도로 인스턴스를 생성 관리하지 않고, 완전한 매니지드 서비스의 형태로 도커 컨테이너를 실행시킬 수 있는 아마존의 서버리스 컨테이너 상품. Docker 이미지가 리포지토리에 푸시되어 있다면, 클라스터 -&gt; 작업 정의 -&gt; 서비스의 순서로 생성하여 완전히 24시간 서비스 가능한 애플리케이션을 기동할 수 있다.</p>
</li>
<li>
<p>fagate를 사용하려면 상위 개념에서 특정 오케으스레이션 상품을 선택해야한다. 현재 Amazon ECS, Amazon EKS에서 지원, 사용가능하다.</p>
</li>
</ul>
<p>사용법은 추후에 자세이 공부</p>
]]></content:encoded>
      <enclosure url="https://velog.velcdn.com/images%2Flucky-korma%2Fpost%2F30737a15-9adf-49a6-96a0-98c211cab1cc%2FR1280x0.gif" type="image/gif"/>
    </item>
    <item>
      <title>0425 ~ 0501</title>
      <link>ahnjs/TIL/2022/0425/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0425/</guid>
      <source url="ahnjs/TIL/rss.xml">0425 ~ 0501</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0425-0501"> 0425 ~ 0501</h1>
<h2 id="_0425-given-when-then-pattern"> 0425 - Given-When-Then Pattern</h2>
<h3 id="given-when-then-pattern"> Given-When-Then Pattern?</h3>
<p><code>Given-When-Then Pattern</code>은 BDD(Behaviour-Driven Development) 중 하나로, Test Code 스타일을 표현하는 하나의 방식이라고 볼 수 있다.</p>
<h4 id="given-테스트-전의-상태"> Given (테스트 전의 상태)</h4>
<ul>
<li>테스트에서 구체화하고자 하는 행동을 시작하기 전에 테스트 상태를 설명하는 부분</li>
<li>즉, 시나리오 진행에 필요한 값을 설정하고 테스트의 상태를 설정한다</li>
</ul>
<h4 id="when-테스트-행위"> When (테스트 행위)</h4>
<ul>
<li>구체화하고자 하는 행동</li>
<li>즉, 시나리오 진행 필요 조건 명시, 테스트하고자 하는 행동을 명시한다</li>
</ul>
<h4 id="then-테스트-검증"> Then (테스트 검증)</h4>
<ul>
<li>특정 행동으로 인해 발생할 것으로 예상되는 변화에 대해 설명하는 부분</li>
<li>즉, 시나리오를 완료했을 때 보장해야 하는 결과를 명시하고 예상되는 변화를 설명한다</li>
</ul>
<div><pre><code><span>@Test</span>
<span>void</span> <span>hasSkill_AlwaysTrue</span><span>(</span><span>)</span> <span>{</span>
    <span>// given</span>
    <span>given</span><span>(</span>skills<span>.</span><span>hasSkill</span><span>(</span><span>)</span><span>)</span><span>.</span><span>willReturn</span><span>(</span><span>true</span><span>)</span><span>;</span>

    <span>// when</span>
    <span>boolean</span> actual <span>=</span> person<span>.</span><span>hasSkill</span><span>(</span><span>)</span><span>;</span>

    <span>// then</span>
    <span>assertThat</span><span>(</span>actual<span>)</span><span>.</span><span>isTrue</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><br>
<h2 id="_0426-modifying"> 0426 - @Modifying</h2>
<h3 id="query이란"> @Query이란</h3>
<p>Spring Data JPA에서는 기본적으로 JpaRepository의 기본 메서드와, 메서드 네이밍만을 통해서 쿼리를 실행할 수 있도록 기능을 제공한다. 하지만, 쿼리를 직접 작성하여 사용하고 싶을땐 @Query annotation을 사용한다. JPQL 및 nativeQuery=true 옵션으로 네이티브 쿼리도 사용 가능하다.</p>
<h3 id="modifying이란"> @Modifying이란</h3>
<p>@Query Annotation으로 작성 된 변경, 삭제 쿼리 메서드를 사용할때 필요하다. 즉, 조회 쿼리를 제외하고, 데이터 변경이 일어나는 INSERT, UPDATE, DELETE, DDL에서 사용한다. 주로 벌크 연산시에 사용된다.<br>
JPA Entity LifeCycle을 무시하고 쿼리가 실행되기 때문에 해당 annotation을 사용할 때는 영속성 콘텍스트 관리에 주의해야 한다. 앞으로 설명할 clearAutomatically, flushAutomatically를 통해 간단하게 해결할 수 있다.</p>
<h3 id="벌크연산이란"> 벌크연산이란</h3>
<p>벌크 연산이란 단건 UPDATE, DELETE를 제외한 다건의 UPDATE, DELETE 연산을 하나의 쿼리로 처리하는 것을 의미한다. JPA에서 단건 UPDATE 같은 경우에는 Dirty Checking을 통해서 수행되거나 save()로도 가능하다. DELETE의 경우에는 다건, 단건 모두 쿼리 메서드로 제공된다.<br>
@Query에 벌크 연산 쿼리를 작성하고, @Modifying을 붙이지 않으면, InvalidDataAccessApiUsage exception이 발생한다.</p>
<h3 id="clearautomatically"> clearAutomatically</h3>
<p>이 Attribute는 @Modifying이 붙은 해당 쿼리 메서드 실행 직 후, 영속성 컨텍스트를 clear 할 것인지를 지정하는 Attribute이다. defalut 값은 false다. true시 벌크 연산 직 후 자동으로 영속성 컨텍스트를 클리어 해준다.</p>
<br>
<h2 id="_0429-jpa-osiv"> 0429 - JPA - OSIV</h2>
<h3 id="osiv-open-sessio-in-view"> OSIV(Open Sessio In View)</h3>
<p>OSIV는 영속성 컨텍스트를 뷰까지 열어두는 기능이다. 영속성 컨텍스트가 유지되면 엔티티도 영속 상태로 유지된다. 뷰까지 영속성 컨텍스트가 살아있다면 뷰에서도 지연 로딩을 사용할 수가 있다.</p>
<blockquote>
<p>JPA에서는 OEIV(Open EntityManage In View), 하이버네이트에선 OSIV(Open Session In View)라고 한다. 하지만 관례상 둘 다 OSIV로 부른다.</p>
</blockquote>
<h3 id="osiv-동작-원리"> OSIV 동작 원리</h3>
<p>OSIV의 동작 방식에 대해서 Spring Framework가 제공하는 OSIV를 통해 보면, 스프링이 제공하는 OSIV 클래스는 서블릿 필터에서 적용할지 스프링 인터셉터에서 적용할지에 따라 원하는 클래스를 선택해서 사용하면 된다.</p>
<ul>
<li>JPA OEIV 서블릿 필터: <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewFilter.html" target="_blank" rel="noopener noreferrer">org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter<i>Content not supported</i></a></li>
<li>JPA OEIV 스프링 인터셉터: <a href="https://docs.spring.io/spring-framework/docs/5.3.3/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html" target="_blank" rel="noopener noreferrer">org.springframework.orm.jpa.support.OpenEntityManagerInViewInterceptor<i>Content not supported</i></a></li>
</ul>
<p>스프링 프레임워크가 제공하는 OSIV는 비지니스 계층에서 트랜잭션을 사용하는 OSIV다. 영속성 컨텍스트는 사용자의 요청 시점에서 생성이 되지만, 데이터를 쓰거나 수정할 수 있는 트랜잭션은 비즈니스 계층에서만 사용할 수 있도록 트랜잭션이 일어난다.</p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbd835C%2FbtqTPzbjhqa%2FAPhn7gWwr4pRhzCL79N4q1%2Fimg.png" alt="image"></p>
<ul>
<li>spring.jpa.open-in-view : true 기본값</li>
</ul>
<p>Spring Boot JPA의존성을 주입 받아 어플리케이션을 구성할 경우
spring.jpa.open-in-view의 기본값인 true로 지정되어 있어 OSIV가 적용된 상태로 어플리케이션이 구성된다.</p>
<p>동작원리는 다음과 같다.</p>
<ul>
<li>클라이언트의 요청이 들어오면 서블릿 필터나, 스프링인터셉터에서 영속성 컨텍스트를 생성한다. 단 이 시점에서 트랜잭션은 시작하지 않는다.</li>
<li>서비스 계층에서 @Transactional로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.</li>
<li>서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이 시점에 트랜잭션은 끝내지만 영속성 컨텍스트는 종료되지 않는다.</li>
<li>컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.</li>
<li>서블릿 필터나, 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때 플러시를 호출하지 않고 바로 종료한다.</li>
</ul>
<p>서비스 계층에서 트랜잭션이 끝나면 컨트롤러와 뷰에는 트랜잭션이 유지되지 않는 상태이다. 엔티티를 변경하지 않고 단순히 조회만 할 때는 트랜잭션이 없어도 동작하는데, 이것을 트랜잭션 없이 읽기(Nontransactional reads)라 한다. 하여 만약 프록시를 뷰 렌더링하는 과정에 초기화(Lazy loading)가 일어나게 되어도 조회 기능이므로 트랜잭션이 없이 읽기가 가능하다.</p>
<ul>
<li>영속성 컨텍스트는 기본적으로 트랜잭션 범위 안에서 엔티티를 조회하고 수정할 수 있다.</li>
<li>영속성 컨텍스트는 트랜잭션 범위 밖에서 엔티티를 조회만 할 수 있다. 이것을 트랜잭션 없이 읽기(Nontransactional reads)라 한다.</li>
</ul>
<p>만약 트랜잭션 범위 밖인 컨트롤러와 뷰에서 엔티티를 수정하여도 영속성 컨텍스트의 변경 감지에 의한 데이터 수정이 다음 2가지 이유로 동작하지 않는다.</p>
<ul>
<li>영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하려면 영속성 컨텍스트를 플러시(flush)해야 한다. 스프링이 제공하는 OSIV는 요청이 끝나면 플러시를 호출하지 않고 em.close()로 영속성 컨텍스트만 종료시켜 버린다.</li>
<li>프레젠테이션 계층에서 em.flush()를 호출하여 강제로 플러시해도 트랜잭션 범위 밖이므로 데이터를 수정할 수 없다는 예외가 일어난다. (javax.persistence.TransactionRequiredException)</li>
</ul>
<h3 id="osiv-사용시-주의점"> OSIV 사용시 주의점</h3>
<div><pre><code>2021-01-18 21:54:44.750 WARN 36808 --- [ restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
</code></pre>
<div><span>1</span><br></div></div><p>spring.jpa.open-in-view의 값을 기본값(true)으로 어플리케이션을 구동하면, 어플리케이션 시작 시점에 위와 같은 warn 로그를 남기게 된다.<br>
그런데 위 동작 방식처럼 프록시를 초기화하는 작업을 Service 계층에서 끝내지 않고도 렌더링 시 자동으로 해결하게 해주는 장점이 있는 OSIV전략에 왜 경고를 줄까?</p>
<p>OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점에서 API 응답이 끝날 때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지한다. 그래서 View Template이나 API 컨트롤러에서 지연 로딩이 가능하다.<br>
지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지한다. 이것 자체가 큰 장점이다.</p>
<p>그런데 이전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있다. 이것은 결국 장애로 이어진다.<br>
예를 들어서 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간 만큼 커넥션 리소스를 반환하지 못하고, 유지해야 한다. -&gt; OISV의 치명적인 단점, 커넥션을 영속성 컨텍스트가 종료될 때까지 1:1로 계속 물고 있다.</p>
<p>[ OSIV OFF ]
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FemsRZ9%2FbtqTLyKOQQ7%2F5cKM4Ma00A7LYKwhde77Zk%2Fimg.png" alt="image"></p>
<ul>
<li>spring.jpa.open-in-view: false (OSIV 종료)</li>
</ul>
<p>OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다. 따라서 커넥션 리소스를 낭비하지 않는다. OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 한다. 따라서 지금까지 작성한 많은 지연 로딩 코드를 트랜잭션안으로 넣어야 하는 단점이 있다. 그리고 view template에서 지연로딩이 동작하지 않는다. 결론적으로 트랜잭션이 끝나기 전에 지연 로딩을 강제로 호출해 두어야 한다.</p>
<h4 id="커맨드와-쿼리-분리"> 커맨드와 쿼리 분리</h4>
<p>실무에서 OSIV를 끈 상태로 복잡성을 관리하는 종은 방법이 있다. 바로 Command와 Query를 분리하는 것이다.</p>
<p>보통 비즈니스 로직은 특정 엔티티 몇 개를 등록하거나 수정하는 것이므로 성능이 크게 문제가 되지 않는다. 그런데 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화 하는 것이 중요하다. 하지만 그 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 아니다.<br>
그래서 크고 복잡한 애플리케이션을 개발한다면, 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 충분히 의미 있다.</p>
<p>예)<br>
OrderService</p>
<ul>
<li>OrderService : 핵심 비즈니스 로직</li>
<li>OrderQueryService : 화면이나 API에 맞춘 서비스 (주로 읽기 전용 트랜잭션 사용)</li>
</ul>
<p>보통 서비스 계층에서 트랜잭션을 유지한다. 두 서비스 모두 트랜잭션을 유지하면서 지연 로딩을 사용할 수 있다.</p>
<h3 id="osiv-정리"> OSIV 정리</h3>
<p>특징</p>
<ul>
<li>OSIV는 클라이언트 요청이 들어올 때 영속성 컨텍스트를 생성해서 요청이 끝날 때까지 같은 영속성 컨텍스트를 유지한다. 하여 한 번 조회된 엔티티는 요청이 끝날 때까지 영속 상태를 유지한다.</li>
<li>엔티티 수정은 트랜잭션이 있는 계층에서만 동작한다. 트랜잭션이 없는 프레젠테이션 계층은 지연 로딩을 포함해 조회만 할 수 있다.</li>
</ul>
<p>단점</p>
<ul>
<li>영속성 컨텍스트와 DB 커넥션은 1:1로 물고있는 관계이기 때문에 프레젠테이션 로직까지 DB 커넥션 자원을 낭비하게 됨.</li>
<li>OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유하게될 수도 있다.</li>
<li>프레젠테이션에서 엔티티를 수정하고 비즈니스 로직을 수행하면 엔티티가 수정될 수 있다.</li>
<li>프레젠테이션 계층에서 렌더링 과정에서 지연 로딩에 의해 SQL이 실행된다. 따라서 성능 튜닝시에 확인해야 할 부분이 넓어진다.</li>
</ul>
<br>
<h2 id="_0430-dau-pu-pv"> 0430 - DAU, PU, PV</h2>
<h3 id="dau-wau-mau"> DAU / WAU / MAU</h3>
<p>1일, 1주, 1달 동안 활성 사용자(Active User)의 수를 의미</p>
<h4 id="dau-daily"> DAU (Daily)</h4>
<ul>
<li>하루 동안 방문한 순수 사용자 수를 집계</li>
<li>게임, 메신저 등 사용빈도가 높은 앱의 주요 지표로 활용됨</li>
<li>서버 부하를 비롯한 트래픽 관련 변동비 추정 및 최적화와 연관이 깊음</li>
</ul>
<h4 id="wau-weekly-active-user"> WAU (Weekly Active User)</h4>
<ul>
<li>일주일(7일) 동안 방문한 순수 사용자 수를 집계</li>
<li>매일 접속할 필요 없는 모바일 은행과 같은 앱에서 주로 활용되는 지표</li>
</ul>
<h4 id="mau-monthly-active-user"> MAU (Monthly Active User)</h4>
<ul>
<li>월 간(30일) 방문한 순수 사용자 수를 집계</li>
<li>수치가 크기 때문에 비즈니스를 설명하는 데에 주로 인용됨</li>
<li>하지만 실제적인 유저의 활성화 정도를 파악하기 어려운 단점이 있음</li>
</ul>
<h3 id="pu-arpu-arppu"> PU / ARPU / ARPPU</h3>
<h4 id="pu-paying-users"> PU (Paying Users)</h4>
<ul>
<li>유료 유저 수 (결제한 유저 수)</li>
</ul>
<h4 id="arpu-average-revenue-per-users"> ARPU (Average Revenue Per Users)</h4>
<ul>
<li>유저별 평균 매출</li>
<li>ARPU = 총매출/총 유저수</li>
<li>쉽게 말해 '객단가', 한 명의 유저가 평균 얼마를 지출했는지 알 수 있는 지표</li>
</ul>
<h4 id="arppu-average-revenue-per-paying-users"> ARPPU (Average Revenue Per Paying Users)</h4>
<ul>
<li>유료 유저별 평균 매출</li>
<li>ARPPU = 총매출/총 유료 서비스 구매 유저</li>
<li>쉽게 말해 '결제자 객단가', 한 명의 유로 유저가 평균 얼마를 지출했는지 알 수 있는 지표</li>
</ul>
<h3 id="entrance-pv-uv"> Entrance, PV, UV</h3>
<h4 id="entrance-방문-수"> Entrance (방문 수)</h4>
<ul>
<li>웹 사이트 방문에서 이탈까지 수행하는 통합 단위</li>
</ul>
<h4 id="pv-page-view"> PV (Page View)</h4>
<ul>
<li>사이트 안에서 페이지를 조회한 횟수</li>
</ul>
<p>ex) 1명이 블로그 글 2개를 읽는다면?<br>
= PV는 2로 집계</p>
<h4 id="uv-unique-visitors"> UV (Unique Visitors)</h4>
<ul>
<li>순방문자. 최초 세션을 일으킨 방문자</li>
<li>웹페이지에 방문한 사람의 수 의미</li>
<li>일반적으로 IP를 기준으로, 30분 단위로 쪼개서 계산</li>
</ul>
<p>ex) 1명이 블로그 글을 여러번 본다면?<br>
= UV는 1로 집계</p>
<p>ex) 1명이 블로그 글을 읽고, 30분 뒤에 한 번 더 본다면?<br>
= UV는 2로 집계</p>
<br>
<h2 id="_0501-spring-bean-vs-static-method-언제-어느걸-사용해야할까"> 0501 - Spring Bean vs Static method 언제 어느걸 사용해야할까?</h2>
<p>먼저 여기서 말하는 static 함수 모음 class란 <a href="https://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html" target="_blank" rel="noopener noreferrer">Apache Commons Lang StringUtils<i>Content not supported</i></a>처럼 순전히 static 함수만을 가지고 있고, 객체를 생성하지 않고 사용하는 클래스를 의미한다.</p>
<blockquote>
<p>static 함수 모음 클래스의 모든 함수는 인자가 동일할 경우 항상 동일한 결과를 리턴해야 한다. 이규칙을 지킬 수 없으면 POJO Bean으로 만들라.</p>
</blockquote>
<blockquote>
<p>이것이 이뤄지려면 함수 안에서는 외부 자원(Resource)에 대해 하나도 의존하면 안된다는 선결 조건을 충족해야 한다. 외부 자원은 그 실행 결과의 일관성을 보장할 수 없기 때문이다.</p>
</blockquote>
<p>이에 가장 잘 들어맞는 예는 <a href="https://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html" target="_blank" rel="noopener noreferrer">StringUtils<i>Content not supported</i></a>, <a href="https://commons.apache.org/proper/commons-collections/apidocs/org/apache/commons/collections4/CollectionUtils.html" target="_blank" rel="noopener noreferrer">CollectionUtils<i>Content not supported</i></a> 같은 것들이다.</p>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbd835C%2FbtqTPzbjhqa%2FAPhn7gWwr4pRhzCL79N4q1%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0502 ~ 0515</title>
      <link>ahnjs/TIL/2022/0502/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0502/</guid>
      <source url="ahnjs/TIL/rss.xml">0502 ~ 0515</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0502-0515"> 0502 ~ 0515</h1>
<h2 id="_0502-fetch-join-vs-join"> 0502 - fetch join vs join</h2>
<h3 id="일반-join"> 일반 Join</h3>
<ul>
<li>Fetch Join과 달리 연관 Entity에 Join을 걸어도 실제 쿼리에서 SELECT 하는 Entity는 오직 JPQL에서 조회하는 주체가 되는 Entity만 조회하여 영속화.</li>
<li>조회의 주체가 되는 Entity만 SELECT해서 영속화하기 때문에 데이터는 필요하지 않지만 연관 Entity가 검색조건에는 필요한 경우에 주로 사용된다.</li>
</ul>
<h3 id="fetch-join"> Fetch Join</h3>
<ul>
<li>조회의 주체가 되는 Entity 이외에 Fetch Join이 걸린 연관 Entity도 함께 SELECT하여 모두 영속화.</li>
<li>Fetch Join이 걸린 Entity 모두 영속화하기 때문에 FetchType이 Lazy인 Entity를 참조하더라도 이미 영속성 컨텍스트에 들어있기 때문에 따로 쿼리가 실행되지 않은 채로 N+1문제가 해결된다.</li>
</ul>
<br>
<h2 id="_0503-oatuh관련"> 0503 - OAtuh관련</h2>
<p>OAuth는 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여 할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다.
쉽게말해, 자신이 소유한 리소스에 소프트웨어 애플리케이션이 접근할 수 있도록 허용해 줌으로써 접근 권한을 위임해주는 개방형 표준 프로토콜</p>
<p>용어</p>
<ul>
<li>Resource Server : OAuth2.0 서비스를 제공하고 자원을 관리하는 서버</li>
<li>Resource Owner : Resource Server의 계정을 소유하고 있는 사용자</li>
<li>Client : Resource Server의 API를 사용하여 데이터를 가져오려고 하는 사이트</li>
<li>Authorization Server : Client가 Resource Server의 서비스를 사용할 수 있게 인증하고 토큰을 발생해주는 서버</li>
<li>Access Token : 자원 서버에 자원을 요청할 수 있는 토큰</li>
<li>Refresh Token : 권한 서버에 접근 토큰을 요청할 수 있는 토큰</li>
</ul>
<blockquote>
<p>OAuth Bearer token과 JWT토큰의 차이<br>
OAuth Token은 어떤 사용자의 정보와 같은 중요한 정보가 있는 토큰은 아니며, 리로스 서버에서 정보를 요청할 용도로 사용. JWT는 payload에 명확한 정보를 가지고 있으며 헤더, 내용, 서명 구조를 가지고 있다.</p>
</blockquote>
<br>
<h2 id="_0504-generatedvalue-전략"> 0504 - @GeneratedValue 전략</h2>
<p>기본키를 자동으로 생성하기 위해 사용</p>
<h3 id="identity"> IDENTITY</h3>
<div><pre><code><span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>IDENTITY<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>기본키 생성을 데이터 베이스에게 위임하는 방식으로 id값을 따로 할당하지 않아도 데이터베이스가 자동으로 AUTO_INCREMENT를 하여 기본키를 생성해준다.</li>
</ul>
<blockquote>
<p>JPA는 보통 영속성 컨텍스트에서 객체를 관리하다가 commit이 호출되는 시점에 쿼리문을 실행하게된다. 하지만 IDENTITY 전략에서는 EntityManager.persist()를 하는 시점에 Insert SQL을 실행하여 데이터베이스에서 식별자를 조회해온다.<br>
그 이유는 영속성 컨텍스트는 1차 캐시에 PK와 객체를 가지고 관리를 하는데 기본키를 데이터베이스에게 위임했기 때문에  EntityManage.persist() 호출 하더라도 데이터베이스에 값을 넣기전까지 기본키를 모르고 있기 때문에 관리가 되지 않기 때문이다.<br>
따라서 특별한 경우로 IDENTITY 전략에서는 EntityManage.persist()를 하는 시점에 Insert SQL을 실행하여 데이터베이스에서 식별자를 조회하여 영속성 컨텍스트 1차 캐시에 값을 넣어주기 때문에 관리가 가능해진다.</p>
</blockquote>
<h3 id="sequence"> SEQUENCE</h3>
<div><pre><code><span>@Entity</span>
<span>@SequenceGenerator</span><span>(</span>
    name <span>=</span> <span>"USER_PK_GENERATOR"</span><span>,</span>
    sequenceName <span>=</span> <span>"USER_PK_SEQ"</span><span>,</span>
    initailValue <span>=</span> <span>1</span><span>,</span>
    allocationSize <span>=</span> <span>50</span>
<span>)</span>
<span>public</span> <span>class</span> <span>PkEx</span><span>(</span><span>)</span> <span>{</span>
    
        <span>@Id</span>
        <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>SEQUENCE<span>,</span>
                    generator<span>=</span><span>"USER_PK_GENERATOR"</span><span>)</span>
        <span>private</span> <span>Long</span> id<span>;</span>
    
        <span>private</span> <span>String</span> name<span>;</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>데이터 베이스의 Sequence Object를 사용하여 데이터베이스가 자동으로 기본키를 생성해준다.</li>
<li>@SequenceGenerator 어노테이션이 필요하다.</li>
</ul>
<blockquote>
<p>SEQUENCE 전략도 IDENTITY 전략과 동일한 문제가 있다. 데이터베이스가 직접 기본키를 생성해주기 때문이다.<br>
ENtityManage.persist() 가 호출 되기 전에 기본키를 가져와야 하므로 하이버네이트에서 hibernamte:call next value for USER_PK_SEQ을 실행하여 기본키를 가져온다.<br>
그 후에 EntityManager.persist() 호출하기 때문에 IDENTITY 전략과 다르게 쿼리문을 실행하지 않는다.<br>
하지만 SEQUENCE 값을 계쏙 DB에서 가져와서 사용해야 하기 때문에 성능 저하를 일으킬 수 있다.<br>
해결방법은 allocationSize의 크기를 적당히 설정하여 성능 저하 개선하는 방법이 있다.</p>
</blockquote>
<h3 id="table"> TABLE</h3>
<div><pre><code><span>@Entity</span>
<span>@TableGenerator</span><span>(</span>
    name <span>=</span> <span>"USER_PK_GENERATOR"</span><span>,</span>
    table <span>=</span> <span>"USER_PK_SEQ"</span><span>,</span>
    pkColumnValue <span>=</span> <span>"USER_SEQ"</span><span>,</span>
    allocationSize <span>=</span> <span>1</span>
<span>)</span>
<span>public</span> <span>class</span> <span>PkEx</span><span>(</span><span>)</span> <span>{</span>
    
        <span>@Id</span>
        <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>SEQUENCE<span>,</span>
                    generator<span>=</span><span>"USER_PK_GENERATOR"</span><span>)</span>
        <span>private</span> <span>Long</span> id<span>;</span>
    
        <span>private</span> <span>String</span> name<span>;</span>
        
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>키를 생성하는 테이블을 사용하는 방법으로 Sequence와 유사하다.</li>
<li>@TableGenerator 어노테이션이 필요하다.</li>
</ul>
<blockquote>
<p>TABLE 전략은 모든 데이터베이스에서 사용이 가능하지만 최적화 되어있지 않은 테이블을 사용하기 때문에 성능 이슈가 있다.</p>
</blockquote>
<h3 id="auto"> AUTO</h3>
<div><pre><code><span>@GeneratedValue</span><span>(</span>strategy <span>=</span> <span>GenerationType</span><span>.</span>AUTO<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>기본 설정 값으로 데이터베이스에 따라 기본키를 자동으로 생성한다.</li>
</ul>
<h4 id="기본키의-제약조건"> 기본키의 제약조건</h4>
<ul>
<li>null이면 안된다.</li>
<li>유일하게 실벽할 수 있어야한다.</li>
<li>변하지 않는 값이어야 한다.</li>
</ul>
<br>
<h2 id="_0508-retryable"> 0508 - @Retryable</h2>
<p>특정 Exception이 발생했을 경우 일정 횟수만큼 재시도할 수 있는 어노테이션이다.</p>
<ul>
<li>dependencies 설정</li>
</ul>
<div><pre><code>implementation &#39;org.springframework.boot:spring-boot-starter&#39;
implementation &#39;org.springframework.boot:spring-boot-starter-web:2.5.4&#39;

implementation &#39;org.springframework.retry:spring-retry:1.3.1&#39;
runtimeOnly &#39;org.aspectj:aspectjweaver:1.9.7&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>EnableRetry 설정</li>
</ul>
<div><pre><code><span>@SpringBootApplication</span>
<span>@EnableRetry</span>
<span>public</span> <span>class</span> <span>FailsafeRetryApplication</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>FailsafeRetryApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>@Retryable로 재시도 진행</li>
</ul>
<div><pre><code><span>@Service</span>
<span>public</span> <span>class</span> <span>RetryableService</span> <span>{</span>

    <span>@Retryable</span><span>(</span>maxAttempts <span>=</span> <span>2</span><span>,</span> backoff <span>=</span> <span>@Backoff</span><span>(</span><span>2000</span><span>)</span><span>,</span> value <span>=</span> <span>IllegalStateException</span><span>.</span><span>class</span><span>,</span>
            exclude <span>=</span> <span>{</span> <span>NullPointerException</span><span>.</span><span>class</span><span>,</span> <span>NullPointerException</span><span>.</span><span>class</span> <span>}</span><span>)</span>
    <span>public</span> <span>String</span> <span>getRetryable</span><span>(</span><span>Integer</span> intValue<span>)</span> <span>{</span>
        <span>.</span><span>.</span><span>.</span>
    <span>}</span>

    <span>@Recover</span>
    <span>String</span> <span>recover</span><span>(</span><span>NullPointerException</span> e<span>)</span> <span>{</span>
        <span>return</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@Recover</span>
    <span>String</span> <span>recover</span><span>(</span><span>NumberFormatException</span> e<span>,</span> <span>Integer</span> intValue<span>)</span> <span>{</span>
        <span>return</span> <span>String</span><span>.</span><span>format</span><span>(</span><span>"%s : %s"</span><span>,</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>,</span> intValue<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code>- value, include : retry할 Exception을 지정한다.
- exclude : 제외할 Exception을 지정한다.
- maxAttempts : 최대 재시도 횟수(default 3)
- backoff : 재시도 pause 시간
- @Recover의 경우 발생한 Exception에 대한 return 처리를 진행할 수 있다. 단, 리턴타입은 @Retryable에 정의한 리턴타입과 동일해야 한다.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><br>
<h2 id="_0511-isblank-isempty-hastext"> 0511 - isBlank, isEmpty, hasText</h2>
<ul>
<li>자바 11버전 String.isBlank() : &quot;&quot;, null, whitespace 체크</li>
<li>isEmpty() : &quot;, null 체크 (deprecated)</li>
<li>StringUtils.hasText() : &quot;&quot;, null, whitespace 체크</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0516 ~ 0529</title>
      <link>ahnjs/TIL/2022/0516/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0516/</guid>
      <source url="ahnjs/TIL/rss.xml">0516 ~ 0529</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0516-0529"> 0516 ~ 0529</h1>
<h2 id="_0519-querydsl-튜플이나-dto로-결과-반환하기"> 0519 - Querydsl 튜플이나 DTO로 결과 반환하기</h2>
<ul>
<li>프로젝션 : select 대상을 지정하는 일</li>
</ul>
<h3 id="튜플"> 튜플</h3>
<ul>
<li>com.querydsl.core.Tuple 사용</li>
</ul>
<div><pre><code><span>List</span><span><span>&lt;</span><span>Tuple</span><span>></span></span> result <span>=</span> queryFactory
                        <span>.</span><span>select</span><span>(</span>member<span>.</span>username<span>,</span> member<span>.</span>age<span>)</span>
                        <span>.</span><span>from</span><span>(</span>member<span>)</span>
                        <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>

<span>for</span> <span>(</span><span>Tuple</span> tuple <span>:</span> result<span>)</span> <span>{</span>
    <span>String</span> username <span>=</span> tuple<span>.</span><span>get</span><span>(</span>member<span>.</span>username<span>)</span><span>;</span>
    <span>Integer</span> age <span>=</span> tuple<span>.</span><span>get</span><span>(</span>member<span>.</span>age<span>)</span><span>;</span>
    
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"username="</span> <span>+</span> username<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"age="</span> <span>+</span> age<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="dto-사용하기"> DTO 사용하기</h3>
<ul>
<li>프로퍼티 접근</li>
<li>필드 직접 접근</li>
<li>생성자 사용</li>
<li>@QueryProjection</li>
</ul>
<h4 id="bean-getter-setter-default-constructor-필요"> Bean() : getter, setter, default constructor 필요</h4>
<div><pre><code><span>List</span><span><span>&lt;</span><span>MemberDto</span><span>></span></span> result <span>=</span> queryFactory
                          <span>.</span><span>select</span><span>(</span><span>Projections</span><span>.</span><span>bean</span><span>(</span><span>MemberDto</span><span>.</span><span>class</span><span>,</span>
                                        member<span>.</span>username<span>,</span>
                                        member<span>.</span>age<span>)</span><span>)</span>
                          <span>.</span><span>from</span><span>(</span>member<span>)</span>
                          <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="필드-직접-접근-getter-setter-필요-없음-바로주입"> 필드 직접 접근 : getter, setter 필요 없음, 바로주입</h4>
<div><pre><code><span>List</span><span><span>&lt;</span><span>MemberDto</span><span>></span></span> result <span>=</span> queryFactory
                        <span>.</span><span>select</span><span>(</span><span>Projections</span><span>.</span><span>fields</span><span>(</span><span>MemberDto</span><span>.</span><span>class</span><span>,</span>
                                    member<span>.</span>username<span>,</span>
                                    member<span>.</span>age<span>)</span><span>)</span>
                        <span>.</span><span>from</span><span>(</span>member<span>)</span>
                        <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="생성자-사용"> 생성자 사용</h4>
<div><pre><code><span>List</span><span><span>&lt;</span><span>MemberDto</span><span>></span></span> result <span>=</span> queryFactory
                            <span>.</span><span>select</span><span>(</span><span>Projections</span><span>.</span><span>constructor</span><span>(</span><span>MemberDto</span><span>.</span><span>class</span><span>,</span>
                                      member<span>.</span>username<span>,</span>
                                      member<span>.</span>age<span>)</span><span>)</span>
                            <span>.</span><span>from</span><span>(</span>member<span>)</span>
                            <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>DTO의 필드명이 다를경우 <code>ExpressionUtils.as(source,alias)</code> -&gt; 필드나, 서브 쿼리에 별칭 적용</p>
</blockquote>
<div><pre><code><span>List</span><span><span>&lt;</span><span>UserDto</span><span>></span></span> fetch <span>=</span> queryFactory
                        <span>.</span><span>select</span><span>(</span><span>Projections</span><span>.</span><span>fields</span><span>(</span><span>UserDto</span><span>.</span><span>class</span><span>,</span>
                                member<span>.</span>username<span>.</span><span>as</span><span>(</span><span>"name"</span><span>)</span><span>,</span>
                                <span>ExpressionUtils</span><span>.</span><span>as</span><span>(</span>
                                    <span>JPAExpressions</span>
                                    <span>.</span><span>select</span><span>(</span>memberSub<span>.</span>age<span>.</span><span>max</span><span>(</span><span>)</span><span>)</span>
                                    <span>.</span><span>from</span><span>(</span>memberSub<span>)</span><span>,</span> <span>"age"</span><span>)</span>
                                <span>)</span><span>)</span>
                        <span>.</span><span>from</span><span>(</span>member<span>)</span>
                        <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="queryprojection"> @QueryProjection</h4>
<ul>
<li>DTO 생성자에 @QueryProjection을 사용하면 DTO도 Q파일로 생성된다.</li>
</ul>
<div><pre><code><span>import</span> <span>com<span>.</span>querydsl<span>.</span>core<span>.</span>annotations<span>.</span></span><span>QueryProjection</span><span>;</span>

<span>public</span> <span>class</span> <span>MemberDto</span> <span>{</span>

    <span>private</span> <span>String</span> username<span>;</span>

    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>MemberDto</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>

    <span>@QueryProjection</span>
    <span>public</span> <span>MemberDto</span><span>(</span><span>String</span> username<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>username <span>=</span> username<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>생성된 Q파일 사용</li>
</ul>
<div><pre><code>queryFactory
    <span>.</span><span>select</span><span>(</span><span>new</span> <span>QMemberDto</span><span>(</span>member<span>.</span>username<span>,</span> member<span>.</span>age<span>)</span><span>)</span>
    <span>.</span><span>from</span><span>(</span>member<span>)</span>
    <span>.</span><span>fetch</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>특징</p>
<ul>
<li>컴파일오류로 사전 버그 확인.</li>
<li>컴파일 시점에 타입 체크, 파라미터 개수체크 등 가능.</li>
<li>단, DTO가 Querydsl에 의존성이 생긴다.</li>
</ul>
<br>
<h2 id="_0520-spring-data-common-repository-norepositorybean"> 0520 - [Spring Data Common] Repository, @NoRepositoryBean</h2>
<h3 id="spring-data"> Spring Data</h3>
<p>Spring Data는 Spring에서 SQL &amp; NoSQL 저장소 지원 프로젝트의 묶음이다.<br>
Spring에서 제공하는 여러 저장소 지원 프로젝트의 공통 프로젝트가 바로 <code>Spring Data Common</code>이다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbXkxxz%2Fbtrc2ouagN1%2FKDIwF2KfKcaELHMftFWpM1%2Fimg.png" alt="image"></p>
<h3 id="spring-data-common"> Spring Data Common</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJKTlM%2Fbtrc1u2yKrQ%2FhQoWL6SpdKFaiXrO8BSLJ0%2Fimg.png" alt="image">
JpaRepository 인터페이스는 Spring Data Jpa에서 제공하는 인터페이스이다.</p>
<p>JpaRepository가 상속받는 PagingAndSortingRepository는 Spring Data Common에서 제공하는 인터페이스이다.(PagingAndSortingRepository는부터는 Spring Data Common단의 인터페이스)</p>
<ul>
<li>PagingAndSortingRepository : 페이징, 정렬 지원하는 메서드 제공</li>
<li>CrudRepository : CRUD를 지원하는 메서드 제공</li>
<li>Repository : Marker 인터페이스. 마커용 외에 다른 기능은 없다</li>
</ul>
<h3 id="norepositorybean"> @NoRepositoryBean</h3>
<p>JpaRepository, PagingAndSortingRepository, CurdRepository의 중간단계 Repository를 보면 @NoRepositoryBean 어노테이션이 선언되어있다.</p>
<div><pre><code><span>package</span> <span>org<span>.</span>springframework<span>.</span>data<span>.</span>jpa<span>.</span>repository</span><span>;</span>

<span>/**
 * JPA specific extension of {@link org.springframework.data.repository.Repository}.
 *
 * @author Oliver Gierke
 * @author Christoph Strobl
 * @author Mark Paluch
 */</span>
<span>@NoRepositoryBean</span>
<span>public</span> <span>interface</span> <span>JpaRepository</span><span><span>&lt;</span><span>T</span><span>,</span> ID<span>></span></span> <span>extends</span> <span>PagingAndSortingRepository</span><span><span>&lt;</span><span>T</span><span>,</span> ID<span>></span></span><span>,</span> <span>QueryByExampleExecutor</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>중간 Repository에 @NoRepositoryBean 어노테이션이 붙어있는 이유는 다음과 같다.</p>
<ul>
<li>Repository 인터페이스를 상속받았기 때문에 Spring Data Jpa 또는 다른 저장소용 Repository가 실제 빈을 만들지 않도록 사용.</li>
<li>실제 사용되는 Repository가 아님을 표시함.</li>
</ul>
<br>
<h2 id="_0522-isequalto-vs-issameto-isinstanceof"> 0522 - isEqualTo vs isSameTo(isInstanceOf)</h2>
<ul>
<li>isSameAs : 주소 비교. 메모리 상에서 같은 객체를 참조하는지 확인</li>
<li>isEqualTo : 값 비교. 객체가 서로 같은 값을 가지고 있는지 확인(객체를 비교하게 되는 경우 isSameAs와 같이 참조를 비교)</li>
<li>isInstanceOf : 타입 비교</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbXkxxz%2Fbtrc2ouagN1%2FKDIwF2KfKcaELHMftFWpM1%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0418 ~ 0424</title>
      <link>ahnjs/TIL/2022/0418/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0418/</guid>
      <source url="ahnjs/TIL/rss.xml">0418 ~ 0424</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0418-0424"> 0418 ~ 0424</h1>
<h2 id="_0418-퍼사드-패턴-facade-pattern"> 0418 - 퍼사드 패턴(Facade Pattern)</h2>
<h3 id="퍼사드-패턴이란"> 퍼사드 패턴이란</h3>
<blockquote>
<p>서브시스템의 인터페이스 집합에 대한 하나의 상위 수준 인터페이스를 정의하는 패턴</p>
</blockquote>
<p>퍼사드 패턴(Facade Pattern)은 구조패턴(Structural Pattern)의 한 종류로, 서브시스템들의 공통적인 기능을 정의하는 단순화된 상위 수준의 인터페이스를 정의하는 패턴이다. 서브시스템들 사이의 종속성을 줄일 수 있다.</p>
<h4 id="구조-패턴-structural-pattern"> 구조 패턴(Structural Pattern)</h4>
<p>구조패턴이란 작은 클래스들의 상속과 합성을 통해 더 큰 클래스를 생성하는 방법을 제공하는 패턴으로, 독립적으로 개발한 클래스들을 마치 하나인 것 처럼 사용할 수 있다.</p>
<ul>
<li>적응자 패턴(Adapter)</li>
<li>가교 패턴(Bridge)</li>
<li>복합체 패턴(Composite)</li>
<li>장식자 패턴(Decorator)</li>
<li>퍼사드 패턴(Facade)</li>
<li>플라이급 패턴(Flyweight)</li>
<li>프록시 패턴(Proxy)</li>
</ul>
<h3 id="구성"> 구성</h3>
<p><img src="https://dev-aiden.com/assets/images/2021-08-26-Facade-Pattern/1.png" alt="image"></p>
<ul>
<li>Facade : 사용자의 요청을 서브시스템 객체에 전달하는 단순하고 일관된 통합 인터페이스</li>
<li>Subsystem Classes : Facade에 대해 정보를 가지지 않고, 서브시스템의 기능을 구현하는 클래스</li>
</ul>
<h3 id="퍼사드-패턴-예제"> 퍼사드 패턴 예제</h3>
<p>우리가 아침에 일어나서 사무실에 출근하기까지를 여러 과정으로 나눠볼 수 있다. 예를 들어 씻고, 아침을 먹고, 대중교통을 타서 출근을 하는데, 퍼사드 패턴을 이용하여 각각의 동작들을 서브클래스로 구현하고, 서브클래스들의 공통 기능을 정의하는 상위 수준의 인터페이스를 정의할 수 있다.</p>
<h4 id="facade"> Facade</h4>
<div><pre><code><span>public</span> <span>class</span> <span>GoOffice</span> <span>{</span>

    <span>public</span> <span>void</span> <span>goToWork</span><span>(</span><span>)</span> <span>{</span>
        <span>Wash</span> wash <span>=</span> <span>new</span> <span>Wash</span><span>(</span><span>)</span><span>;</span>
        <span>Breakfast</span> breakfast <span>=</span> <span>new</span> <span>Breakfast</span><span>(</span><span>)</span><span>;</span>
        <span>Move</span> move <span>=</span> <span>new</span> <span>Move</span><span>(</span><span>)</span><span>;</span>

        wash<span>.</span><span>brushTeeth</span><span>(</span><span>)</span><span>;</span>
        wash<span>.</span><span>shower</span><span>(</span><span>)</span><span>;</span>
        breakfast<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
        breakfast<span>.</span><span>water</span><span>(</span><span>)</span><span>;</span>
        move<span>.</span><span>bus</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="subsystem-classes"> Subsystem Classes</h4>
<div><pre><code><span>public</span> <span>class</span> <span>Wash</span> <span>{</span>

    <span>public</span> <span>void</span> <span>brushTeeth</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Brush my teeth"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>shower</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Take a shower"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Breakfast</span> <span>{</span>

    <span>public</span> <span>void</span> <span>eat</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Have breakfast"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>water</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Drink water"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>Move</span> <span>{</span>

    <span>public</span> <span>void</span> <span>bus</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Take the bus"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="특징"> 특징</h3>
<ul>
<li>낮은 결합도 : 클라이언트가 서브시스템의 코드를 모르더라고 Facade 클래스를 통해 사용 가능</li>
<li>서브 클래스 직접 접근 가능 : Facade 클래스를 통해 서브클래스를 사용할지, 서브클래스를 직접 사용할지 선택 가능</li>
</ul>
<br>
<h2 id="_0422-애플리케이션-컨텍스트-application-context"> 0422 - 애플리케이션 컨텍스트(Application Context)</h2>
<h3 id="applicationcontext란"> ApplicationContext란?</h3>
<p>Spring에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC(Inversion of Control) 컨테이너인 빈 팩토리(Bean Factory)가 존재한다. 하지만 실제로는 빈의 생성과 관계설정 외에 추가적인 기능이 필요하다. 이러한 이유로 빈 팩토리를 상속받아 확장한 애플리케이션 컨텍스트를 주로 사용한다.<br>
애플리케이션 컨텍스트는 별도의 설정 정보를 참고하고 IoC를 적용하여 빈의 생성, 관계설정 등의 제어 작업을 총괄한다. 애플리케이션 컨텍스트에는 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 그런 생성 정보와 연관관계 정보에 대한 설정을 읽어 처리한다. 예를 들어 @Configuration과 같은 어노테이션이 대표적인 IoC의 설정정보이다.</p>
<p>ApplicationContext를 스프링 컨테이너라고 한다. ApplicationContext는 BeanFactory 인터페이스의 하위 인터페이스이다. 즉, ApplicationContext는 BeanFactory에 부가기능을 추가한 것이다.
BeanFactory는 스프링 컨테이너의 최상위 인터페이스이다. 스프링 빈을 관리하고 조회하는 역할을 한다. ApplicationContext는 BeanFactory + 부가 기능(국제화 기능, 환경 변수 관련 처리, 애플리케이션 이벤트, 리소스 조회)을 가진다.
정확히는 스프링 컨테이너를 부를 때, BeanFactory, ApplicationContext를 구분해서 말하지만, BeanFactory를 직접적으로 사용하는 경우는 거의 없다. 왜냐하면 ApplicationContext가 BeanFactory의 모든 기능을 가지고 있기 때문이다.
ApplicationContext의 구현체가 여러가지 있는데, 구현체에 따라 스프링 컨테이너를 XML을 기반으로 만들 수도 있고, 자바 클래스로 만들 수도 있다. 이게 가능한 이유는 빈 등록을 BeanDefinition으로 추상화해서 생성 하기 때문이다. XML로 하든, 자바로 하든 BeanDefinition이 생성된다.
스프링 컨테이너 내부에는 빈 저장소가 존재한다. 빈 저장소는 key로 빈 이름을 가지고 있으며, value로 실제 빈 객체를 가지고 있다.
스프링 컨테이너는 기본적으로 빈을 싱글톤으로 관리해준다. 따라서 싱글톤 컨테이너라고 불리기도 한다. 스프링 컨테이너가 빈을 싱글톤으로 관리해주면서 기존 싱글턴 패턴의 문제점(싱글톤 패턴 구현을 위한 코드가 추가되어야함, 구체 클래스에 의존, 유연성이 떨어짐 etc)은 없어지고, 싱글톤의 장점(매번 인스턴스를 생성할 필요없이 단 하나만 생성해서 비용을 줄일 수 있다.)만 가져갈 수 있다.</p>
<h3 id="빈-bean-요청-시-처리-과정"> 빈(Bean) 요청 시 처리 과정</h3>
<p>클라이언트에서 해당 빈을 요청하면 애플리케이션 컨텍스트는 다음과 같은 과정을 거쳐 빈을 반환한다.</p>
<ol>
<li>ApplicationContext는 @Configuration이 붙은 클래스들을 설정 정보로 등록해두고, @Bean이 붙은 메소드의 이름으로 빈 목록을 생성한다.</li>
<li>클라이언트가 해당 빈을 요청한다.</li>
<li>ApplicationContext는 자신의 빈 목록에서 요청한 이름이 있는지 찾는다.</li>
<li>ApplicationContext는 설정 클래스로부터 빈 생성을 요청하고, 생성된 빈을 돌려준다.</li>
</ol>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLuLhA%2Fbtq4squITMm%2FmqqtgMfiiahkAFBuPLMaLk%2Fimg.png" alt="image"></p>
<p>애플리케이션 컨택스트는 @Configuration이 붙은 클래스들을 설정 정보로 등록해두고, @Bean이 붙은 메소드의 이름으로 빈 목록을 생성한다. 그리고 클라이언트가 해당 빈을 요청한다면 애플리케이션 컨텍스트는 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 있다면 해당 빈 생성 메소드(@Bean)을 호출하여 객체를 생성하고 돌려준다. (구체적으로는 Spring 내부에서 Reflection API를 이용해 빈 정의에 나오는 클래스 이름을 이용하거나 또는 빈 팩토리를 통해 빈을 생성한다.)</p>
<h3 id="애플리케이션-컨텍스트의-장점"> 애플리케이션 컨텍스트의 장점</h3>
<h4 id="클라이언트는-configuration이-붙은-구체적인-팩토리-클래스를-알-필요가-없다"> - 클라이언트는 @Configuration이 붙은 구체적인 팩토리 클래스를 알 필요가 없다.</h4>
<p>애플리케이션이 발전하면 팩토리 클래스가 계속해서 증가할 것이다. 애플리케이션 컨텍스트가 없다면 클라이언트는 원하는 객체를 가져오려면 어떤 팩토리 클래스에 접근해야 하는지 알아야 하는 번거로움이 생긴다. 반면에 애플리케이션 컨텍스트를 사용하면 팩토리가 아무리 많아져도 이에 직접 접근할 필요가 없어진다. 즉, 일관된 방식으로 원하는 빈을 가져올 수 있다.</p>
<h4 id="애플리케이션-컨텍스트는-종합-ioc-서비스를-제공해준다"> - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.</h4>
<p>애플리케이션 컨텍스트는 객체의 생성과 관계 설정이 다가 아니다. 객체가 만들어지는 방식과 시점 및 전략 등을 다르게 가져갈 수 있고, 그 외에에도 후처리나 정보의 조합 인터셉트 등과 같은 다양한 기능이 존재한다.</p>
<h4 id="애플리케이션-컨텍스트를-통해-다양한-빈-검색-방법을-제공할-수-있다"> - 애플리케이션 컨텍스트를 통해 다양한 빈 검색 방법을 제공할 수 있다.</h4>
<p>애플리케이션 컨텍스트에서 빈 목록을 관리하여, 빈의 이름이나 타입 또는 어노테이션 설정 등으로 빈을 찾을 수 있다. 이러한 빈을 직접 찾는 방식은 의존성 검색(dependency lookup)으로 불린다.</p>
<h3 id="자바-설정-클래스로-스프링-컨테이너-생성하기"> 자바 설정 클래스로 스프링 컨테이너 생성하기</h3>
<p>어노테이션 기반의 자바 크래스로 스프링 컨테이너를 만든 예시이다.</p>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>AppConfig</span> <span>{</span>

    <span>@Bean</span>
    <span>public</span> <span>StationService</span> <span>stationService</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>StationServiceImpl</span><span>(</span><span>stationRepository</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>@Bean</span>
    <span>public</span> <span>StationRepository</span> <span>stationRepository</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>MemoryStationRepository</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>@Bean</span>
    <span>// ...</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><code>new AnnotationConfigApplicationContext()</code>를 통헤 자바 기반 스프링 컨테이너를 만들어 준다. 그럼 비어있는 빈 저장소가 생긴다. 이때 만들어 둔 자바 설정 크래스를 파라미터로 넘겨줘서 생성한다. 그럼 자바 설정 클래스 내부의 @Bean 어노테이션이 붙은 메서드들을 실행하면서 빈 저장소에 실제 빈을 등록한다.</p>
<div><pre><code><span>ApplicationContext</span> applicationContext <span>=</span> <span>new</span> <span>AnnotationConfigApplicationContext</span><span>(</span><span>AppConfig</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>사용할 땐, 빈 등록 메서드 이름을 통해 객체를 가져올 수 있다.</p>
<div><pre><code><span>StationService</span> stationService <span>=</span> applicationContext<span>.</span><span>getBean</span><span>(</span><span>"stationService"</span><span>,</span> <span>StationService</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_0424-스프링-spring-의-싱글톤-singleton"> 0424 - 스프링(Spring)의 싱글톤(Singleton)</h2>
<h3 id="스프링에서-싱글톤을-사용하는-이유"> 스프링에서 싱글톤을 사용하는 이유</h3>
<p>애플리케이션 컨텍스트에 의해 등록된 빈은 기본적으로 싱글톤으로 관리된다. 즉, 스프링에 여러 번을 요청하더라도 매번 동일한 객체를 돌려준다. 애플리케이션 컨테긋트가 싱글톤으로 빈을 관리하는 이유는 대규모 트래픽을 처리할 수 있도록 하기 위함이다.<br>
스프링은 최초에 설계될 때 부터 대규모의 엔터프라이즈 환경에서 요청을 처리할 수 있도록 고안되었다. 그리고 그에따라 계층적으로 처리 구조(Controller, Service, Repository 등)가 나뉘어지게 되었다.<br>
그런데 매번 클라이언트에서 요청이 올 때무다 각 로직을 처리하는 빈을 새로 만들어서 사용한다고 생각해보자. 요청 1번에 5개의 객체가 만들어 진다고 하고, 1초에 500번 요청이 온다고 하면 초당 2500개의 새로운 객체가 생성된다. 아무리 GC의 성능이 좋아졌다 하더라도 부하가 걸리면 감당이 힘들 것이다.<br>
그래서 이러한 문제를 해결하고자 빈을 싱글톤 스코프로 관리하여 1개의 요청이 왔을 때 여러 쓰레드가 빈을 공유해 처리하도록 하였다.</p>
<h3 id="스프링ᄋ에서-관리하는-싱글톤의-장점"> 스프링ㅇ에서 관리하는 싱글톤의 장점</h3>
<ul>
<li>private 생성자를 갖고 있어 상속이 불가능하다.</li>
<li>테스트하기 힘들다.</li>
<li>서버 환경에서는 싱글톤이 1개만 생성됨을 보장하지 못한다.</li>
<li>전역 상태를 만들 수 있기 때문에 바람직하지 못하다.</li>
</ul>
<p>그래서 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는데, 그것이 바로 싱글톤 레지스트리(Singleton Registry)이다. 스프링 컨테이너는 싱글톤을 생성하고, 관리하고 공급하는 컨테이너기이기도 하다. 싱긅톤 레지스트리의 장점은 다음과 같다.</p>
<ul>
<li>static 메소드나 private 생성자 등을 사용하지 않아 객체지향적 개발을 할 수 있다.</li>
<li>테스트를 하기 편리하다.</li>
</ul>
<p>기본적으로 싱글톤이 멀티쓰레드 환경에서 서비스 형태 객체로 사용되기 위해서는 내부에 상태정보를 갖지 않는 무상태(Stateless) 방식으로 만들어져야 한다. 만약 여러 쓰레드드들이 동시에 상태를 접근하여 수정한다면 상당히 위험하기 때문이다.<br>
직접 싱글톤을 구현한다면 상당히 많은 단점들이 있겠지만, 스프링 프레임워크에서 직접 싱글톤으로 객체를 관리해주므로,ㅡ 우리는 더욱 객체지향적인 개발을 할 수 있게 된다.</p>
]]></content:encoded>
      <enclosure url="https://dev-aiden.com/assets/images/2021-08-26-Facade-Pattern/1.png" type="image/png"/>
    </item>
    <item>
      <title>0523 ~ 0605</title>
      <link>ahnjs/TIL/2022/0523/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0523/</guid>
      <source url="ahnjs/TIL/rss.xml">0523 ~ 0605</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0523-0605"> 0523 ~ 0605</h1>
<h2 id="_0525-단위-테스트-통합-테스트-인수-테스트"> 0525 - 단위 테스트, 통합 테스트, 인수 테스트</h2>
<h3 id="단위-테스트-unit-test"> 단위 테스트 (Unit Test)</h3>
<blockquote>
<p>단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트</p>
</blockquote>
<p>단위 테스트에서 테스트 대상 단위의 크기는 엄격하게 정해져 있지 않다. 하지만, 일반적으로 클래스 또는 메소드 수준으로 정해진다. 단위의 크기가 작을수록 단위의 복잡성이 낮아진다. 따라서, 단위 테스트를 활용하여 동작을 표현하기 더 쉬워진다. 즉, 테스트 대상 단위의 크기를 작게 설정해서 단위 테스트를 최대한 간단하고 디버깅하게 쉽게 작성해야 한다.</p>
<p>소프트웨어를 개발할 때, 소프트웨어 내부 구조나 구현 방법을 고려하여 개발자관점에서 테스트한다. 그러므로 단위 테스트는 소프트웨어 내부 코드에 관련한 지식을 반드시 알고 있어야 하는 화이트박스 테스트이다. 단위 테스트는 TDD와 함께 할 때 특히 더 강력해진다.</p>
<div><pre><code><span>@DisplayName</span><span>(</span><span>"자동차가 전진한다"</span><span>)</span>
<span>@Test</span>
<span>public</span> <span>void</span> <span>moveCar</span><span>(</span><span>)</span> <span>{</span>
    <span>// given</span>
    <span>Car</span> car <span>=</span> <span>new</span> <span>Car</span><span>(</span><span>"dani"</span><span>)</span><span>;</span>

    <span>// when</span>
    car<span>.</span><span>move</span><span>(</span><span>4</span><span>)</span><span>;</span>

    <span>// then</span>
    <span>assertThat</span><span>(</span>car<span>.</span><span>getPosition</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>@DisplayName</span><span>(</span><span>"자동차가 멈춘다"</span><span>)</span>
<span>@Test</span>
<span>public</span> <span>void</span> <span>stopCar</span><span>(</span><span>)</span> <span>{</span>
    <span>// given</span>
    <span>Car</span> car <span>=</span> <span>new</span> <span>Car</span><span>(</span><span>"dani"</span><span>)</span><span>;</span>

    <span>// when</span>
    car<span>.</span><span>move</span><span>(</span><span>3</span><span>)</span><span>;</span>

    <span>// then</span>
    <span>assertThat</span><span>(</span>car<span>.</span><span>getPosition</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="통합-테스트-integration-test"> 통합 테스트 (Integration Test)</h3>
<blockquote>
<p>통합 테스트는 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트이다.</p>
</blockquote>
<p>통합 테스트는 단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부 라이브러리)까지 묶어 검증할 때 사용한다. 이는 DB에 접근하거나 전체 코드와 다양한 환경이 제대로 작동하는지 확인하는데 필요한 모든 작업을 수행할 수 있다. 그러나, 통합 테스트가 응용 프로그램이 완전하게 작동하는걸 무조건 증명하지는 않는다.</p>
<p>통합 테스트의 장점은 단위 테스트에서 발견하기 어려운 버그를 찾을 수 있다는 점이다. 예를 들어, 통합 테스트에서는 환경 버그(ex. 싱글 코어 CPU에서는 잘 실행되거나 쿼드 코어 CPU에서는 잘 실행되지 않음)이 발생할 수 있다.</p>
<p>한편, 통합 테스트의 단점은 단위 테스트보다 더 많은 코드를 테스트하기 때문에 신회성이 떨어질 수 있다는 점이다. 또, 어디서 에러가 발생했는지 확인하기 쉽지 않아 유지보수하기 힘들다는 점도 있다.</p>
<p>스프링부트에서는 클래스 상단에 @SpringBootTest 어노테이션을 붙여 통합 테스트를 수행할 수 있다.</p>
<div><pre><code><span>@SpringBootTest</span>
<span>class</span> <span>SubwayApplicationTests</span> <span>{</span>
    <span>@Test</span>
    <span>void</span> <span>contextLoads</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="인수-테스트-acceptance-test"> 인수 테스트 (Acceptance Test)</h3>
<blockquote>
<p>인수테스트는 사용자 스토리(시나리오)에 맞춰 수행하는 테스트이다.</p>
</blockquote>
<p>앞선 두 테스트들과 달리 비즈니스 쪽에 초점을 둔다. 프로젝트에 참여하는 사람들이 토의해서 시나리오를 만들고, 개발자는 이에 의거해서 코드를 작성한다. 개발자가 직접 시나리오를 제작할 수도 있지만, 다른 의사소통집단으로부터 시나리오를 받아 개발한다는 의미를 가지고 있다.</p>
<p>인수 테스트는 애자일 개발론에서 파생했다. 특히, 익스트림 프로그래밍(XP)에서 사용하는 용어이다. 이는 시나리오가 정상적으로 동작하는지를 테스트하기 때문에 통합 테스트와는 분류가 다르다. 시나리오에서 요구하는 것은 누가, 어떤 목적으로, 무엇을 하는가이다. 개발을 하다 보면 이런 기능은 API를 통해 드러난다. 인수 테스트는 주로 이 API를 확인인하는 방식으로 이뤄진다.</p>
<p>결국, 인수 테스트는 소프트웨어 인수를 목적으로 하는 테스트이다. 소프트웨어를 인수하기 전에 명세한 요구사항(인수 조건)대로 잘 작동하는지 검증이 필요하다.</p>
<p>소프트웨어를 인수할 때, 소프트웨어 내부 구조나 구현 방법을 고려하기보다는 실제 사용자 관점에서 테스트하는 경우가 많다. 따라서, 인수 테스트는 소프트웨어 내부 코드에 관심을 가지지 않는 블랙박스 테스트이다. 실제 사용자 관점에서 테스트 할 때 E2E(End-to-End) 형식을 이용해서 확인한다.</p>
<p>Java에서는 RestAssured, MockMvc 같은 도구를 활용하여 인수 테스트를 작성 할 수 있다.</p>
<div><pre><code><span>public</span> <span>static</span> <span>ExtractableResponse</span><span><span>&lt;</span><span>Response</span><span>></span></span> 회원_생성_요청<span>(</span><span>MemberRequest</span> memberRequest<span>)</span> <span>{</span>
    <span>return</span> <span>RestAssured</span>
            <span>.</span><span>given</span><span>(</span><span>)</span>
            <span>.</span><span>contentType</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span>
            <span>.</span><span>body</span><span>(</span>memberRequest<span>)</span>
            <span>.</span><span>when</span><span>(</span><span>)</span><span>.</span><span>post</span><span>(</span><span>"/api/members"</span><span>)</span>
            <span>.</span><span>then</span><span>(</span><span>)</span>
            <span>.</span><span>extract</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><br>
<h2 id="_0526-single-branch로-clone-후-새로운-브랜치-추가"> 0526 - Single branch로 Clone 후, 새로운 브랜치 추가</h2>
<p>git에서 브랜치가 많을경우 특정 브랜치만 추적하도록 clone할 수 있다.</p>
<div><pre><code><span>git</span> clone -b <span>&lt;</span>branch name<span>></span> --single-branch <span>&lt;</span>github url<span>></span> <span>&lt;</span>target directory<span>></span>
<span>git</span> clone -b jaesungahn91 --single-branch https://github.com/jaesungahn91/jwp_qna
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>위와 같이 clone한 후 새로운 브랜치를 추가하고 싶은 경우가 있으면 다음과 같이 새로운 브랜치를 추가할 수 있다.</p>
<div><pre><code><span>git</span> remote set-branches --add origin <span>[</span>remote-branch<span>]</span>
<span>git</span> fetch origin <span>[</span>remote-branch<span>]</span>:<span>[</span>local-branch<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><br>
<h2 id="_0529-atdd-인수-테스트"> 0529 - ATDD, 인수 테스트</h2>
<h3 id="인수-테스트-acceptance-test-란"> 인수 테스트(Acceptance Test)란?</h3>
<p>명세 등 요구 사항이 충족되는지 확인하기 위해 비즈니스 측면에 초점을 맞춘 테스트라고 생각할 수 있다. 보통 마지막 단계에서 작업(기능)이 완전히 완료되었는지 검사하는데 수행된다.<br>
요구사항(인수 조건)이 만족하는지 확인하는 과정에서, 시나리오에 맞춰 테스트가 수행된다. 이때, 인수 조건(Aceeptance Criteria)이 사용자 스토리를 시나리오 형식으로 표현되며 시나리오는 프로젝트에 참여하는 사람들(개발자, 기획자 등)의 토의를 통해 나온다.<br>
시나리오의 중점은 누가, 어떤 목적으로, 무엇을 하는가 이다.</p>
<h3 id="atdd-인수-테스트-주도-개발"> ATDD, 인수 테스트 주도 개발</h3>
<p>인수 테스트를 먼저 작성한 다음 기능 개발을 하는 방법<br>
사용자(고객)-개발자-테스터간의 커뮤니케이션을 기반한 개발 방법<br>
애자일의 프로그래밍 방법론 중 하나로 사용자 스토리를 기반으로 인수 조건을 도출하여 기능 개발을 진행하는 방법론이다.</p>
<p>ATDD를 통해 요구사항과, 작업의 순서와 범위를 명확하게 파악할 수 있다.
<img src="https://velog.velcdn.com/images/yyy96/post/df3b213b-8121-4e6e-9b5d-48b489512fce/image.png" alt="image"></p>
<br>
<h2 id="_0531-string-format"> 0531 - String.format</h2>
<div><pre><code><span>public</span> <span>static</span> <span>String</span> <span>format</span><span>(</span><span>String</span> format<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>;</span>
<span>public</span> <span>static</span> <span>String</span> <span>format</span><span>(</span><span>Locale</span> l<span>,</span> <span>String</span> format<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>String의 static 메서드인 format 메서드는 문자열의 형식을 설정하는 메서드이다.</p>
<h4 id="_1-d-integer-formatting"> 1. %d (= Integer Formatting)</h4>
<ul>
<li>10진수 integer의 형식을 설정할 때 이용한다.</li>
</ul>
<div><pre><code><span>int</span> i <span>=</span> <span>23</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%5d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%-5d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%05d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>

<span>// 출력</span>
<span>23_</span>
   <span>23_</span>
<span>23</span>   _
<span>00023_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>int</span> i <span>=</span> <span>123456789</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%,d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%,15d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%,-15d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%,015d_"</span><span>,</span> i<span>)</span><span>)</span><span>;</span>

<span>// 출력</span>
<span>123</span><span>,</span><span>456</span><span>,</span><span>789_</span>
    <span>123</span><span>,</span><span>456</span><span>,</span><span>789_</span>
<span>123</span><span>,</span><span>456</span><span>,</span><span>789</span>    _
<span>0000123</span><span>,</span><span>456</span><span>,</span><span>789_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="_2-s-s-string-formatting"> 2. %s (s= String Formatting)</h4>
<ul>
<li>문자열의 형식을 설정할 대 이용한다.</li>
</ul>
<div><pre><code><span>String</span> str <span>=</span> <span>"tete"</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%s_"</span><span>,</span> str<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%12s_"</span><span>,</span> str<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%-12s_"</span><span>,</span> str<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%.2s_"</span><span>,</span> str<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%-12.2s_"</span><span>,</span> str<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%12.2s_"</span><span>,</span> str<span>)</span><span>)</span><span>;</span>

<span>// 출력</span>
tete_
        tete_
tete        _
te_
te          _
          te_
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_3-f-floating-point-formatting"> 3. %f (= Floating point Formatting)</h4>
<ul>
<li>실수형 숫자 형식을 설정할 때 이용한다.</li>
</ul>
<div><pre><code><span>double</span> n <span>=</span> <span>123.45678</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>3.4</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>n<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%f_"</span><span>,</span> <span>3.4</span><span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%.6f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%15f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%-15f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%.3f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%.2f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%15.2f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%-15.2f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%015f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%015.2f_"</span><span>,</span> n<span>)</span><span>)</span><span>;</span>

<span>// 출력</span>
<span>3.4</span>
<span>123.45678</span>

<span>3.400000_</span>
<span>123.456780_</span>
<span>123.456780_</span>
     <span>123.456780_</span>
<span>123.456780</span>     _
<span>123.457_</span>
<span>123.46_</span>
         <span>123.46_</span>
<span>123.46</span>         _
<span>00000123.456780_</span>
<span>000000000123.46_</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h4 id="_4-locale-설정"> 4. Locale 설정</h4>
<ul>
<li>오버로딩된 <code>String.format(Locale, 포맷, 값);</code> 메서드를 이용하여 국가별 포맷 설정이 가능.</li>
</ul>
<div><pre><code><span>int</span> money <span>=</span> <span>35000</span><span>;</span>
<span>Date</span> today <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>

<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"￦ %,d"</span><span>,</span> money<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>Locale</span><span>.</span>GERMANY<span>,</span> <span>"%,d €"</span><span>,</span> money<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"%tp"</span><span>,</span> today<span>)</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>Locale</span><span>.</span>ENGLISH<span>,</span> <span>"%tp"</span><span>,</span> today<span>)</span><span>)</span><span>;</span>

<span>// 출력</span>
￦ <span>35</span><span>,</span><span>000</span>
<span>35.000</span> €
오후
pm
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><br>
<h2 id="_0602-jpa-연관관계-편의-메서드"> 0602 - JPA 연관관계 편의 메서드</h2>
<h3 id="연관관계-편의-메서드"> 연관관계 편의 메서드</h3>
<p>양방향 연관관계를 맺을 때에는, 양쪽 모두 관계를 맺어주어야한다. 사실 JPA의 입장에서 보았을 때에는 외래키 관리자(연관관계의 주인)쪽에만 관계를 맺어준다면 정상적으로 양쪽 모두에서 조회가 가능하다.</p>
<div><pre><code><span>Team</span> team1 <span>=</span> <span>new</span> <span>Team</span><span>(</span><span>"Team1"</span><span>)</span><span>;</span>
em<span>.</span><span>persist</span><span>(</span>team1<span>)</span><span>;</span>

<span>Member</span> member1 <span>=</span> <span>new</span> <span>Member</span><span>(</span><span>"Member1"</span><span>)</span><span>;</span>
member1<span>.</span><span>setTeam</span><span>(</span>team1<span>)</span><span>;</span> <span>// 연관관계 설정 member1 -> team1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>하지만 객체까지 고려한다면, 양쪽 다 관계를 맺어야한다.</p>
<div><pre><code><span>Team</span> team1 <span>=</span> <span>new</span> <span>Team</span><span>(</span><span>"Team1"</span><span>)</span><span>;</span>
em<span>.</span><span>persist</span><span>(</span>team1<span>)</span><span>;</span>

<span>Member</span> member1 <span>=</span> <span>new</span> <span>Member</span><span>(</span><span>"Member1"</span><span>)</span><span>;</span>
member1<span>.</span><span>setTeam</span><span>(</span>team1<span>)</span><span>;</span> <span>// 연관관계 설정 member1 -> team1</span>
team1<span>.</span><span>getMembers</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span>member1<span>)</span> <span>// 연관관계 설정 tema1 -> member1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>즉, 객체의 양방향 연관관계는 양쪽 모두 관계를 맺어주어야 순수한 객체 상태에서도 정상적으로 동작한다.</p>
<p>이렇듯 양방향 연관관계는 결국 양쪽 모두를 신경써야한다. 만약, setTeam과 getMembers().add를 각각 호출하면 실수가 발생할 수 있다. 따라서 양쪽 모두의 관계를 맺어주는 것을 하나의 코드처럼 사용하는 것이 안전하다.</p>
<div><pre><code><span>public</span> <span>void</span> <span>setTeam</span><span>(</span><span>Team</span> team<span>)</span> <span>{</span>
    <span>this</span><span>.</span>team <span>=</span> team<span>;</span>
    team<span>.</span><span>getMembers</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>위와 같이 한번에 양방향 관계를 설정하는 메서드를 <code>연관관계 편의 메서드</code>라고 한다.</p>
<p>하지만 위와같이 setTeam 메서드를 작성하는 경우 버그가 발생할 수 있다. 예로</p>
<div><pre><code>member1<span>.</span><span>setTeam</span><span>(</span>team1<span>)</span><span>;</span>
member1<span>.</span><span>setTeam</span><span>(</span>team2<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>위와 같이 연속적으로 setTeam을 호출한 이후 team1에서 멤버를 조회하면 member1가 여전히 조회된다. team2로 변경할 때 team1과의 관계를 제거하지 않았기 때문이다.</p>
<p>--&gt; 수정</p>
<div><pre><code><span>public</span> <span>void</span> <span>setTeam</span><span>(</span><span>Team</span> team<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>team <span>!=</span> <span>null</span><span>)</span> <span>{</span> <span>// 기존에 이미 팀이 존재한다면</span>
        <span>this</span><span>.</span>team<span>.</span><span>getMembers</span><span>(</span><span>)</span><span>.</span><span>remove</span><span>(</span><span>this</span><span>)</span><span>;</span> <span>// 관계를 끊는다.</span>
    <span>}</span>
    <span>this</span><span>.</span>team <span>=</span> team<span>;</span>
    team<span>.</span><span>getMembers</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>taem1<span>.</span><span>addMember</span><span>(</span>member1<span>)</span><span>;</span>

<span>// Team</span>
<span>public</span> <span>void</span> <span>addMember</span><span>(</span><span>Member</span> member<span>)</span> <span>{</span>
    <span>this</span><span>.</span>members<span>.</span><span>add</span><span>(</span>member<span>)</span><span>;</span>
    member<span>.</span><span>setTeam</span><span>(</span><span>this</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><br>
<h2 id="_0603-dirtiescontext"> 0603 - @DirtiesContext</h2>
<p>스프링 단위 테스트 진행시  하나의 Spring Context를 재사용함에 따라 발생하는 문제를 해결하기 위해 사용한다.</p>
<p><code>@DirtiesContext</code> 어노테이션은 테스트를 수행 전, 수행 후, 각 테스트 케이스마다 수행하기 전 수행한 이후에 Context를 재생성하는 역할을 한다.</p>
<blockquote>
<p>@DirtiesContext indicates that the underlying Spring ApplicationContext has been dirtied during the execution of a test (that is, the test modified or corrupted it in some manner — for example, by changing the state of a singleton bean) and should be closed. When an application context is marked as dirty, it is removed from the testing framework’s cache and closed. As a consequence, the underlying Spring container is rebuilt for any subsequent test that requires a context with the same configuration metadata.<br>
You can use @DirtiesContext as both a class-level and a method-level annotation within the same class or class hierarchy. In such scenarios, the ApplicationContext is marked as dirty before or after any such annotated method as well as before or after the current test class, depending on the configured methodMode and classMode.</p>
</blockquote>
<p>doc.spring.io에 따르면 @DiritiesContext ApplicationContext 테스트를 실행하는동안 테스트프레임워크의 캐시를 제거하고 닫게한다. 결과적으로 기본 Spring Container에 동일한 구성 멧타 데이터가 있는 컨텍스트를 필요로하는 후속 테스트를 위해 재 빌드된다고 나와있다.</p>
<p>메소드나 클래스레벨에 어노테이션을 붙이는 것으로 동작하며, methodMode, classMode에 따라 각각 다르게 동작하게 설정할 수 있다.</p>
<ol>
<li>클래스의 테스트가 시작하기 전에 context 재생성</li>
</ol>
<div><pre><code><span>@DirtiesContext</span><span>(</span>classMode <span>=</span> BEFORE_CLASS<span>)</span>
<span>public</span> <span>class</span> <span>FreshContextTests</span> <span>{</span>
 <span>// 테스트 케이스들이 새로운 context에서 실행됨</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="2">
<li>클래스의 테스트가 모두 끝난 다음 context 재생성 (기본값)</li>
</ol>
<div><pre><code><span>@DirtiesContext</span>
<span>public</span> <span>class</span> <span>ContextDirtyingTests</span> <span>{</span>
 <span>// 테스트 케이스가 context의 @Bean의 상태에 영향을 끼침</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="3">
<li>클래스의 모든 테스트 케이스마다 시작하기 이전에 context 재생성</li>
</ol>
<div><pre><code><span>@DirtiesContex</span><span>(</span>classMode <span>=</span> BEFORE_EACH_TEST_METHOD<span>)</span>
<span>public</span> <span>class</span> <span>FreshContextTests</span> <span>{</span>
 <span>// 모든 케이스에서 새로운 context가 필요함</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="4">
<li>클래스의 모든 테스트 케이스가 끝날 때 마다 context 재생성</li>
</ol>
<div><pre><code><span>@DirtiesContext</span><span>(</span>classMode <span>=</span> AFTER_EACH_TEST_METHOD<span>)</span>
<span>public</span> <span>class</span> <span>ContextDirtyingTests</span> <span>{</span>
 <span>// 모든 케이스가 context의 상태에 영향을 끼침</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol start="5">
<li>특정 케이스를 시작하기 전에 context 재생성</li>
</ol>
<div><pre><code><span>@DirtiesContext</span><span>(</span>methodMode <span>=</span> BEFORE_METHOD<span>)</span>
<span>@Test</span>
<span>public</span> <span>void</span> <span>testProcessWhichRequiresFreshAppCtx</span><span>(</span><span>)</span> <span>{</span>
 <span>// 새로운 context가 필요한 어떤 로직</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="6">
<li>특정 케이스를 시작한 이후 context 재생성</li>
</ol>
<div><pre><code><span>@DirtiesContext</span>
<span>@Test</span>
<span>public</span> <span>void</span> <span>testProcessWhichDirtiesAppCtx</span><span>(</span><span>)</span> <span>{</span>
 <span>// context의 상태를 변경하는 어떤 로직</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><br>
<h2 id="_0605-requirenonnull"> 0605 - requireNonNull</h2>
<p>자바 7에 추가된 Objects 클레스에서 제공하는 Null 체크를 위한 메소드 이다. 파라미터로 입력된 값이 null 이라면 NPE(NullPointerException)가 발생하고, 그렇지 않다면 입력값을 그대로 반환하는 간단한 메소이이다. requireNonNull은 아래와 같이 세가지로 오버로딩 되어있다.</p>
<table>
<thead>
<tr>
<th>리턴타입</th>
<th>메소드</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>requireNonNull(T obj)</td>
</tr>
<tr>
<td>T</td>
<td>requireNonNull(T obj, String message)</td>
</tr>
<tr>
<td>T</td>
<td>requireNonNull(T obj, Supplier msgSupplier)</td>
</tr>
</tbody>
</table>
<p>첫번째 메소드는 null을 전달하면 메세지가 비어있는 NPE 예외를 던진다,</p>
<div><pre><code><span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span><span>null</span><span>)</span><span>;</span>
<span>// java.lang.NullPointerException</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>두번쨰 메소드는 null을 전달하면, 두번째 파라미터로 전달한 문자열을 메세지로 갖는 NPE 예외를 던진다.</p>
<div><pre><code><span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span><span>null</span><span>,</span> <span>"null은 전달될 수 없습니다!"</span><span>)</span><span>;</span>
<span>// java.lang.NullPointerException: null은 전달될 수 없습니다!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>세번째 메소드는 null을 전달하면, 두번째 파라미터로 전달한 Supplier를 구현한 익명 함수의 반환값을 메세지로 갖는 NPE 예외를 던진다.</p>
<div><pre><code><span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span><span>null</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>"null은 전달될 수 없습니다!"</span><span>)</span><span>;</span>
<span>// java.lang.NullPointerException: null은 전달될 수 없습니다!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="requirenonnull을-사용하는-이유"> requireNonNull을 사용하는 이유</h4>
<ul>
<li>빠른 실패 (Fail-Fast)<br>
디버깅을 쉽게하기 위해서는 문제가 발생한 경우 즉각적으로 감지할 필요가 있다. 문제의 원인과 문제의 발생 지점이 물리적으로 떨어져 있다면 디버깅하기 어렵다.</li>
<li>명시성과 가독성</li>
</ul>
]]></content:encoded>
      <enclosure url="https://velog.velcdn.com/images/yyy96/post/df3b213b-8121-4e6e-9b5d-48b489512fce/image.png" type="image/png"/>
    </item>
    <item>
      <title>0606 ~ 0619</title>
      <link>ahnjs/TIL/2022/0606/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0606/</guid>
      <source url="ahnjs/TIL/rss.xml">0606 ~ 0619</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0606-0619"> 0606 ~ 0619</h1>
<h2 id="_0610-테스트-더블-test-double"> 0610 - 테스트 더블 (Test Double)</h2>
<h3 id="테스트-더블-test-double-이란"> 테스트 더블(Test Double)이란?</h3>
<p>xUnit Test Patterns의 저자인 제라드 메스자로스가 만든 용어로 테스트를 진행하기 어려운 경우 이를 대신해 테스트를 진행할 수 있도록 만들어주는 객체를 말한다.</p>
<p>예를 들어 우리가 데이터베이스로부터 조회한 값을 연산하는 로직을 구현했다고 하자. 해당 로직을 테스트하기 위해선 항상 데이터베이스의 영향을 받을 것이고, 이는 데이터베이스의 상태에 따라 다른 결과를 유발할 수도 있다.</p>
<p>이렇게 테스트하려는 객체와 연관된 객체를 사용하기가 어렵고 모호할 때 대신 해줄 수 있는 객체를 테스트 더블이라 한다.</p>
<h3 id="테스트-더블의-종류"> 테스트 더블의 종류</h3>
<p>테스트 더블은 크게 Dummy, Fake, Stub, Spy, Mock으로 나뉜다.</p>
<h4 id="_1-dummy"> 1. Dummy</h4>
<ul>
<li>가장 기본적인 테스트 더블이다.</li>
<li>인스턴스화 된 객체가 필요하지만 기능은 필요하지 않은 경우에 사용한다.</li>
<li>Dummy 객체의 메서드가 호출되었을 때 정상 동작은 보장하지 않는다.</li>
<li>객체는 전달되지만 사용되지 않는 객체이다.</li>
</ul>
<p>정리하면 인스턴스화된 객체가 필요해서 구현한 가짜 객체일 뿐이고, 생성된 Dummy 객체는 정상적인 동작을 보장하지 않는다.</p>
<div><pre><code><span>public</span> <span>interface</span> <span>PringWarning</span> <span>{</span>
    <span>void</span> <span>print</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>PrintWarningDummy</span> <span>implements</span> <span>PrintWarning</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>print</span><span>(</span><span>)</span> <span>{</span>
        <span>// 아무런 동작을 하지 않는다.</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>실제 객체는 PrintWarning 인터페이스의 구현체를 필요하지만, 특정 테스트에서는 해당 구현체의 동작이 전혀 필요하지 않을 수 있다. 실제 객체가 로그용 경고만 출력한다면 테스트 환경에서는 전혀 필요 없기 때문이다.<br>
이런 경우에는 print()가 아무런 동작을 하지 않아도 테스트에는 영향을 미치지 않는다.<br>
이처럼 동작하지 않아도 테스트에는 영향을 미치지 않는 객체를 Dummy 객체라고 한다.</p>
<h4 id="_2-fake"> 2. Fake</h4>
<ul>
<li>복잡한 로직이나 객체 내부에서 필요로 하는 다른 외부 객체들의 동작을 단순화하여 구현한 객체이다.</li>
<li>동작의 구현을 가지고 있지만 실제 프로덕션에는 적합하지 않은 객체이다.</li>
</ul>
<p>정리하면 동작은 하지만 실제 사용되는 객체처럼 정교하게 동작하지는 않는 객체를 말한다.</p>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>User</span> <span>{</span>
    <span>@Id</span>
    <span>private</span> <span>Long</span> id<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>
    
    <span>protected</span> <span>User</span><span>(</span><span>)</span> <span>{</span><span>}</span>
    
    <span>public</span> <span>User</span><span>(</span><span>Long</span> id<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>id <span>=</span> id<span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>Long</span> <span>getId</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>id<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>name<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>UserRepository</span> <span>{</span>
    <span>void</span> <span>save</span><span>(</span><span>User</span> user<span>)</span><span>;</span>
    <span>User</span> <span>findById</span><span>(</span><span>long</span> id<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>FakeUserRepository</span> <span>implements</span> <span>UserRepository</span> <span>{</span>
    <span>private</span> <span>Collection</span><span><span>&lt;</span><span>User</span><span>></span></span> users <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>User</span> user<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>findById</span><span>(</span>user<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            user<span>.</span><span>add</span><span>(</span>user<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>@Override</span>
    <span>public</span> <span>User</span> <span>findById</span><span>(</span><span>long</span> id<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>User</span> user <span>:</span> users<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>user<span>.</span><span>getId</span><span>(</span><span>)</span> <span>==</span> id<span>)</span> <span>{</span>
                <span>return</span> user<span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>테스트해야 하는 객체가 데이터베이스와 연관되어 있다고 가정한다.</p>
<p>그럴 경우 실제 데이터베이스를 연결해서 테스트해야 하지만, 실제 데이터베이스 대신 가짜 데이터베이스 역할을 하는 FakeUserRepository를 만들어 테스트객체에 주입하는 방법도 있다. 이렇게 하면 테스트 객체는 데이터베이스에 의존하지 않으면서도 동일하게 동작을하는 가짜 데이터베이스를 가지게 된다.</p>
<h4 id="_3-stub"> 3. Stub</h4>
<ul>
<li>Dummy 객체가 실제로 동작하는 것 처럼 보이게 만들어 놓은 객체이다.</li>
<li>인터페이스 또는 기본 클래스가 최소한으로 구현된 상태이다.</li>
<li>테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다.</li>
</ul>
<p>정리하면 테스트를 위해 프로그래밍된 내용에 대해서만 준비된 결과를 제공하는 객체이다.</p>
<div><pre><code><span>public</span> <span>class</span> <span>StubUserRepository</span> <span>implements</span> <span>UserRepository</span> <span>{</span>
    <span>// ...</span>
    <span>@Override</span>
    <span>public</span> <span>User</span> <span>findById</span><span>(</span><span>long</span> id<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>User</span><span>(</span>id<span>,</span> <span>"Test User"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>위의 코드처럼 StubUserRepository는 findByID() 메서드를 사용하면 언제나 동일한 id값에 TestUser라는 이름을 가진 User 인스턴스를 반환받는다.<br>
테스트 환경에서 User 인스턴스의 name을 Test User만 받기를 원하는 경우 이처럼 동작하는 객체를 만들어 사용할 수 있다.<br>
물론 이러한 방식의 단점은 테스트가 수정될 경우 Stub 객체도 함께 수정해야 하는 단점이 있다.<br>
우리가 테스트에서 자주 사용하는 Mockito 프레임워크도 Stub와 같은 역할을 해준다.<br>
이처럼 테스트를 위해 의도한 결과만 반환되도록 하기 위한 객체가 Stub이다.</p>
<h4 id="_4-spy"> 4. Spy</h4>
<ul>
<li>Stub의 역할을 가지면서 호출된 내용에 대해 약간의 정보를 기록한다.</li>
<li>테스트 더블로 구현된 객체에 자기 자신이 호출 되었을 때 확인이 필요한 부분을 기록하도록 구현한다.</li>
<li>실체 객체처럼 동작시킬 수도 있고, 필요한 부분에 대해서는 Stub로 만들어서 동작을 지정할 수도 있다.</li>
</ul>
<p>정리하면 실제 객체로도 사용할 수 있고 Stub 객체로도 활용할 수 있으며 필요한경우 특정 메서드가 제대로 호출되었는지 여부를 확인할 수 있다.</p>
<div><pre><code><span>public</span> <span>class</span> <span>MailingService</span> <span>{</span>
    <span>private</span> <span>int</span> sendMailCount <span>=</span> <span>0</span><span>;</span>
    <span>private</span> <span>Collection</span><span><span>&lt;</span><span>Mail</span><span>></span></span> mails <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>sendMail</span><span>(</span><span>Mail</span> mail<span>)</span> <span>{</span>
        sendMailCount<span>++</span><span>;</span>
        mails<span>.</span><span>add</span><span>(</span>mail<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>long</span> <span>getSendMailCount</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> sendMailCount<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>MailingService는 sendMail을 호출할 때마다 보낸 메일을 저장하고 몇 번 보냈는지를 체크한다. 그리고 나중에 메일을 보낸 횟수를 물어볼 때 sendMailCount를 반환한다.<br>
이처럼 자기 자신이 호출된 상황을 확인할 수 있는 객체가 Spy이다.<br>
이 또한 Mockito 프레임워크의 verify() 메서드가 같은 역할을 한다.</p>
<h4 id="_5-mock"> 5. Mock</h4>
<ul>
<li>호출에 대한 기대를 명세하고 내용에 따라 동작하도록 프로그래밍 된 객체.</li>
<li>Mockito 프레임워크가 대표적인 Mock 프레임워크.</li>
</ul>
<div><pre><code><span>@ExtendWith</span><span>(</span><span>MockitoExtension</span><span>.</span><span>class</span><span>)</span>
<span>public</span> <span>class</span> <span>UserServiceTest</span> <span>{</span>
    <span>@Mock</span>
    <span>private</span> <span>UserRepository</span> userRepository<span>;</span>
    
    <span>@Test</span>
    <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>
        <span>when</span><span>(</span>userRepository<span>.</span><span>findById</span><span>(</span><span>anyLong</span><span>(</span><span>)</span><span>)</span><span>)</span><span>.</span><span>thenReturn</span><span>(</span><span>new</span> <span>User</span><span>(</span><span>1</span><span>,</span> <span>"Test User"</span><span>)</span><span>)</span><span>;</span>
        
        <span>User</span> actual <span>=</span> userService<span>.</span><span>findById</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>assertThat</span><span>(</span>actual<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>1</span><span>)</span><span>;</span>
        <span>assertThat</span><span>(</span>actual<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"Test User"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="_0613-orphanremoval"> 0613 - orphanRemoval</h2>
<p>부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제해주는 기능이다.</p>
<div><pre><code><span>@Entity</span>
<span>public</span> <span>class</span> <span>Parent</span> <span>{</span>

    <span>@Id</span>
    <span>@GeneratedValue</span>
    <span>private</span> <span>Long</span> id<span>;</span>

    <span>private</span> <span>String</span> username<span>;</span>

    <span>@OneToMany</span><span>(</span>mappedBy <span>=</span> <span>"parent"</span><span>,</span> cascade <span>=</span> <span>CascadeType</span><span>.</span>ALL<span>,</span> orphanRemoval <span>=</span> <span>true</span><span>)</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Child</span><span>></span></span> childList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>orphanRemoval가 true 시</p>
<div><pre><code><span>Parent</span> parent1 <span>=</span> em<span>.</span><span>find</span><span>(</span><span>Parent</span><span>.</span><span>class</span><span>,</span> parent<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>
parent1<span>.</span><span>getChildList</span><span>(</span><span>)</span><span>.</span><span>remove</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// delete 쿼리나간다.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>자동으로 delete 쿼리가 나간다.</p>
<ul>
<li>이 속성은 참조하는 곳이 하나일 때만 사용해야 한다.</li>
<li>특정 엔티티가 개인 소유할 때만 사용해야 한다.</li>
<li>@OneToOne과 @OneToMany에서만 사용이 가능하다.</li>
</ul>
<p>CascadeType.ALL + orphanRemovel=true<br>
이 두개를 같이 사용하게 되면 부모 엔티티가 자식의 생명주기를 모두 관리할 수 있게 된다.</p>
<br>
<h2 id="_0615-cqrs"> 0615 - CQRS</h2>
<h3 id="cqrs-아키텍처란"> CQRS 아키텍처란?</h3>
<p><img src="https://velog.velcdn.com/images/sangmin7648/post/306d4956-1d8b-474f-b3b9-431b0cb993ed/image.png" alt="image"></p>
<blockquote>
<p>명령(시스템 데이터 변경) 역할을 수행하는 구성 요소와 쿼리(시스템 데이터 조회) 역할을 구새항하는 구성 요소를 나누는 아키텍처</p>
</blockquote>
<p>시스템 데이터를 변경하는 코드와 시스템 데이터를 조회하는 코드를 따로 만드는 것, 구현방식이나 시스템 규모에 따라서 DB를 나누기도하고 프로세스를 나누기도 함</p>
<ul>
<li>Command : 명령
<ul>
<li>시스템 데이터 변경</li>
<li>ex) 주문 생성, 수정, 취소</li>
</ul>
</li>
<li>Query : 조회
<ul>
<li>시스템 데이터 조회</li>
<li>ex) 주문 조회</li>
</ul>
</li>
<li>Responsibility : 책임
<ul>
<li>구성 요소의 역할</li>
<li>구성 요소 ex) 클래스, 함수, 모듈, 패키지, 웹서버, DB 등</li>
</ul>
</li>
<li>Segregation : 역할에 따라 구성 요소 나누기</li>
</ul>
<h3 id="단일-모델의-단점"> 단일 모델의 단점</h3>
<blockquote>
<p>명령과 쿼리를 구분해 피할 수 있는 문제들</p>
</blockquote>
<p><img src="https://velog.velcdn.com/images%2Fsangmin7648%2Fpost%2F955c1e24-1f0a-49db-a913-eb66cb07e0f0%2Fimage.png" alt="image"></p>
<ul>
<li>기능 추가에 따라 코드의 책임이 모호해지고, 기능마다 다른 테이블에 의존하게 된다</li>
<li>명령은 한 영역의 데이터를 다루는데 반해 쿼리는 여러 영역의 데이터를 사용한다.</li>
<li>명령과 쿼리는 코드 변경 빈도와 사용자가 다르다. 서로 다른 이유로 모델의 코드가 바뀐다는 것은 책임의 분리가 적절하지 않다는 것이다.</li>
<li>기능마다 요구 성능이 다르다. 단일 모델은 기능에 맞는 다양한 성능 향상 기법 적용이 어렵다.
<ul>
<li>ex) 명령 : 사용자 주문 기능, 쿼리 : 백오피스 주문 목록 조회</li>
</ul>
</li>
</ul>
<h3 id="cqrs의-구현"> CQRS의 구현</h3>
<h4 id="같은-프로세스-같은-dbms"> 같은 프로세스, 같은 DBMS</h4>
<p><img src="https://velog.velcdn.com/images%2Fsangmin7648%2Fpost%2F10c1fe6b-f5c6-4cff-b5ea-6ac29da9efc1%2Fimage.png" alt="image"></p>
<ul>
<li>코드 수준에서만 명령과 쿼리가 분리된다</li>
<li>데이터의 동일성이 보장된다</li>
</ul>
<h4 id="같은-프로세스-같은-dbms-다른-테이블"> 같은 프로세스, 같은 DBMS, 다른 테이블</h4>
<p><img src="https://velog.velcdn.com/images%2Fsangmin7648%2Fpost%2Fb3dd095d-34b8-4050-8dbb-9fd5cabc5bd6%2Fimage.png" alt="Image"></p>
<ul>
<li>쿼리 전용 테이블을 사용한다</li>
<li>코드 수준, 데이터 수준에서 명령과 쿼리가 분리된다</li>
<li>명령이 데이터를 변경할때, 쿼리 전용 테이블도 수정해야한다</li>
</ul>
<h4 id="같은-프로세스-다른-dbms"> 같은 프로세스, 다른 DBMS</h4>
<p><img src="https://velog.velcdn.com/images%2Fsangmin7648%2Fpost%2F4374065b-f002-4f23-8b0f-967fcade226e%2Fimage.png" alt="image"></p>
<ul>
<li>Redis를 캐시로 하고 쿼리 DB로 사용하는 경우를 생각해볼 수 있다</li>
</ul>
<h4 id="다른-프로세스-다른-dbms"> 다른 프로세스, 다른 DBMS</h4>
<p>![image]</p>
<ul>
<li>MSA를 생각해볼 수 있다</li>
</ul>
<h3 id="_3가지-변경-전파-전략"> 3가지 변경 전파 전략</h3>
<blockquote>
<p>CQRS 아키텍처에서 여러 DBMS를 사용하게 된다면 변경 전파 전략도 수립해야 한다</p>
</blockquote>
<h4 id="명령이-쿼리-dbms를-수정"> 명령이 쿼리 DBMS를 수정</h4>
<ul>
<li>구현이 단순</li>
<li>쿼리 DB 장애시 데이터 유실 가능성이 있다</li>
<li>명령 기능이 쿼리 DB까지 접근하기 때문에 명령 기능의 에러 가능성이 높다</li>
</ul>
<h4 id="변경-내용-기록-후-전파기-사용"> 변경 내용 기록 후, 전파기 사용</h4>
<ul>
<li>명령 DB에 변경 내용 테이블을 관리해야한다</li>
<li>데이터 변경과 변경 내용을 하나의 트랜잭션으로 처리할 수 있어 데이터 유실 방지가 가능하다</li>
<li>전파기를 구현해야한다</li>
</ul>
<h4 id="db가-제공하는-cdc-사용"> DB가 제공하는 CDC 사용</h4>
<ul>
<li>CDC : 데이터베이스에 있는 데이터의 변경을 파악하고 추적하는 소프트웨어 프로세스</li>
<li>명령 DB 바이너리 로그를 읽어 변경을 파악하고, 쿼리 DB에 전달할 수 있다</li>
<li>명령 코드가 변경 내용을 관리할 필요가 없다</li>
</ul>
<br>
<h2 id="_0616-msa와-soa의-차이"> 0616 - MSA와 SOA의 차이</h2>
<h3 id="soa-msa란"> SOA, MSA란?</h3>
<blockquote>
<p>SOA는 서비스 지향 설계 방식(Service Oriented Architecture)<br>
SOA는 서비스 단위로 개발을 하고, 개발된 서비스들을 공유함으로써 재가용성을 늘리고 유연성을 확보하는 것을 목표</p>
</blockquote>
<blockquote>
<p>MSA는 마이크로 서비스 설계 방식(Micro Service Architecture)<br>
MSA 또한 아주 작은 단위의 서비스로 소프트웨어를 구성함으로써 민첩하고 유연한 설계하는 것을 목표</p>
</blockquote>
<h4 id="공유-지향점"> 공유 지향점</h4>
<p><img src="https://velog.velcdn.com/images/hwang95/post/a979a2bc-d5c3-4f70-8249-bfd6cc016b10/soamsa.PNG" alt="image"></p>
<p>SOA는 비지니스 측면에서의 서비스 재사용성을 중요시하여 ESB(Enterprise Service Bus)라는 서비스 채널 이용 -&gt; 서비스 공유, 재사용</p>
<p>MSA는 한 가지 작은 서비스에 집중하여 서비스 공유하지 않고 독립적 실행</p>
<ul>
<li>SOA : 재사용을 통한 비용 절감</li>
<li>MSA : 서비스 간의 결합도를 낮추어 변화에 능동적으로 대응</li>
</ul>
<h4 id="기술-방식"> 기술 방식</h4>
<ul>
<li>SOA는 공통의 서비스를 esb에 모아 사업 측면에서 공통 서비스 형식으로 서비스 제공</li>
<li>MSA는 각 독립된 서비스가 노출된 REST API를 사용</li>
<li>SOA는 서비스를 개발하고 최대한 재가용</li>
<li>MSA는 서비스가 공유되기 보다 독립적으로 실행되는 것을 지향</li>
</ul>
<br>
<h2 id="_0618-자바-테스트-격리"> 0618 - 자바 테스트 격리</h2>
<h3 id="테스트-격리란"> 테스트 격리란?</h3>
<p>테스트는 순서에 상관없이 독립적으로 실행되며 결정적으로 수행되어야 한다. 테스트를 서로 격리하여 한 테스트를 실행하여도 다른 테스트에 영향을 주지 않도록 해야한다.</p>
<h3 id="계층별-테스트"> 계층별 테스트</h3>
<p>데이터들이 공유되기 때문에 불완전한 테스트를 작성하게 된다. 따라서 데이터베이스를 얼마나 의존하지 않고 테스트를 작성할지 또는 데이터 베이스 상태를 테스트 이전으로 돌릴지에 대해서 신경을 써야 한다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FoxF8l%2FbtqUzwxi3Jt%2F7NE1JMAJPb7XMAyFJ2y6kk%2Fimg.png" alt="image"></p>
<h4 id="domain-pojo-계층"> - Domain(POJO) 계층</h4>
<ul>
<li>애플리케이션의 POJO(Model, Utils, etc...)는 JUnit으로 테스트</li>
<li>객체는 new 연산자(또는 빌더)로 간단히 인스턴스화</li>
<li>각각의 테스트가 실행되기 전에 @BeforeEach에서 인스턴스 초기화</li>
<li>데이터베이스를 사용하지 않기 때문에 격리를 걱정할 필요 없음</li>
</ul>
<div><pre><code><span>private</span> <span>Question</span> question<span>;</span>

<span>@BeforeEach</span>
<span>void</span> <span>setUp</span><span>(</span><span>)</span><span>{</span>
    question <span>=</span> <span>Question</span><span>.</span><span>builder</span><span>(</span><span>)</span>
        <span>.</span><span>userId</span><span>(</span><span>1L</span><span>)</span>
        <span>.</span><span>title</span><span>(</span>TEST_QUETION_TITLE<span>)</span>
        <span>.</span><span>content</span><span>(</span>TEST_QUESTION_CONTENT<span>)</span>
        <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>@DisplayName</span><span>(</span><span>"조회수 초기값 확인"</span><span>)</span>
<span>@Test</span>
<span>void</span> <span>initValueOfVisits</span><span>(</span><span>)</span><span>{</span>
    <span>assertThat</span><span>(</span>question<span>.</span><span>getVisits</span><span>(</span><span>)</span><span>.</span><span>getVisitCount</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>0L</span><span>)</span><span>;</span>
<span>}</span>

<span>@DisplayName</span><span>(</span><span>"조회수 증가"</span><span>)</span>
<span>@Test</span>
<span>void</span> <span>increaseVisits</span><span>(</span><span>)</span><span>{</span>
    question<span>.</span><span>increaseVisits</span><span>(</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>question<span>.</span><span>getVisits</span><span>(</span><span>)</span><span>.</span><span>getVisitCount</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>1L</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id="service-계층"> - Service 계층</h4>
<ul>
<li>실질적인 비즈니스 로직을 수행</li>
<li>실제 데이터베이스 사용</li>
<li>트랜잭션이 끝나면 데이터베이스 상태 변경</li>
<li>테스트 간 격리가 필요</li>
<li>실제 데이터베이스를 사용하면서 계층구조로 이루어져있기 때문에 사실상 통합 테스트가 되버림</li>
<li>@Transactional을 사용해서 테스트가 종료되면 rollback가능</li>
<li>Mockito를 이용하면 실제 데이터베이스를 사용하지 않기 때문에 테스트 격리를 고민할 필요가 없다.</li>
</ul>
<h4 id="controller-계층"> - Controller 계층</h4>
<ul>
<li>@SpringBootTest
<ul>
<li>Spring IoC로 실제 컨트롤러 빈을 사용해서 테스트</li>
<li>실제 데이터베이스 사용</li>
<li>통합 테스트</li>
</ul>
</li>
<li>@WebMvcTest
<ul>
<li>MockMvc RestAPI 클라이언트 테스트 도구 사용</li>
<li>데이터베이스를 사용하지 않고 단위 테스트 수행</li>
</ul>
</li>
</ul>
<h4 id="repository-계층"> - Repository 계층</h4>
<ul>
<li>@DataJpaTest
<ul>
<li>Slice Test 진행</li>
<li>In Memory로 테스트 수행</li>
<li>자동으로 @Transactional(rollback=true)이 사용됨</li>
</ul>
</li>
</ul>
<h3 id="인수-테스트"> 인수 테스트</h3>
<ul>
<li>시스템이 실제 운영 환경에서 사용될 준비가 되었는지 최종적으로 확인하는 단계</li>
<li>실제 운영환경에 맞게 서버를 띄우고 데이터베이스를 사용</li>
<li>테스트 격리를 신경쓰지 않으면 테스트가 실패하기 쉬움</li>
<li>테스트 단위가 커서 한번 실패하면 디버깅하기 까다로움</li>
<li>Mock 객체가 아닌 실제 빈을 사용</li>
</ul>
<h4 id="인수테스트-방법"> 인수테스트 방법</h4>
<ol>
<li>
<p>@Transactional : 인수 테스트에서 제대로 작동하지 않음. 요청을 보내는 http client 쪽과 실제 로직을 수행하는 서버로직이 서로 다른 쓰레드에서 실행된다. 테스트 코드에서 어노테이션을 롤백 전략으로 해두어도, 다른 스레드에서 실행되는 서버 사이드 트랜잭션은 그 테스트 코드의 영향을 받지 않고 데이터베이스가 변하게 된다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRU1t0%2FbtqUBvdOrYi%2Fw2kwi1Q5BZ7IWdNOKpQPa1%2Fimg.png" alt="image"></p>
</li>
<li>
<p>매번 테스트 종료시 생성한 픽스처 및 데이터 삭제
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdnPh4v%2FbtqUtWqaFlR%2FKRtQQHcO9GKB2uDLfmNVn1%2Fimg.png" alt="image"></p>
</li>
<li>
<p>매번 테스트 종료시 테이블 Truncate</p>
</li>
</ol>
<ul>
<li>
<p>Delete보다 Truncate가 좋은 이유</p>
<ul>
<li>트랜잭션 로그 공간을 적게 차지</li>
<li>쿼리 실행시 행단위로 락을 걸지 않음</li>
</ul>
</li>
<li>
<p>3-1 @Sql로 SQL 파일 실행
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcIsYKn%2FbtqUuNmfBa6%2FfkYV5NnPOrydLHdzscl761%2Fimg.png" alt="image"></p>
</li>
<li>
<p><code>3-2 EntityManager 이용</code>(보스독님이 추천하는 방식)
엔티티 매니저로 쿼리를 직접 만들어서 실행하는 방식. 엔티티에 있는 테이블 이름을 가지고온 후 리스트에 저장
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FM127C%2FbtqUBvESPMW%2FEAMBpFpIQjbK6k3wATWgQK%2Fimg.png" alt="image"></p>
</li>
</ul>
<p>데이터 베이스를 주입 받고 테스트를 실행하기 직전 @BeforeEach에서 테이블 이름을 조사한 후 Truncate를 실행. 이렇게 만들어 두면 추후 엔티티가 추가되거나 삭제될 때 동적으로 테이블을 조사하기 때문에 테스트 격리에 투입되는 비용을 줄일 수 있음</p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOo8nJ%2FbtqUvDKsjGT%2FDan2LsPFp9BJhaGHkokmKk%2Fimg.png" alt="image"></p>
<h3 id="정리"> 정리</h3>
<ul>
<li>잘격리된 테스트는 유지보수가 수월</li>
<li>더욱 안전한 테스트 작성으로 코드의 품질 보장</li>
</ul>
]]></content:encoded>
      <enclosure url="https://velog.velcdn.com/images/sangmin7648/post/306d4956-1d8b-474f-b3b9-431b0cb993ed/image.png" type="image/png"/>
    </item>
    <item>
      <title>0627 ~ 0703</title>
      <link>ahnjs/TIL/2022/0627/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0627/</guid>
      <source url="ahnjs/TIL/rss.xml">0627 ~ 0703</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0627-0703"> 0627 ~ 0703</h1>
<h2 id="_0627-객체지향-생활-체조-원칙-9가지"> 0627 - 객체지향 생활 체조 원칙 9가지</h2>
<h4 id="_1-한-메서드에-오직-한-단계의-들여쓰기만-한다"> 1. 한 메서드에 오직 한 단계의 들여쓰기만 한다.</h4>
<p>한 메서드에 들여쓰기가 여러 개 존재한다면, 해당 메서드는 여러가지 일을 하고 있다고 봐도 무관하다.<br>
메서드는 맡은 일이 적을수록 재사용성이 높고 디버깅도 용이하다.</p>
<h4 id="_2-else-키워드를-쓰지-않는다"> 2. else 키워드를 쓰지 않는다.</h4>
<p>조건문은 복제의 원인이 되기도 하며 가독성 또한 좋지 않다.<br>
디자인 패턴의 Strategy 패턴 - 상태 인라인(status inline)의 분기를 막기 위한 다형성(polymorphism) 예제가 있다.<br>
상태에 대한 분기가 몇 군데 걸쳐 중복돼 있을 때 Strategy 패턴은 특히 유용<br>
간단한 경우엔 guard clause(보호 구문) 사용 : if에 return을 쓸 것(early return) - 단, 많이 쓰면 간결함을 해칠 수 있다.</p>
<h4 id="_3-모든-원시값과-문자열을-포장-wrap-한다"> 3. 모든 원시값과 문자열을 포장(wrap)한다.</h4>
<p>원시형 변수로는 컴파일러가 의미적으로 맞는 프로그램 작성을 안내할 수 없다. (예 - 년도에 대한 유효성 검사)<br>
포장한 객체로라면 아주 사소하더라도 컴파일러와 개발자에게 해당 값이 어떤 값이며 왜 쓰는지에 대해 정보를 전달할 수 있다.<br>
또한 시간이나 돈처럼 작은 단위를 포장한 객체의 경우엔, 행위(메서드)를 놓을 곳을 마련해준다.</p>
<h4 id="_4-한-줄에-점을-하나만-찍는다"> 4. 한 줄에 점을 하나만 찍는다.</h4>
<p>(스트림 등 체이닝하는 일부를 제외)<br>
어느 코드 한 곳에서 점이 둘 이상 있다면, 해당 부분을 다시 리팩토링 해야 한다.</p>
<ul>
<li>어쩌면 다른 두 개의 객체를 동시 조작하고 있는 것일 수도 있다.</li>
</ul>
<p>디미터(Demeter)의 법칙 : &quot;친구하고만 대화하라&quot;<br>
자신 소유의 객체, 자신이 생성한 객체, 그리고 누군가 준(파라미터로) 객체에만 메시지를 보낼 것</p>
<ul>
<li>그렇지 않을 경우, 다른 객체에 너무 깊숙이 관여하게 된다 : 캡슐화를 어기는 것</li>
</ul>
<p>메시지를 받는 객체는 자신의 속을 오픈하기보다는, 작업을 해주도록 해야 한다.</p>
<h4 id="_5-줄여쓰지-않는다"> 5. 줄여쓰지 않는다.</h4>
<p>과도한 축약은 코드 가독성을 저해한다. 무조건 짧다고 좋은 것은 아니다.<br>
메서드의 이름이 긴 이유 중 하나는, 책임을 너무 많이 갖고 있거나, 적절한 클래스의 아래에 위치하지 않아서 일 수 있다.</p>
<h4 id="_6-entity를-작게-유지한다"> 6. entity를 작게 유지한다.</h4>
<p>50줄 이상 되는 클래스 또는 10개 파일 이상의 패키지는 없어야 한다.<br>
[ 클래스 ]</p>
<ul>
<li>50줄 이상인 경우 보통 클래스가 한 가지 일만 하지 않는다.</li>
<li>50줄 정도면 스크롤을 내리지 않아도 된다.</li>
</ul>
<p>[ 패키지 ]</p>
<ul>
<li>하나의 목적을 달성하기 위한 연관된 클래스들의 모임.</li>
<li>작게 유지하면 패키지가 진정한 정체성을 가지게 된다.</li>
</ul>
<h4 id="_7-2개-이상의-인스턴스-변수를-가진-클래스를-쓰지-않는다"> 7. 2개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.</h4>
<p>새로운 인스턴스 변수를 가진 클래스는 응집도가 떨어진다. 많은 인스턴스 변수를 가진 클래스로 응집력있는 단일 작업을 설명할 수 있는 경우는 거의 없다.<br>
인스턴스 변수의 분해는 여러 개의 관련 인스턴스 변수의 공통성을 이해하게 하여 자료구조형으로 묶어 일급 컬렉션으로 생성할 수 있게 해준다.<br>
인스턴스 변수들의 집합을 갖고 있는 것에서, 협력 객체(일급 컬렉션/Wrapper 객체)의 계층 구조로 분해하면 더 효율적인 객체 모델이 될 수 있다. 복잡하고 덩치 큰 객체를 이해하는 것은 어렵지만, 분해하면 간단해진다.<br>
분해하는 것이 어렵거나 막막하다면, 객체를 상관 관계가 있는 반(half)씩 나누거나, 인스턴스 변수를 둘 골라서 그로부터 하나의 객체를 만드는 등을 하는 것을 추천한다.</p>
<h4 id="_8-일급-컬렉션을-쓴다"> 8. 일급 컬렉션을 쓴다.</h4>
<p>콜렉션(Collection)을 가진 클래스는 콜렉션 외에는 다른 멤버 변수를 가지면 안된다는 원칙이다. 어떤 데이터 세트(Set)를 가지고 있는데 조작이 필요하다면 그 데이터에만 집중된 클래스를 만들어야 한다.</p>
<h4 id="_9-getter-setter-property를-쓰지-않는다"> 9. getter/setter/property를 쓰지 않는다.</h4>
<p>이 규칙은 &quot;말은 하되, 묻지는 말라.(Tell, don't ask)&quot;로 대변된다. 객체의 상태를 가져오는 접근자(accessor)를 사용하는 것은 괜찮지만, 객체 바깥에서 그 결과값을 사용해 객체에 대한 결정을 내리는 것은 안된다. 한 객체의 상태에 대한 결정은 어떤 것이든 그 객체 안에서만 이루어져야 한다.</p>
<br>
<h2 id="_0701-드라이빙-테이블-driving-table"> 0701 - 드라이빙 테이블(DRIVING TABLE)</h2>
<h3 id="드라이빙-테이블이란"> 드라이빙 테이블이란?</h3>
<blockquote>
<p>JOIN시 먼저 액세스 돼서 ACCESS PATH를 주도하는 테이블을 드라이빙 테이블이라고 한다.</p>
</blockquote>
<p>즉, 조인시 먼저 액세스되는 쪽은 드라이빙 테이블(DRIVING TABLE, OUTER TABLE)이라고 하며, 나중에 액세스 되는 테이블을 드리븐 테이블(DRIVEN TABLE, INNER TABLE)이라고 한다.</p>
<p>인덱스의 존재 및 우선순위 혹은 FROM절에서의 TABLE 지정 순서에 영향을 받으며 어느 테이블이 먼저 엑세스되느냐에 따라 속도의 차이가 크게 날 수 있으므로 많은 양의 데이터를 다룰 때, 드라이빙 테이블은 매우 즁요하다</p>
<div><pre><code>조건을 만족하는 5000만 건인 A테이블과
조건을 만족하는 1000건인 B테이블과
조인 시 드라이빙 순서에 따라 속도의 확연한 차이가 있다.
 
5000만 건을 먼저 드라이빙하면
5000만 번을 반복하며 B테이블 탐색하며,
 
1000건인 B가 먼저 드라이빙되면
최대 1000번 A테이블 탐색이 반복이 된다.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>즉, 작업 대상이 되는 행(rows)의 수가 적은 테이블부터 액세스 되어야 전체 탐색이 줄어든다.</p>
<h3 id="드라이빙-테이블-결정규칙"> 드라이빙 테이블 결정규칙</h3>
<ol>
<li>규칙 기반 옵티마이저(Rule-Based Optimizer, RBO)에서는 연산자, 인덱스의 유무, 조건절의 형태 등 정해진 규칙의 우선순위에 따라 실행계획을 생성한다.</li>
</ol>
<ul>
<li>인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선순위가 높음</li>
<li>조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재할 때, 우선순위가 높은 테이블을 선ㅌ택</li>
<li>조인 칼럼에만 인덱스가 존재하는 경우에는 인덱스가 없는 테이블을 먼저 선택하여 조인 수행</li>
<li>만약 조인 테이블의 우선순위가 동일하지 않다면, FROM 절에 나열된 테이블의 역순으로 수행</li>
</ul>
<ol start="2">
<li>비용기반 옵티마이저(Cost-Based Optimizer, CBO)는 규칙의 우선순위가 아닌 쿼리를 수행하는데 소요되는 예상 비용을 바탕으로 실행계획을 생성한다. 통계정보, DBMS 설정정보, DBMS 버전 등의 차이로 인해 똑같은 SQL문이라도 서로 다른 실행계획인 생성 될 수 있다</li>
</ol>
<div><pre><code><span>SELECT</span> <span>*</span> 
<span>FROM</span> employees e<span>,</span> dept_emp de
<span>WHERE</span> e<span>.</span>emp_no<span>=</span>de<span>.</span>emp_no<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>이 두 테이블의 조인 쿼리에서 emp_no 칼럼과 dept_emp 테이블의 emp_no칼럼에 각각 인덱스가 있을 때와 없을 때의 조인순서를 비교해 보면 아래와 같다.</p>
<ol>
<li>
<p>두 칼럼 모두 각각 인덱스가 있는 경우<br>
옵티마이저의 판단으로 각 테이블의 통계 정보에 있는 레코드 건수에 따라 employees가 드라이빙 테이블이 될 수도 있고, dept_emp 테이블이 드라이빙 테이블이 될 수도 있다.</p>
</li>
<li>
<p>dept_emp.emp_no 에만 인덱스가 있는 경우<br>
employees 테이블의 반복된 풀 스캔을 막기 위해 employees 테이블을 드라이빙 테이블로 선택하고 인덱스가 있는 dept_emp 테이블을 드리븐 테이블로 조인을 수행하도록 실행 계획을 수립한다.</p>
</li>
<li>
<p>employees.emp_no에만 인덱스가 있는 경우<br>
dept_emp 테이블이 드리븐 테이블로 선택된다면 employees 테이블의 레코드 건수만큼 dept_emp 테이블을 풀 스캔해야만 &quot;e.emp_no=de.emp_no&quot; 조건에 일치하는 레코드를 찾을 수 있다. 그래서 옵티마이저는 항상 dept_emp 테이블을 드라이빙 테이블로, employees 테이블을 드리븐 테이블로 선택하게 된다.</p>
</li>
<li>
<p>두 칼럼 모두 인덱스가 없는 경우<br>
어느 테이블을 드라이빙으로 선택하더라도 드리븐 테이블의 풀 스캔 발생하기 떄문에 스캔되는 레코드 수에 따라 옵티마이저가 적절히 드라이빙 테이블을 선택하게 된다. 조인이 수행될때 양쪽 테이블의 칼럼에 모두 인덱스가 없을 때만 드리븐 테이블을 풀스캔한다. 나머지 경우에는 드라이빙 테이블을 풀 테이블 스캔을 사용할 수는 있어도 드리븐 테이블을 풀 테이블 스캔으로 접근하는 실행 계획은 옵티마이저가 거의 만들어내지 않는다.</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>0711 ~ 0717</title>
      <link>ahnjs/TIL/2022/0711/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0711/</guid>
      <source url="ahnjs/TIL/rss.xml">0711 ~ 0717</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0711-0717"> 0711 ~ 0717</h1>
<h2 id="_0711-attributeoverrides-매핑-정보-재정의"> 0711 - @AttributeOverrides 매핑 정보 재정의</h2>
<p>@MappedSuperclass를 통해 상속 받은 경우나 @Embedded를 통해 다른 객체를 필드에 선언한 경우 해당 엔티티에서는 다른 컬럼명을 사용하고 싶을 때가 있다. 이러한 경우에 사용할 수 있는 어노테이션이다.<br>
@AttributeOverride 혹은 @AttributeOverrides를 사용할 수 있으며, 사용 방법은 다음과 같다.</p>
<div><pre><code><span>@MappedSuperclass</span>
<span>public</span> <span>class</span> <span>Vehicle</span> <span>{</span>
    <span>@Id</span>
    <span>@GeneratedValue</span>
    <span>private</span> <span>Integer</span> id<span>;</span>
    <span>private</span> <span>String</span> identifier<span>;</span>
    <span>private</span> <span>Integer</span> numberOfWheels<span>;</span>
    
    <span>// standard getters and setters</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>@Entity</span>
<span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"identifier"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"VIN"</span><span>)</span><span>)</span>
<span>public</span> <span>class</span> <span>Car</span> <span>extends</span> <span>Vehicle</span> <span>{</span>
    <span>private</span> <span>String</span> model<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>

    <span>// standard getters and setters</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>부모 클래스(Vehicle)의 identifier 속성을 VIN으로 재정의하여 사용함</p>
<div><pre><code><span>@Entity</span>
<span>@AttributeOverrides</span><span>(</span><span>{</span>
	<span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"id"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"CAR_ID"</span><span>)</span><span>)</span>
	<span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"identifier"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"VIN"</span><span>)</span><span>)</span>
<span>}</span><span>)</span>
<span>public</span> <span>class</span> <span>Car</span> <span>extends</span> <span>Vehicle</span> <span>{</span>
    <span>private</span> <span>String</span> model<span>;</span>
    <span>private</span> <span>String</span> name<span>;</span>

    <span>// standard getters and setters</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>여러 필드를 재정의할 수 있다.</p>
<h4 id="임베디드-타입-속-임베디드-타입-속성-재정의하기"> 임베디드 타입 속 임베디드 타입 속성 재정의하기</h4>
<div><pre><code><span>@NoArgsConstructor</span><span>(</span>access <span>=</span> <span>AccessLevel</span><span>.</span>PROTECTED<span>)</span>
<span>@Entity</span>
<span>@Setter</span>
<span>@Getter</span>
<span>public</span> <span>class</span> <span>Member</span><span>{</span>

    <span>@Id</span> <span>@GeneratedValue</span>
    <span>@Column</span><span>(</span>name <span>=</span> <span>"MEMBER_ID"</span><span>)</span>
    <span>private</span> <span>Long</span> id<span>;</span>


    <span>private</span> <span>String</span> name<span>;</span>

    <span>@Embedded</span>
    <span>@AttributeOverrides</span><span>(</span><span>{</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"city"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"HOME_CITY"</span><span>)</span><span>)</span><span>,</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"street"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"HOME_STREET"</span><span>)</span><span>)</span><span>,</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"zipcode.zip"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"HOME_ZIP"</span><span>)</span><span>)</span><span>,</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"zipcode.plusFour"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"HOME_PLUS_FOUR"</span><span>)</span><span>)</span><span>,</span>
    <span>}</span><span>)</span>
    <span>private</span> <span>Address</span> homeAddress<span>;</span>


    <span>@Embedded</span>
    <span>@AttributeOverrides</span><span>(</span><span>{</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"city"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"COMPANY_CITY"</span><span>)</span><span>)</span><span>,</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"street"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"COMPANY_STREET"</span><span>)</span><span>)</span><span>,</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"zipcode.zip"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"COMPANY_ZIP"</span><span>)</span><span>)</span><span>,</span>
            <span>@AttributeOverride</span><span>(</span>name <span>=</span> <span>"zipcode.plusFour"</span><span>,</span> column <span>=</span> <span>@Column</span><span>(</span>name <span>=</span> <span>"COMPANY_PLUS_FOUR"</span><span>)</span><span>)</span><span>,</span>
    <span>}</span><span>)</span>
    <span>private</span> <span>Address</span> companyAddress<span>;</span>


<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code><span>@Embeddable</span>
<span>public</span> <span>class</span> <span>Address</span> <span>{</span>

    <span>private</span> <span>String</span> city<span>;</span>
    <span>private</span> <span>String</span> street<span>;</span>

    <span>@Embedded</span>
    <span>private</span> <span>Zipcode</span> zipcode<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>@Embeddable</span>
<span>public</span> <span>class</span> <span>Zipcode</span> <span>{</span>

    <span>private</span> <span>String</span> zip<span>;</span>
    <span>private</span> <span>String</span> plusFour<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>name에 .을 통해 설정</p>
<br>
<h2 id="_0712-백엔드-api-패턴-레이어드-아키텍처-패턴-layered-architecture"> 0712 - 백엔드 API 패턴 - 레이어드 아키텍처 패턴(layered architecture)</h2>
<p>개발 단계에서 좋은 코드의 구조를 생각하는 것은 쉽지 않다. 코드 아키텍처를 구사할 때는</p>
<ul>
<li>확장성(extensibility)</li>
<li>재사용성(reusability)</li>
<li>유지 보수 가능성(maintainability)</li>
<li>가독성(readability)<br>
와 같은 요소들을 염두해야 한다.</li>
</ul>
<p>다행이도 코드의 구조를 어떻게 구상하고 관리해야 하는지는 이미 많이 다루어졌으며, 그에 관한 정성이나 패턴은 많이 나와 있다. 그 중에서 백엔드 API 코드에 가장 널리 적용되는 패턴 중 하나는 레이어드 아키텍처 패턴이다.</p>
<p>Multi-tier 아키텍처 패턴이라고도 하는 레이어드 아키텍처는 코드를 논리적인 부분 혹은 역할에 따라 독립된 모듈로 나누어서 구성하는 패턴이다. 그리고 각 모듈이 서로의 의존도에 따라 층층히 쌓듯이 연결되어서 전체의 시스템을 구현하는 구조이다. 그래서 마치 레이어(layer)를 쌓아 놓은 것 같은 형태의 구조가 된다.</p>
<p>각 시스템 마다 경우가 다를 수 있으나 일반적으로 보통 다음과 같은 3개의 레이어가 존재한다.</p>
<ul>
<li>presentation layer</li>
<li>business layer</li>
<li>persistence</li>
</ul>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbCxdbP%2Fbtrsnogd42h%2FOvPZq7EzMlOkCiKhRP22AK%2Fimg.png" alt="image"></p>
<h3 id="presentation-layer-user-interface"> Presentation layer (User Interface)</h3>
<p>Presentation layer는 해당 시스템을 사용하는 사용자 혹은 클라이언트 시스템과 직접적으로 연결되는 부분이다. 웹사이트에서는 UI 부분에 해당하고 백엔드 API에서는 엔트포인트 부분에 해당한다. 그러므로 presentation layer에서 API의 엔드포인트들을 정의하고 전송된 HTTP 요청(request)를 읽어 들이는 로직을 구현한다. 하지만 그 이상의 역할은 담당하지 안흔다. 실제 시스템이 구현하는 비즈니스 로직은 다음 레이어로 넘기게 된다.</p>
<ul>
<li>EndPoint</li>
<li>Authentication</li>
<li>JSON Translation</li>
</ul>
<h3 id="business-lyaer-business-logic"> Business lyaer (Business Logic)</h3>
<p>Business layer라는 이름 그대로 비즈니스 로직을 구현하는 부분이다. 실제 시스템이 구현해야하는 로직을 이 레이어에서 구현하게 된다. 백엔드 API에서는 Presentation layer에서 전송된 요청을 읽어들여 요청에 맞게 동작하는 로직을 구현하면 된다.</p>
<ul>
<li>Business Logic</li>
<li>Validation</li>
<li>Authoristion</li>
</ul>
<h3 id="persistence-layer-data-access"> Persistence layer (Data Access)</h3>
<p>Persistence layer는 데이터베이스와 관련된 로직을 구현하는 부분이다. Business layer에서 필요한 데이터를 생성, 수정, 읽기 등을 처리하여 실제로 데이터베이스에서 데이터를 저장, 수정, 읽기 작업을 하는 역하을 한다.</p>
<ul>
<li>Storage Logic</li>
</ul>
<h3 id="레이어드-아키텍처의-핵심-요소"> 레이어드 아키텍처의 핵심 요소</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlCOWD%2FbtrslVyO4cD%2FfViidrJt2eCAId4ZEgQ9H1%2Fimg.png" alt="image">
레이어드 아키텍처의 핵심 요소는 단방향 의존성이다. 각각의 레이어는 오직 자기보다 하위에 있는 레이어에만 의존한다.<br>
또 다른 핵심 요소는 &quot;sepration of concerns&quot;이다. 즉 각 레이어의 역할이 명확하다는 의미이다.<br>
위와 같은 요소들 때문에 레이어드 아키텍처의 구조로 코드를 구현하려면 각 레이어가 독립적이고 역할이 분명하므로 코드의 확장성이 높아진다. 코드의 구조를 파악하기 쉬울 뿐만 아니라 재사용 가능성도 높아진다.<br>
또한 역할이 명확하게 나뉘어 있으므로 각 레이어를 테스트 하는 테스트 코드의 작성도 훨씬 수월해진다.</p>
<br>
<h2 id="_0714-intellij의-http-사용"> 0714 - IntelliJ의 .http 사용</h2>
<h3 id="http-장점"> .http 장점</h3>
<ul>
<li>Code highlighting</li>
<li>코드 자동 완성</li>
<li>직관적인 HttpRequest 구조</li>
<li>Request Body에 쓸 JSON 등 적극적 지원(Language injections)</li>
<li>리팩토링</li>
<li>파일 관리가능</li>
</ul>
<h3 id="http-사용법"> .http 사용법</h3>
<h4 id="get-요청"> GET 요청</h4>
<ul>
<li>HTTP Request 파일생성</li>
</ul>
<div><pre><code>GET https://www.devbeginner.com
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>파일의 첫줄에는 HTTP Method와 URL<br>
둘째줄에는 RequestHeader 작성</p>
</blockquote>
<h4 id="post-요청"> POST 요청</h4>
<div><pre><code>POST https://localhost:8080/group
Content-Type: application/json

{
  &quot;groupName&quot;: &quot;그룹명&quot;,
  &quot;members&quot;: [
    &quot;회원1&quot;,
    &quot;회원2&quot;,
    &quot;회원3&quot;
  ],
  &quot;date&quot;: {
    &quot;year&quot;: 2018,
    &quot;month&quot;: 1,
    &quot;day&quot;: 24
  }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="json을-파일로-사용가능"> json을 파일로 사용가능</h4>
<div><pre><code>POST http://localhost:8080/group
Content-Type: application/json

&lt; ./post.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>꺽쇠(&lt;)를 기준으로 파일 위치를 지정하면 해당 파일의 데이터를 전송</li>
<li>Request Header와 데이터형태를 변경하여 multipart/form-data와 같이 파일 업로드, 이미지 업로드 테스트 가능</li>
</ul>
<h4 id="request-header-수정"> Request Header 수정</h4>
<div><pre><code>GET http://localhost:8080/real/hello
Authorization: Bearer {token}
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="cookie-수정"> Cookie 수정</h4>
<div><pre><code>GET https://localhost:8080/cookie
Cookie: user=ahnjs
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>key=value 형식으로 작성</li>
</ul>
<h4 id="log"> Log</h4>
<p>Intellij의 .http 요청은 모두 로그로 남겨진다.
로그 파일 위치 <code>프로젝트폴더/.idea/httpRequests/</code></p>
<h4 id="controller로-자동생성가능"> Controller로 자동생성가능</h4>
]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbCxdbP%2Fbtrsnogd42h%2FOvPZq7EzMlOkCiKhRP22AK%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0725 ~ 0807</title>
      <link>ahnjs/TIL/2022/0725/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0725/</guid>
      <source url="ahnjs/TIL/rss.xml">0725 ~ 0807</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0725-0807"> 0725 ~ 0807</h1>
<h2 id="_0727-oom-종류-및-조치"> 0727 - OOM 종류 및 조치</h2>
<p>OOM(Out Of Memory) : 메모리 부족 현상</p>
<blockquote>
<p>Heap
<img src="https://user-images.githubusercontent.com/42403023/127438023-0a746f66-b8f2-498f-b8e3-363f1351f1c0.png" alt="image"></p>
</blockquote>
<ul>
<li>Java 7 까지의 Heap 구조, 8부터 PermGen 부분이 Metaspace로 변경되었다.
<ul>
<li>PermGen 은 class 혹은 method 코드가 저장되는 영역으로 Heap영역에 위치한다.</li>
<li>Metaspace는 Classloader가 로드한 class 들의 metadata를 저장되는 공간으로 Heap이 아닌 Native 영역에 위치시킨다.</li>
<li>가장 큰 차이는 클래스의 metadata를 native 영역으로 옮김으로써 OS가 동적으로 조정할 수 있도록 한 것</li>
</ul>
</li>
<li>Runtime Data Area는 JVM이 OS로부터 할당받은 메모리 공간을 말하며 크게 5가지 영역으로 나눌 수 있다.</li>
<li>Heap은 런타임시 동적으로 할당하여 사용하는 영역으로 class를 이용해 instance를 생성하면 Heap에 저장된다.</li>
</ul>
<blockquote>
<p>메모리 누수(Memory Leak)</p>
</blockquote>
<ul>
<li>메모리 사용량
<ul>
<li>시스템 작업관리자에서 나오는 메모리 사용량으로는 측정의 정확도가 매우 떨어진다.</li>
<li>Runtime 클래스에 totalMemory() - freeMemory()를 통해 자바 어플리케이션의 메모리 사용량을 로그로 출력
<ul>
<li>long freeMemory() : Returns the amount of free memory in the jvm.</li>
<li>long totalMemory() : Returns the total amount of memory in the jvm.</li>
</ul>
</li>
<li>Jprobe 또는 Optimizeit와 같은 개발도구로 측정</li>
</ul>
</li>
<li>메모리 누수 발생 요인
<ul>
<li>Java에서는 GC에 의해 메모리가 자동 관리 되지만 memory leak가 발생할 수 있다.</li>
<li>루트 참조들로부터 직간접적으로 참조가 되는(reachable) 모든 객체를 현재 사용중인 객체라고 판단하고, 나머지는 쓰레기 객체라고 판단하여 JVM은 이러한 쓰레기 객체를 수거한다.
<ul>
<li>루트 참조는 다음과 같이 크게 3가지가 존재한다.
<ul>
<li>static 변수에 의한 객체 참조</li>
<li>현재 자바 스레드 스택내의 지역변수, 매개 변수에 의한 객체 참조</li>
<li>JNI 프로그램에 의해 동적으로 만들어지고 제거되는 JNI global 객체 참조</li>
</ul>
</li>
<li>하지만, 실제로 사용되지 않는 객체의 Reference를 프로그램에서 잡고 있으면 GC에 의해 처리되지 않고, 프로그램 내에서도 접근하여 사용될 수 없는 쓰레기 객체로 메모리를 점유하게 된다.
<ul>
<li>상호참조가 많은 경우 하나의 객체 잠조를 null처리 해주지 않는 실수</li>
</ul>
</li>
<li>이로 인해 메모리 누수가 발생하며 OOM이 발생하여 프로그램이 종료되는 심각한 현상이 발생한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>OOME(Out Of Memory Error)</p>
</blockquote>
<ul>
<li>객체를 생성하는 과정에서 힙 공간에 객체를 할당하기 위한 공간이 부족할 경우 발생한다.</li>
<li>해당 경우 GC는 새로운 객체를 생성할 수 있는 공간을 확보할 수 없거나 GC를 수행하는 데 과도한 시간이 소비되어 메모리를 사용하지 못하는 상황에서 발생할 수 있다.</li>
<li>기본 할당조건을 충족하지 못하는 경우 네이티브 라이브러리 코드에 의해 발생할 수 있다.(스왑 공간 부족)</li>
</ul>
<blockquote>
<p>OOME 종류 및 원인</p>
</blockquote>
<ul>
<li>java.lang.OutOfMemoryError : Java heap space(Java 힙 공간)
<ul>
<li>원인
<ul>
<li>자바 힙 공간에 새로운 객체를 생성할 수 없는 경우에 발생한다.</li>
<li>메모리 누수가 아닌 지정한 힙 크기(혹은 기본 크기)가 애플리케이션에 충분하지 않은 경우에도 발생한다.</li>
<li>혹은, 생명주기가 긴 애플리케이션의 경우 finalize를 과도하게 사용할 때 발생하기도 한다. (finalize는 소멸을 명시적으로 할 때 사용하나 GC에 마킹하는 데 오래걸리는 단점이 있다)</li>
</ul>
</li>
<li>조치
<ul>
<li>JVM Option을 통해 Heap size를 늘려 해결할 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li>java.lang.OutOfMemoryError : GC Overhaed limit exceeded(GC 오버헤드 한도 초과)
<ul>
<li>원인
<ul>
<li>메모리가 부족하여 가비지 컬렉션이 이루어졌지만, 새로 확보된 메모리가 전체 메모리의 2% 미만일 때 발생한다.</li>
<li>더 이상 가비지 컬렉션을 할 수 없을 정도로 메모리를 사용한다는 것이다.</li>
</ul>
</li>
<li>조치
<ul>
<li>힙 크기를 늘린다.</li>
<li>XX:-UseGCOverheadLimit 선택사항을 추가하여 에러가 발생하는 초과 오버헤드 GC 제한 명령을 해제할 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li>java.lang.OutOfMemoryError: Requested array size exceeds VM limit(요청 배열 크기가 VM 제한 초과)
<ul>
<li>원인
<ul>
<li>애플리케이션(혹은 애플리케이션을 사용하는 API)이 힙 공간보다 큰 배열을 할당을 시도하는 경우 발생한다.</li>
<li>힙공간 사이즈가 너무 작은경우
<ul>
<li>배열 요소를 계산하고 더하는 등 배열을 키우는 경우</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>java.lang.OutOfMemoryError: Metaspace
<ul>
<li>원인
<ul>
<li>자바 클래스 메타데이터는 원시 메모리(=메타 공간)에 할당된다.</li>
<li>클래스 메타데이터가 할당될 메타 공간이 모두 소모되면 발생한다.</li>
<li>클래스 메타데이터가 할당될 공간은 MaxMetaSpaceSize 매개변수로 제한된다.</li>
</ul>
</li>
<li>조치
<ul>
<li>MaxMetaSpaceSize 값을 늘려 설정한다. 자바 힙과 동일한 주소 공간에 할당된다.</li>
<li>자바 힙의 크기를 줄이면 더 많은 공간을 확보할 수 있다. 자바 힙공간에 여유가 있는 경우에 고려해 볼 수 있다.</li>
<li>heap영역과 perm 영역을 과하게 설정하면, native 영역과 stack 영역이 적은 공간으로 설정되어 이 두 영역의 공간부족에러가 발생 할 수도 있다.</li>
</ul>
</li>
</ul>
</li>
<li>java.lang.OutOfMemoryError: request size bytes for reason. Out of swap space?
<ul>
<li>원인
<ul>
<li>자바 HotSpot VM 코드가 네이티브 힙 고갈이 되어 네이티브 힙에 할당할 수 없는 경우 발생한다.</li>
<li>이 메시지는 실패한 요청의 바이트 크기와 메모리 요청의 이유를 나타내며 대개의 경우 할당에 실패한 소스 모듈의 이름을 출력한다.</li>
</ul>
</li>
<li>조치
<ul>
<li>네이티브 힙 고갈의 경우는 힙 메모리 로그 및 메모리 맵 정보를 분석하는 것이 유용하다.</li>
<li>이런 유형은 운영체제의 문제 유틸리티를 사용하여 문제를 진단할 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li>java.lang.OutOfMemoryError: Compressed class space(압축된 클래스 공간)
<ul>
<li>원인
<ul>
<li>64비트 플랫폼에서 클래스 메타데이터 포인터는 32비트 오프셋(UseCompressedOops)으로 표현된다.
이 방식은 UseCompressedClassPointers(기본값 활성화, on)으로 제어할 수 잇으며 활성화되면 클래스 메타데이터가 사용할 수 있는 공간의 크기가 고정된다.</li>
<li>UseCompressedClassPointers에 필요한 CompressedClassSpaceSize를 초과하면 java.lang.OutOfMemoryError: Compressed class space를 던진다.</li>
</ul>
</li>
<li>조치
<ul>
<li>CompressedClassSpaceSize 크기를 키우거나 UseCompressedClassPointers를 비활성화 시킨다.</li>
</ul>
</li>
</ul>
</li>
<li>java.lang.OutOfMemoryError: Reason stack_trace_with_native method
<ul>
<li>원인
<ul>
<li>이 메시지가 출력되는 것은 원시 메서드에서부터 스택 트레이스가 출력되었다는 것을 의미하며, 네이티브 메서드에 할당 오류가 발생했음을 의미한다.</li>
<li>이 메시지가 위의 메시지들과 다른 점은 JVM 코드가 아니라 Java Native Interface(JNI) 또는 원시메서드에서 할당실패가 감지되었다는 것이다.</li>
</ul>
</li>
<li>조치
<ul>
<li>이 예외가 발생하면 운영체제가 제공하는 유틸리티를 이용해서 문제점을 진단해야 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0807-flyway"> 0807 - Flyway</h2>
<h3 id="flyway란"> Flyway란?</h3>
<p>DB 이력을 형상관리 할 수 있는 오픈소스 도구이다.</p>
<p>로컬, 알파 등 개발 DB에서 변경한 Schema, Index, Key 등을 베타, 운영 DB에 누락되는 것을 Flyway를 사용하여 방지할 수 있다. 또한 단위 테스트에서도 In-Memory DB(H2, derby, Hsqldb 등)에 DB DDL이력을 실행하여 원격과 같은 DB 형상을 유지한 채, 단위 테스트를 할 수 있다.</p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcy0ZU4%2FbtrffQcB4B2%2FY5pX9oNiF30Ma7DEvdL2h0%2Fimg.png" alt="image"></p>
<p>flyway는 다양한 방법으로 실행할 수 있다. 공식 사이트에 따르면 gradle, maven, CLI, JAVA API등 으로 사용할 수 있다.</p>
<h3 id="flyway-사용법"> Flyway 사용법</h3>
<h4 id="의존성-및-환경-설정"> 의존성 및 환경 설정</h4>
<p>flyway의 Java API를 사용하기 위해서는 org.flywaydb:flyway-core 모듈에 대한 의존성이 필요하다</p>
<div><pre><code>implementation(&quot;org.flywaydb:flyway-core:6.5.7&quot;)
</code></pre>
<div><span>1</span><br></div></div><h4 id="yaml-파일-설정"> yaml 파일 설정</h4>
<p>Spring Boot에서는 flyway에 대한 autoconfigure를 지원한다.</p>
<div><pre><code><span>spring</span><span>:</span>
<span>  datasource</span><span>:</span>
<span>    hikari</span><span>:</span>
<span>      jdbc-url</span><span>:</span> <span>jdbc:mariadb://localhost:3306/pika</span>
<span>      username</span><span>:</span> <span>pika_app</span>
<span>      password</span><span>:</span> <span>pika_password</span>

<span>  flyway</span><span>:</span>
<span>    locations</span><span>:</span> <span>classpath:/db/migration # migration 파일들이 위치하는 directory</span>
<span>    sql-migration-suffixes</span><span>:</span> <span>ddl        # 파일 확장자</span>
<span>    baseline-on-migrate</span><span>:</span> <span>true          # flyway_schema_history 테이블을 자동으로 생성할지 여부 </span>
<span>    baseline-version</span><span>:</span> <span>0                # 최초 버전 정보</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h4 id="마이그레이션-파일"> 마이그레이션 파일</h4>
<p>flyway에서는 데이터베이스에 일어나는 모든 행위를 메이그레이션(migration)이라고 표현한다. 이러한 마이그레이션은 파일로 관리되어 진다. 파일의 이름은 지정하는 형식이 존재하며 이를 지켜야 한다.</p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcqvO9u%2FbtrfgYIhw2u%2FkKyRbZFhXrOt1T1YYuCgS0%2Fimg.png" alt="image"></p>
<ul>
<li>Prefix : V, U, R 중 하나를 입력 V는 Verion, U는 undo, R은 Repeatable이다.</li>
<li>Version : 버전 정보이다. 정수, 소수, 날짜 등이 가능</li>
<li>Seperator : __(underscore 2개를 사용)</li>
<li>Description : 추가되는 설명이다. _가 space를 대신한다.</li>
</ul>
<p>예) V0_create_table_user.sql, V1.1_create_table_game.sql, V20210909_create_table_screenshot.sql</p>
<p>Flyway로 관리될 SQL 파일은 <code>src/main/resources/db/migration</code> 위치에 저장되어야 한다.</p>
<h4 id="flyway-schema-history-테이블"> flyway_schema_history 테이블</h4>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpDNJE%2FbtrfjWIKdHQ%2FKdEEAaW34kBzC3o62onmFk%2Fimg.png" alt="image"></p>
<ul>
<li>version은 파일의 V뒤에 붙어있던 숫자로 낮은 순서부터 실행되며 실행 순서대로 테이블에 쌓이는 구조를 가진다.</li>
<li>checksum은 파일의 내용을 hashing한 것이다. 만약 파일의 내용이 달라지면 이 체크섬이 달라진다. 한번 체크섬을 만들어 둔 후 파일을 수정할 경우 형상관리에 문제가 생겻다고 판단하기 때문에 에러가 발생한다. 이럴 경우 해당 파일에 대한 체크섬을 repair 한 후 success를 0으로 돌리는등의 작업이 필요하다. (flyway로 등록된 순간을 기준으로 flyway가 DB버전을 관리하게 되므로 해당 스크립트를 수정, 삭제하면 안된다.)</li>
<li>success는 파일 실행에 성공했는지 여부를 나타내는 값이다.</li>
</ul>
]]></content:encoded>
      <enclosure url="https://user-images.githubusercontent.com/42403023/127438023-0a746f66-b8f2-498f-b8e3-363f1351f1c0.png" type="image/png"/>
    </item>
    <item>
      <title>0815 ~ 0824</title>
      <link>ahnjs/TIL/2022/0815/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0815/</guid>
      <source url="ahnjs/TIL/rss.xml">0815 ~ 0824</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0815-0824"> 0815 ~ 0824</h1>
<h2 id="_0820-활성-프로파일-profile-의-관리를-위한-profile과-activeprofiles"> 0820 - 활성 프로파일(Profile)의 관리를 위한 @Profile과 @ActiveProfiles</h2>
<h3 id="활성-프로파일과-profile-activeprofiles"> 활성 프로파일과 @Profile, @ActiveProfiles</h3>
<h4 id="환경의-분리"> [ 환경의 분리 ]</h4>
<p>개발을 하다 보면 여러 개의 환경을 관리해야 한다. 예를 들어 테스트 코드를 위한 테스트 환경, 개발을 하고 테스트를 하기 위한 알파 환경, 실제 운영 환경과 동일하게 맞춰두고 QA 등을 진행하는 스테이지 환경, 실제 서비스가 운영되는 운영 환경 등이 있다.<br>
그렇기 때문에 각각의 환경들에 맞게 서로 다르게 빈 또는 프로퍼티들을 정의해야 할 수 있다. 예를 들어 개발을 위해서는 로컬 또는 내장 캐시를 이용할 수 있지만 실제 운영을 위해서는 외부 캐시를 이용하는 것이 대표적인 경우이다.<br>
Spring은 3.1부터 환경에 따라 빈 정보가 달라져야 하는 경우에 파일을 여러 개로 분리하는 대신 빈 구성이 달라지는 내용을 프로파일로 정의해서 만들어두고, 실행 시점에 어느 프로파일의 빈 설정을 사용할 지 지정할 수 있도록 도와주고 있다. 즉, 환경에 따라 서로 다르게 빈을 정의할 수 있도록 환경을 분리하는 기수을 제공하는데, 이와 관련된 기술이 @Profile과 @ActiveProfile 이다.</p>
<h4 id="활성-프로파일을-지정하기-위한-activeprofiles-어노테이션"> [ 활성 프로파일을 지정하기 위한 @ActiveProfiles 어노테이션 ]</h4>
<p>활성 프로파일이란 스프링 컨테이너를 실행할 때 실행 환경을 지정해주는 속성으로, 환경을 구분하기 위해 사용된다. 프로파일은 JVM의 옵션으로도 설정을 할 수 있고, 스프링에서도 설정을 할 수 있다.<br>
JVM 옵션으로 프로파일을 설정하기 위해서는 다음의 옵션을 지정해줄 수 있다,</p>
<div><pre><code>-Dspring.profiles.active<span>=</span>dev
</code></pre>
<div><span>1</span><br></div></div><p>그리고 JVM이 아닌 스프링에서 현재의 프로파일(환경)을 지정하도록 도와주는 어노테이션이 <code>@ActiveProfiles</code> 이다.<br>
예를 들어 테스트 환경에서는 현재의 프로파일을 test로 설정해주어야 하는데, 다음과 같이 @ActiveProfiles를 설정해주면 해당 프로파일로 스프링 컨테이너가 실행된다.</p>
<div><pre><code><span>@ActiveProfiles</span><span>(</span><span>"test"</span><span>)</span>
<span>public</span> <span>class</span> <span>UnitTestConfig</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>만약 활성 프로파일이 test라면 test 프로파일이 아닌 다른 프로파일을 위해 등록된 빈들이나 설정 파일들은 모두 무시(비활성화) 된다.</p>
<h4 id="특정-프로파일에-활성화하기-위한-profile-어노테이션"> [ 특정 프로파일에 활성화하기 위한 @Profile 어노테이션 ]</h4>
<p>예를 들어 Redis 캐시 설정은 운영 환경(prod)에서만 사용하기를 원할 수 있다. 그럴 때 해당 설정 클래스가 원하는 환경에서만 등록(활성화)되도록 설정을 해줄 수 있는데, 이를 위해 사용되는 것이 @Profile 어노테이션이다.</p>
<div><pre><code><span>@Profile</span><span>(</span><span>"prod"</span><span>)</span>
<span>@Configuration</span>
<span>@EnableRedisHttpSession</span><span>(</span>maxInactiveIntervalInSeconds <span>=</span> <span>60</span> <span>*</span> <span>60</span> <span>*</span> <span>24</span> <span>*</span> <span>30</span><span>)</span>
<span>public</span> <span>class</span> <span>RedisConfig</span> <span>extends</span> <span>AbstractHttpSessionApplicationInitializer</span> <span>{</span>

    <span>@Value</span><span>(</span><span>"${spring.redis.host}"</span><span>)</span>
    <span>private</span> <span>String</span> host<span>;</span>
    <span>@Value</span><span>(</span><span>"${spring.redis.port}"</span><span>)</span>
    <span>private</span> <span>int</span> port<span>;</span>

    <span>@Bean</span>
    <span>public</span> <span>RedisConnectionFactory</span> <span>redisConnectionFactory</span><span>(</span><span>)</span> <span>{</span>
        <span>RedisStandaloneConfiguration</span> redisStandaloneConfiguration <span>=</span> <span>new</span> <span>RedisStandaloneConfiguration</span><span>(</span>host<span>,</span> port<span>)</span><span>;</span>
        <span>return</span> <span>new</span> <span>LettuceConnectionFactory</span><span>(</span>redisStandaloneConfiguration<span>)</span><span>;</span>
    <span>}</span>

    <span>@Bean</span>
    <span>public</span> <span>CookieSerializer</span> <span>cookieSerializer</span><span>(</span><span>)</span> <span>{</span>
        <span>DefaultCookieSerializer</span> serializer <span>=</span> <span>new</span> <span>DefaultCookieSerializer</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> serializer<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>위와 같은 설정 클래스는 @Profile이 prod로 설정되어 있기 때문에 현ㅇ재의 프로파일(환경)이 prod인 경우에만 활성화된다. 만약 prod가 아닌 경우에만 사용하기를 원한다면 !prod와 같이 설정할수도 있다</p>
<br>
<h2 id="_0821-credential-파일-관리"> 0821 - Credential 파일 관리</h2>
<p>설정파일의 외부 노출을 막고 배포하는 방법</p>
<ol>
<li>설정파일을 .gitignore에 추가하여 따로 관리한다.
<ul>
<li>배포시 필요한 설정 파일을 직접 추가해야 한다.</li>
</ul>
</li>
<li>설정파일을 Private Repository의 Git Submodules 로 사용.
<ul>
<li>Private Repository라고 해도 설정 값들이 암호화되어있는 것이 아니기에 노출 시 취약.</li>
</ul>
</li>
<li>설정파일 암호화 : Java의 Jasypt(Java Simplified Encrypotion) 패키지를 사용하여 설정 파일들을 암호화
<ul>
<li>암호화 값을 추가(별도 관리 비용 발생)</li>
</ul>
</li>
<li>외부 서비스 연동(별도 Config Server 사용)
<ul>
<li>별도의 Config를 관리하는 Server를 사용하여 배포시 Config server와 통신하여 설정 파일들을 가져온다. Spring Cloud Config 또는 Aws System Manager, AppConfig 등을 사용</li>
<li>별도의 관리가 필요하며 외부 서비스 비용이 발생한다.</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>0718 ~ 0724</title>
      <link>ahnjs/TIL/2022/0718/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0718/</guid>
      <source url="ahnjs/TIL/rss.xml">0718 ~ 0724</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0718-0724"> 0718 ~ 0724</h1>
<h2 id="_0719-도메인-주도-설계-domain-driven-development-이해"> 0719 - 도메인 주도 설계(Domain Driven Development) 이해</h2>
<h3 id="도메인-주도-설계-도입-배경"> 도메인 주도 설계 도입 배경</h3>
<blockquote>
<p>Before</p>
</blockquote>
<h4 id="기존-개발"> 기존 개발</h4>
<ul>
<li>데이터에 종속적인 애플리케이션</li>
<li>모델링과 개발과의 불일치 발생</li>
</ul>
<blockquote>
<p>After</p>
</blockquote>
<h4 id="도메인-주도-설계"> 도메인 주도 설계</h4>
<ul>
<li>이런 불일치를 해소하기 위한 노력 중 하나가 바로 DDD</li>
<li>공통의 언어(*유비쿼터스 언어)를 사용하여 도메인과 구현을 충분히 만족하는 모델을 만든다.</li>
<li>*유비쿼터스 언어를 사용하여 용어사전을 만든다. (예) 헌터 | hunter | 보물을 찾는 사냥꾼</li>
<li>'설계'와 '구현'은 계속된 수정 과정을 거친다. (반복 작업)</li>
</ul>
<p>*유비쿼터스 언어(보편 언어)란? 도메인 어휘를 이해관리자들이 공통적으로 의미를 이해할 수 있도록 정의하는 것</p>
<blockquote>
<p>효과적인 모델링</p>
</blockquote>
<ul>
<li>사용자와 개발자는 동일한 언어로 이야기 하는가?</li>
<li>해당 언어가 애플리케이션에서 수행해야 할 내용에 관한 논의를 이끌어갈 만큼 풍성한가?</li>
</ul>
<blockquote>
<p>도메인</p>
</blockquote>
<ul>
<li>일반적인 요구하상, 전문 용어, 그리고 컴퓨터 프로그래밍 분야에서 문제를 풀기 위해 설계된 어떤 소프트웨어 프로그램에 대한 기능성을 정의하는 연구의 한 영역</li>
<li>소프트웨어로 해결하고자 하는 문제 영역
(예) 광고회사의 광고와 관련된 지식 = 도메인</li>
</ul>
<blockquote>
<p>도메인 모델</p>
</blockquote>
<ul>
<li>특정 도메인을 개념적으로 표현한 것</li>
<li>도메인 모델을 사용하면 여러 관계자들(개발자, 기획자, 사용자 등)이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다.</li>
<li>모델의 각 구성 요소는 특정 도메인을 한정할 때 비로소 의미가 와전해지기 때문에, 각 하위 도메인마다 별도로 모델을 만들어야 한다.<br>
(예) 쿠팡에서 상품을 주문할 때 필요한 것 : 고객의 주문서 모델, 상품 정보의 상품 모델</li>
</ul>
<h3 id="도메인-주도-설계-아키텍처-개요"> 도메인 주도 설계 아키텍처 개요</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAq1DL%2FbtqvtfTTA4N%2F5UelKaZfgzz0ZGyvBbfoY0%2Fimg.png" alt="image">
*핵심 로직(비즈니스 로직)은 도메인 모델에 담아서 사용한다.</p>
<blockquote>
<p>도메인 모델의 네 개의 영역</p>
</blockquote>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbbeJCW%2FbtqvsZLoVQu%2FnqAjktecGoh8bkW2L4kS61%2Fimg.png" alt="image">
*아래로 내려갈수록 의존성이 강해진다.</p>
<ul>
<li>PRESENTATION LAYER : 표현 영역 또는 UI영역. 사용자의 요청을 받아 응용 영역에 전달하고, 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다. (Controller 영역, DispatcherServlet에게 요청과 응답을 전달하는 역할)</li>
<li>APPLICATION LAYER : 응용 영역. 시스템이 사용자에게 제공해야 할 기능을 구현한다. (Service 영역)</li>
<li>DOMAIN LAYER : 도메인 영역. 도메인 모델을 구현한다. (이름, 주소, 상품, 주문서 등)</li>
<li>INFRASTRUCTURE LAYER : 구현 기술에 대한 것을 다룬다. (외부 API, 데이터베이스, 외부 라이브러리 사용 등)</li>
</ul>
<h4 id="presentation-layer-표현영역"> PRESENTATION LAYER(표현영역)</h4>
<ul>
<li>사용자가 시스템을 사용할 수 있는 (화면) 흐름을 제공하고 제어</li>
<li>사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.</li>
<li>사용자의 세션을 관리한다.</li>
</ul>
<h4 id="application-layer-응용영역"> APPLICATION LAYER(응용영역)</h4>
<ul>
<li>사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용한다.</li>
<li>로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.</li>
<li>도메인 객체 간의 실행 흐름을 제어</li>
<li>*트랜잭션 처리</li>
<li>도메인 영역에서 발생시킨 이벤트를 처리</li>
</ul>
<p>*트랜잭션이란? 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위.</p>
<h3 id="도메인-주도-설계-기본요소"> 도메인 주도 설계 기본요소</h3>
<blockquote>
<p>엔티티(Entity)와 벨류(Value)</p>
</blockquote>
<ul>
<li>도출한 모델은 크게 엔티티와 벨류로 구분</li>
<li>데이터와 함께 도메인 기능을 제공한다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd21pJI%2Fbtqvs0i9vA6%2FYKy9DAeSn8Y9QRmsJG6rlK%2Fimg.png" alt="image"></li>
</ul>
<blockquote>
<p>Entity</p>
</blockquote>
<ul>
<li>식별자를 갖는다.</li>
<li>식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 갖는다.</li>
</ul>
<blockquote>
<p>도메인 모델에 set 메서드 넣지 않기</p>
</blockquote>
<ul>
<li>도메인 모델에 get/set 메서드를 무조건 추가하는 것은 좋지 않은 버릇이다.</li>
<li>특히 set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.</li>
<li>set 메서드의 또 다른 문제는 도메인 객체를 생성할 때 완전한 상태가 아닐 수도 있다는 것이다.</li>
<li>도메인 객체가 불완전한 상태로 사용되는 것을 막으러면 생성 시점에 필요한 것을 전달해 주어야 한다.</li>
</ul>
<blockquote>
<p>Value Object</p>
</blockquote>
<ul>
<li>벨류 타입은 불변을 원칙으로 한다.</li>
<li>의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 벨류 타입을 이용한다.</li>
<li>시스템이 성숙함에 따라 데이터 값을 객체로 대체한다.</li>
<li>벨류 객체의 값을 변경하는 방법은 새로운 벨류 객체를 할당하는 것뿐이다.</li>
<li>식별자가 존재하지 않는다.</li>
</ul>
<blockquote>
<p>Aggregate</p>
</blockquote>
<ul>
<li>관련 객체를 하나로 묶은 군집</li>
<li>애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.</li>
<li>애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.</li>
<li>애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.</li>
<li>한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.</li>
<li>대부분의 애그리거트는 한개의 엔티티 객체를 가지며, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다.</li>
<li>각 애그리거트는 자기 자신을 관리할뿐 다른 애그리거트는 관리하지 않는다.<br>
(예)주문 애그리 거트는 배송지 변경, 주문 상품 변경 등 자신은 관리하지만 회원 비밀번호 변경, 상품 가격 변경 등은 하지 않는다.</li>
</ul>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FFMZwX%2Fbtqvsko6gQ5%2FWRbDGFGNICDO36Q02dASx1%2Fimg.png" alt="image">
*주문(Order) 애그리거트 : 주문, 배송지 정보, 주문자, 주문목록, 총 결제금액의 하위 모델이 있다. 이때 이 하위 개념을 표현한 모델을 하나로 묶어서 '주문'이라는 상위 개념으로 표현할 수 있다.<br>
즉, 주문은 Root Aggregate가 된다.<br>
Root Aggregate를 중점으로 종속되어 있는 엔티티들은 동일한 라이프사이클(하나의 트랜잭션)을 가진다.<br>
*퍼사드 패턴과 유사하다. (참고: https://jusungpark.tistory.com/23)</p>
<blockquote>
<p>애그리거트 루트</p>
</blockquote>
<ul>
<li>애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 꺠지지 않도록 하는 것이다.(애그리거트: 독립된 객체군)</li>
<li>부득이하게 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 않고, 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다.</li>
<li>애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.</li>
<li>이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화 할 수 있도록 돕는다.</li>
<li>루트 엔티티는 애그리거트에 속해 있는 엔티티와 벨류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.</li>
</ul>
<div><pre><code>*애그리거트 루트를 통해서만 도메인 로직을 구현하게 만드는 습관*

- 단순히 필드를 변경하는 set 메소드를 public으로 만들지 않는다.
- 벨류타입은 불변으로 구현한다.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>애그리거트 참조</p>
</blockquote>
<ul>
<li>애그리거트를 직접 참조할 때 발생할 수 있는 문제는 편리함을 오용할 수 있다는 것, 성능에 대한 고민, 확장의 어려움 등이 있다.</li>
<li>ID참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다.</li>
<li>ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다.</li>
</ul>
<blockquote>
<p>리포지터리</p>
</blockquote>
<ul>
<li>엔티티나 벨류가 요구사항에서 도출되는 도메인 모델이라면, 리포지터리는 구현을 위한 도메인 모델</li>
<li>애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.</li>
<li>애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.</li>
<li>리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NPE와 같은 문제가 발생하게 된다.</li>
<li>리포지터리는 애그리거트(루트) 단위로 존재하며 테이블 단위로 존재하는 것이 아니다.</li>
</ul>
<p>(예시)</p>
<div><pre><code><span>public</span> <span>interface</span> <span>OrderRepository</span> <span>{</span>
    <span>public</span> <span>Order</span> <span>findByNumber</span><span>(</span><span>OrderNumber</span> number<span>)</span><span>;</span>
    <span>public</span> <span>void</span> <span>save</span><span>(</span><span>Order</span> order<span>)</span><span>;</span>
    <span>public</span> <span>void</span> <span>delete</span><span>(</span><span>Order</span> order<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>여러 애그리거트가 필요한 기능<br>
*결제 금액 계산 로직</p>
</blockquote>
<ul>
<li>상품 애그리거트 : 구매하는 상품의 가격이 필요하다. 또한 상품에 따라 배송비가 추가되기도 한다.</li>
<li>주문 애그리거트 : 상품별로 구매 개수가 필요하다.</li>
<li>할인 쿠폰 애그리거트 : 쿠폰별로 지정한 할인 금액이나 비율에 따라 주문 총 금액을 할일한다. 할인 쿠폰을 조건에 따라 중복 사용할 수 있다거나 지정한 카테고리의 상품에만 적용할 수 있다는 제약 조건이 있다면 할인 꼐산이 복잡해진다.</li>
<li>회원 애그리거트 : 회원 등급에 따라 추가 할인이 가능하다.</li>
</ul>
<p><em><strong>&quot;이 상황에서 실제 결제 금액을 계산해야 하는 주체는 어떤 애그리거트 일까?&quot;</strong></em></p>
<blockquote>
<p>도메인 서비스</p>
</blockquote>
<ul>
<li>한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다.</li>
<li>응용 영역의 서비스가 응용 로직을 다룬다면 도메인 서비스는 도메인 로직을 다룬다.</li>
<li>도메인 영역의 애그리거트나 밸류와 같은 다른 구성요소와 비교할 떄 다른 점은 상태 없이 로직만 구현한다.</li>
<li>서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있다.</li>
<li>애그리거트 메서드를 실행할 때 도메인 서비스를 인자로 전달하지 않고 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하기도 한다.</li>
<li>특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 검사해 보면 된다.</li>
</ul>
<p>(예) 계좌이체 로직은 계좌 애그리거트의 상태를 변경한다. 결제 금액 로직은 주문 애그리거트의 주문 금액을 계산한다. 이 두로직은 각각 애그리거트를 변경하고 애그리거트의 값을 계산하는 도메인 로직이다.<br>
도메인 로직이면서 한 애그리거트에 넣기 적합하지 않으므로 이 두 로직은 도메인 서비스로 구현하게 된다.</p>
<p>*트랜잭션 처리와 같은 로직은 응용 로직이므로 응용 서비스에서 처리해야 한다.</p>
<blockquote>
<p>UML</p>
</blockquote>
<ul>
<li>모델 기반 의사소통은 *UML 상의 다이어그램으로 한정돼서는 안된다.</li>
</ul>
<blockquote>
<p>BOUNDED CONTEXT</p>
</blockquote>
<ul>
<li>애그리거트의 명시적 경계</li>
<li>하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.</li>
<li>하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인 마다 모델을 만들어야 한다.</li>
<li>모델은 특정한 컨텍스트(문맥)하에서 완전한 의미를 갖는다.</li>
<li>이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 BOUNDED CONTEXT라고 부른다.</li>
<li>도메인 : Bounded Context = 1:1 이 이상적이다.
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqRo50%2Fbtqvsk3QgsC%2F2SQg0xmmOtkxzcgsVutuN0%2Fimg.png" alt="image"></li>
</ul>
<p>*주의할 점</p>
<ul>
<li>하위 도메인 모델이 뒤섞이지 않도록 하는 것</li>
<li>개별 Bounded Context Package로 구성하여 하위 도메인이 섞이지 않도록 하여 효과를 낼 수 있다.</li>
<li>도메인이 섞이게 된다면 기능 확장이 어렵게 되고 이는 서비스의 경쟁력을 떨어뜨리는 원인이 될 수 있다.</li>
</ul>
<br>
<h2 id="_0720-자바-예외처리-방법과-종류"> 0720 - 자바 예외처리 방법과 종류</h2>
<p>java exception handling (Checked Exception, Unchecked Exception)</p>
<h3 id="예외와-에러의-의미"> 예외와 에러의 의미</h3>
<p>예외(Exception)란 입력 값에 대한 처리가 불가능하거나, 프로그램 시행 중에 참조된 값이 잘못된 경우 등 정상적인 프로그램의 흐름을 어긋나는 것을 말한다. 또한, 자바에서의 예외는 개발자가 직접 처리할 수 있기 때문에 예외 상황을 미리 예측하여 다룰 수 있다.</p>
<p>에러(Error)는 시스템에 비정상적인 상황이 발생한 경우를 말한다. 주로 자바 가상 머신(JVM)을 통해 발생되며 예외와 반대로 이를 애플리케이션 코드에서 잡으려고 하면 안된다.</p>
<div><pre><code><span>package</span> <span>src<span>.</span>throwable<span>.</span>error</span><span>;</span>

<span>public</span> <span>class</span> <span>ErrorExample</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>gillog</span><span>(</span><span>String</span> log<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>log<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>gillog</span><span>(</span><span>"Error Test"</span><span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>StackOverflowError</span> e<span>)</span> <span>{</span>
            <span>// ......... :(</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>에러의 경우 StackOverflowError에 대해 Catch를 하려 해도 처리할 수 없다.</p>
<h3 id="예외-exception-의-구분"> 예외(Exception)의 구분</h3>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHR90d%2FbtrAyNZKf9Z%2FWF3CbAUARh3HZGRblhcK50%2Fimg.png" alt="image"></p>
<ul>
<li>RuntimeException을 상속하지 않는 클래스는 Checked Exception로 분류할 수 있다.</li>
<li>RuntimeException을 상속하는 클래스는 Unchecked Exception으로 분류할 수 있다.</li>
</ul>
<h3 id="에러-error-의-종류"> 에러(Error)의 종류</h3>
<p>에러의 종류에는 LinkageError, ThreadDeath, AssertionError, VirtualMachineError가 있다.</p>
<ul>
<li>LinkageError : 어떤 클래스가 다른 클래스에 대한 종속성이 있는 상황에서, 후자 클래스가 이전 클래스를 컴파일 한 후 비호환적으로 변경된 경우 발생하는 에러</li>
<li>ThreadDeath : 더 이상 사용되지 않는 Thread에 대해 Thread.stop() method가 호출 될 때, 삭제되는 Thread에서 Instance가 throw 되며 발생하는 에러</li>
<li>AssertionError : Assertion이 실패한 경우 발생하는 에러. (해당 지점에서 개발자가 반드시 참이어야 한다고 생각하는 사항을 표현한 논리식을 Assertion이라 한다.)</li>
<li>VirtualMachine : JVM이 손상되었거나 계속 작동하는 데 필요한 리소스가 부족할때 발생하는 에러</li>
</ul>
<h3 id="checkedexception과-uncheckedexception"> CheckedException과 UncheckedException</h3>
<blockquote>
<p>CheckedException</p>
</blockquote>
<ul>
<li>반드시 예외 처리해야 하며, 컴파일 시점에서 예외 발생이 확인된다.</li>
<li>에러와 RuntimeException을 상속하지 않은 예외들을 모두 포함한다.</li>
<li>Error, FileNotFoundException, ClassNotFoundException 등이 대표적이다.</li>
<li>스프링 프레임워크에서 CheckedException은 트랜젝션 처리 시에 예외가 발생해도 롤백하지 않는다.</li>
</ul>
<blockquote>
<p>UncheckedException</p>
</blockquote>
<ul>
<li>명시적으로 예외 처리할 필요가 없으며, 런타임 시점에서 예외 발생이 확인된다.</li>
<li>RuntimeException을 상속받는 예외들을 포함한다.</li>
<li>NullPointerException, ClassCastException 등이 대표적이다.</li>
<li>스프링 프레임워크에서 UncheckedException은 트랜젝션 처리시에 예외가 발생한 경우 롤백을 수행한다.</li>
</ul>
<p><em><strong>순수 자바 관점에서의 UncheckedException 상황에서는 롤백을 수행하지 않아도 된다.</strong></em></p>
<h3 id="예외처리-방법"> 예외처리 방법</h3>
<p>예외 처리방법에는 복구, 회피, 전환이 있다.</p>
<blockquote>
<p>예외 복구</p>
</blockquote>
<ul>
<li>예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법</li>
<li>예외를 잡아서 일정 시간, 조건만큼 대기하고 다시 재시도를 반복한다.</li>
<li>최대 재시도 횟수를 넘기게 되는 경우 예외를 발생시킨다.</li>
</ul>
<div><pre><code><span>final</span> <span>int</span> MAX_RETRY <span>=</span> <span>100</span><span>;</span>
<span>public</span> <span>Object</span> <span>someMethod</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> maxRetry <span>=</span> MAX_RETRY<span>;</span>
    <span>while</span><span>(</span>maxRetry <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>.</span><span>.</span><span>.</span>
        <span>}</span> <span>catch</span><span>(</span><span>SomeException</span> e<span>)</span> <span>{</span>
            <span>// 로그 출력. 정해진 시간만큼 대기한다.</span>
        <span>}</span> <span>finally</span> <span>{</span>
            <span>// 리소스 반납 및 정리 작업</span>
        <span>}</span>
    <span>}</span>
    <span>// 최대 재시도 횟수를 넘기면 직접 예외를 발생시킨다.</span>
    <span>throw</span> <span>new</span> <span>RetryFailedException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>예외처리 회피</p>
</blockquote>
<ul>
<li>예외 처리를 직접 담당하지 않고 호출한 쪽으로 던져 회피하는 방법</li>
<li>그래도 예외 처리의 필요성이 있다면 어느 정도는 처리하고 던지는 것이 좋다.</li>
<li>긴밀하게 역할을 분담하고 있는 관계까 아니라면 예외를 그냥 던지는 것은 무책임하다.</li>
</ul>
<div><pre><code><span>// 예시 1</span>
<span>public</span> <span>void</span> <span>add</span><span>(</span><span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>
    <span>// ...생략</span>
<span>}</span>

<span>// 예시 2 </span>
<span>public</span> <span>void</span> <span>add</span><span>(</span><span>)</span> <span>throws</span> <span>SQLException</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>// ... 생략</span>
    <span>}</span> <span>catch</span><span>(</span><span>SQLException</span> e<span>)</span> <span>{</span>
        <span>// 로그를 출력하고 다시 날린다!</span>
        <span>throw</span> e<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>예외 전환</p>
</blockquote>
<ul>
<li>예외 회피와 비슷하게 메서드 밖으로 예외를 던지지만, 그냥 던지지 않고 적절한 예외로 전환해서 넘기는 방법</li>
<li>조금 더 명확한 의미로 전달되기 위해 적합한 의미를 가진 예외로 변경한다.</li>
<li>예외 처리를 단순하게 만들기 위해 포장(wrap) 할 수도 있다.</li>
</ul>
<div><pre><code><span>// 조금 더 명확한 예외로 던진다.</span>
<span>public</span> <span>void</span> <span>add</span><span>(</span><span>User</span> user<span>)</span> <span>throws</span> <span>DuplicateUserIdException</span><span>,</span> <span>SQLException</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>// ...생략</span>
    <span>}</span> <span>catch</span><span>(</span><span>SQLException</span> e<span>)</span> <span>{</span>
        <span>if</span><span>(</span>e<span>.</span><span>getErrorCode</span><span>(</span><span>)</span> <span>==</span> <span>MysqlErrorNumbers</span><span>.</span>ER_DUP_ENTRY<span>)</span> <span>{</span>
            <span>throw</span> <span>DuplicateUserIdException</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>throw</span> e<span>;</span>
    <span>}</span>
<span>}</span>

<span>// 예외를 단순하게 포장한다.</span>
<span>public</span> <span>void</span> <span>someMethod</span><span>(</span><span>)</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>// ...생략</span>
    <span>}</span>
    <span>catch</span><span>(</span><span>NamingException</span> ne<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>EJBException</span><span>(</span>ne<span>)</span><span>;</span>
        <span>}</span>
    <span>catch</span><span>(</span><span>SQLException</span> se<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>EJBException</span><span>(</span>se<span>)</span><span>;</span>
        <span>}</span>
    <span>catch</span><span>(</span><span>RemoteException</span> re<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>EJBException</span><span>(</span>re<span>)</span><span>;</span>
        <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><br>
<h2 id="_0721-다이나믹-테스트-dynamic-test"> 0721 - 다이나믹 테스트(Dynamic Test)</h2>
<h3 id="다이나믹-테스트-dynamic-test-란"> 다이나믹 테스트(Dynamic Test)란?</h3>
<p>다이나믹 테스트에 대해 알아보기 전에 상대되는 개념인 정적 테스트와 함께 개념을 비교해서 특징을 한번 살펴보자.</p>
<p>JUnit을 이용해서 테스트를 작성하게 되면 보통 <code>@Test</code>라는 어노테이션을 사용 해서 테스트 케이스를 작성하게 되는데, 이와 같은 방식의 테스트를 정적 테스트라고 한다. 정적 테스트는 컴파일 시점에 코드가 지정된다는 특징을 가지고 있다. 가정은 동적인 기능에 대한 기본 테스트 형태를 제공하지만, 그 표현이 컴파일 시점에 제한된다는 한계를 가지고 있다.</p>
<p>이에 비해 다이나믹 테스트는 런타임 동안에 테스트가 생성되고 수행된다. 그래서 프로그램이 수행되는 도중에도 동작을 변경할 수 있는 특징이 있다. 이 다이나믹 테스트는 <code>@Test</code>어노테이션을 사용하지 않고, <code>@TestFactory</code> 어노테이션을 통해 팩토리 메서드로 생성된다.</p>
<h3 id="다이나믹-테스트의-장점"> 다이나믹 테스트의 장점</h3>
<blockquote>
<ol>
<li>유연성</li>
</ol>
</blockquote>
<p>다이나믹 테스트를 작성하는 가장 큰 이유는 아마도 런타임 시점에 테스트 케이스를 생성할 수 있다는 유연성을 꼽을 수 있다.</p>
<div><pre><code><span>@ParameterizedTest</span>
<span>@ValueSource</span><span>(</span>ints <span>=</span> <span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>}</span><span>)</span>
<span>void</span> <span>isUnderTenTest</span><span>(</span><span>int</span> number<span>)</span> <span>{</span>
  <span>boolean</span> result <span>=</span> <span>isUnderTen</span><span>(</span>number<span>)</span><span>;</span>
  
  <span>assertThat</span><span>(</span>result<span>)</span><span>.</span><span>isTrue</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>@TestFactory</span>
<span>Stream</span><span><span>&lt;</span><span>DynamicTest</span><span>></span></span> <span>isUnderTenTest</span><span>(</span><span>)</span> <span>{</span>
  <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> numbers <span>=</span> <span>getNumberFromDatabase</span><span>(</span><span>)</span> <span>// 1, 2, 3, 4, 5, 6, 7, 8, 9</span>

  <span>return</span> numbers<span>.</span><span>stream</span><span>(</span><span>)</span>
      <span>.</span><span>map</span><span>(</span>num <span>-></span> <span>dynamicTest</span><span>(</span>num <span>+</span> <span>"가 10미만인지 검사"</span><span>,</span>
          <span>(</span><span>)</span> <span>-></span> <span>{</span>
               <span>boolean</span> result <span>=</span> <span>isUnderTen</span><span>(</span>num<span>)</span><span>;</span>
               <span>assertThat</span><span>(</span>result<span>)</span><span>.</span><span>isTrue</span><span>(</span><span>)</span><span>;</span>
          <span>}</span>
    <span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>테스트하고자 하는 메서드가 도메인 핵심 로직을 수행하는 메서드이고, 동적으로 여러 테스트 케이스를 검증이 필요하다면 다이나믹 테스트가 훨씬 유용한 방법이 된다.<br>
다이나믹 테스트의 강력함은 테스트 케이스가 동적으로 생성되고 수행되기 때문에, 여러 dynamicTest안에서 데이터 결과를 공유하고 연속성 있는 테스트를 작성할 수 있다는 것이다.</p>
<blockquote>
<ol start="2">
<li>가독성</li>
</ol>
</blockquote>
<p>인수테스트 처럼 하나의 메서드 안에서 사용자 시나리오를 작성해야할 경우</p>
<div><pre><code><span>/*
Feature: 지하철 노선 관리

  Scenario: 지하철 노선을 관리한다.
    When 지하철 노선 n개 추가 요청을 한다.
    Then 지하철 노선이 추가 되었다.
    
    When 지하철 노선 목록 조회 요청을 한다.
    Then 지하철 노선 목록을 응답 받는다.
    And 지하철 노선 목록은 n개이다.
    
    When 지하철 노선 수정 요청을 한다.
    Then 지하철 노선이 수정 되었다.

    When 지하철 노선 제거 요청을 한다.
    Then 지하철 노선이 제거 되었다.
    
    When 지하철 노선 목록 조회 요청을 한다.
    Then 지하철 노선 목록을 응답 받는다.
    And 지하철 노선 목록은 n-1개이다.
 */</span>
<span>@DisplayName</span><span>(</span><span>"지하철 노선을 관리한다."</span><span>)</span>
<span>@Test</span>
<span>void</span> <span>manageLine</span><span>(</span><span>)</span> <span>{</span>
    <span>// when</span>
    <span>createLine</span><span>(</span><span>"신분당선"</span><span>)</span><span>;</span>
    <span>createLine</span><span>(</span><span>"1호선"</span><span>)</span><span>;</span>
    <span>createLine</span><span>(</span><span>"2호선"</span><span>)</span><span>;</span>
    <span>createLine</span><span>(</span><span>"3호선"</span><span>)</span><span>;</span>
    <span>// then</span>
    <span>List</span><span><span>&lt;</span><span>LineResponse</span><span>></span></span> lines <span>=</span> <span>getLines</span><span>(</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>lines<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>4</span><span>)</span><span>;</span>
  
    <span>// when</span>
    <span>LineResponse</span> line <span>=</span> <span>getLine</span><span>(</span>lines<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>//then</span>
    <span>assertThat</span><span>(</span>line<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>line<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>line<span>.</span><span>getStartTime</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>line<span>.</span><span>getEndTime</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>line<span>.</span><span>getIntervalTime</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
  
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><div><pre><code><span>@DisplayName</span><span>(</span><span>"노선을 관리한다."</span><span>)</span>
<span>@TestFactory</span>
<span>Stream</span><span><span>&lt;</span><span>DynamicTest</span><span>></span></span> <span>dynamicTestsFromCollection</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>Stream</span><span>.</span><span>of</span><span>(</span>
        <span>dynamicTest</span><span>(</span><span>"노선을 만드는 요청으로 새로운 노선을 생성한다."</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>// when</span>
            <span>createLine</span><span>(</span><span>"신분당선"</span><span>)</span><span>;</span>
            <span>createLine</span><span>(</span><span>"1호선"</span><span>)</span><span>;</span>
            <span>createLine</span><span>(</span><span>"2호선"</span><span>)</span><span>;</span>
            <span>createLine</span><span>(</span><span>"3호선"</span><span>)</span><span>;</span>

            <span>// then</span>
            <span>List</span><span><span>&lt;</span><span>LineResponse</span><span>></span></span> lines <span>=</span> <span>getLines</span><span>(</span><span>)</span><span>;</span>
            <span>assertThat</span><span>(</span>lines<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>4</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>,</span>
    
        <span>dynamicTest</span><span>(</span><span>"생성된 노선 목록을 불러온다."</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>// given</span>
            <span>List</span><span><span>&lt;</span><span>LineResponse</span><span>></span></span> lines <span>=</span> <span>getLines</span><span>(</span><span>)</span><span>;</span>
 
            <span>// when  </span>
            <span>LineResponse</span> line <span>=</span> lines<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>;</span>
 
            <span>// then</span>
            <span>assertThat</span><span>(</span>line<span>.</span><span>getId</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
            <span>assertThat</span><span>(</span>line<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
            <span>assertThat</span><span>(</span>line<span>.</span><span>getStartTime</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
            <span>assertThat</span><span>(</span>line<span>.</span><span>getEndTime</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
            <span>assertThat</span><span>(</span>line<span>.</span><span>getIntervalTime</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isNotNull</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>,</span>
      
        <span>.</span><span>.</span><span>.</span>
    <span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><h3 id="다이나믹-테스트-작성밥법"> 다이나믹 테스트 작성밥법</h3>
<h4 id="_1-testfactory-어노테이션-사용"> 1. @TestFactory 어노테이션 사용</h4>
<ul>
<li>@TestFactory 메소드는 테스트 케이스를 생산하는 팩토리이다.</li>
<li>@TestFactory 메서드는 private 또는 static이면 안된다.</li>
</ul>
<h4 id="_2-컬렉션-반환"> 2. 컬렉션 반환</h4>
<ul>
<li>@TestFactory 메서드는 Stream, Collection, Iterable 또는 Iterato 를 return 해야 한다. 그렇지 않으면, JUnitException을 발생 시킨다.</li>
<li>테스트 수는 동적이며, ArrayList 크기에 따라 달라진다.</li>
</ul>
<h4 id="_3-첫번째-인자로-테스트-이름-작성"> 3. 첫번째 인자로 테스트 이름 작성</h4>
<ul>
<li>dynamicTest 는 테스트 이름과, 실행 함수 두 요소로 이루어져있다</li>
<li>그 만큼 테스트 이름을 잘 작성해주는 것이 가독성을 높이는 측면에서도 중요하다</li>
</ul>
<div><pre><code><span>@TestFactory</span>
<span>Stream</span><span><span>&lt;</span><span>DynamicTest</span><span>></span></span> <span>exampleDynamicTest</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>Stream</span><span>.</span><span>of</span><span>(</span>
        <span>dynamicTest</span><span>(</span><span>"First Dynamic Test"</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>// test code</span>
        <span>}</span><span>)</span><span>,</span>
        <span>dynamicTest</span><span>(</span><span>"Second Dynamic test"</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>// test code</span>
        <span>}</span><span>)</span>
    <span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h4 id="주의-사항"> 주의 사항</h4>
<blockquote>
<p>다이나믹 테스트는 JUnit의 생명주기 콜백함수를 지원하지 않는다. 그러므로 @BeforeEach나 @AfterEach와 같은 테스트 생명 주기와 관련된 요소들을 사용할 수 없다</p>
</blockquote>
<br>
<h2 id="_0722-assertj-필수기능정리"> 0722 - AssertJ 필수기능정리</h2>
<p>https://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html</p>
<h3 id="assertj란"> AssertJ란?</h3>
<p>자바 테스트를 위해 좀 더 풍부한 문법을 제공하고 메서드 체이닝을 통해 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리</p>
<blockquote>
<p>예제</p>
</blockquote>
<div><pre><code><span>@Test</span>
  <span>public</span> <span>void</span> <span>split</span><span>(</span><span>)</span> <span>{</span>
    <span>String</span><span>[</span><span>]</span> values <span>=</span> <span>"1,2"</span><span>.</span><span>split</span><span>(</span><span>","</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>values<span>)</span><span>.</span><span>containsExactly</span><span>(</span><span>"1"</span><span>,</span> <span>"2"</span><span>)</span><span>;</span>

    values <span>=</span> <span>"1"</span><span>.</span><span>split</span><span>(</span><span>","</span><span>)</span><span>;</span>
    <span>assertThat</span><span>(</span>values<span>)</span><span>.</span><span>containsExactly</span><span>(</span><span>"1"</span><span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>JUnit5의 경우, assertEquals(expected, actual)과 같이 두 개의 인자를 받아서 비교를 하지만, AssertJ는 메소드 체이닝을 통해 가독성을 높여주는 특징이 있습니다. assertEquals()는 왼쪽이 expected인지 actual인지 혼동될 여지가 있지만, assertThat()은 actual 인자 하나만 요구하고 그 뒤로 메소드 체이닝을 하므로 acutal과 expected를 명확하게 구분지어준다는 장점이 있습니다.</p>
<h4 id="test-fail-message"> Test Fail Message</h4>
<p>JUnit5의 경우, 마지막 인자값에 선택적으로 메시지를 넣어줌으로써 테스트 실패 메시지를 명시할 수 있는데, AssertJ에서는 as()를 호출하여 사용합니다. 단, assertion이 수행되기 전에 사용해야 합니다.</p>
<div><pre><code><span>TolkienCharacter</span> frodo <span>=</span> <span>new</span> <span>TolkienCharacter</span><span>(</span><span>"Frodo"</span><span>,</span> <span>33</span><span>,</span> HOBBIT<span>)</span><span>;</span>
 <span>// failing assertion, remember to call as() before the assertion, not after !</span>
 <span>assertThat</span><span>(</span>frodo<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"check %s's age"</span><span>,</span> frodo<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>100</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>만약, frodo의 나이가 100과 같지 않다면 &quot;check 33's age&quot;와 같은 오류 메시지를 출력한다.</p>
<h4 id="filtering-assertions"> Filtering assertions</h4>
<div><pre><code><span>import</span> <span>static</span> <span>org<span>.</span>assertj<span>.</span>core<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>in<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>assertj<span>.</span>core<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>not<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>assertj<span>.</span>core<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>notIn<span>;</span>
<span>.</span><span>.</span><span>.</span>

<span>// filters use introspection to get property/field values</span>
<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>filteredOn</span><span>(</span><span>"race"</span><span>,</span> HOBBIT<span>)</span>
                               <span>.</span><span>containsOnly</span><span>(</span>sam<span>,</span> frodo<span>,</span> pippin<span>,</span> merry<span>)</span><span>;</span>

<span>// nested properties are supported</span>
<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>filteredOn</span><span>(</span><span>"race.name"</span><span>,</span> <span>"Man"</span><span>)</span>
                               <span>.</span><span>containsOnly</span><span>(</span>aragorn<span>,</span> boromir<span>)</span><span>;</span>

<span>// you can apply different comparison</span>
<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>filteredOn</span><span>(</span><span>"race"</span><span>,</span> <span>notIn</span><span>(</span>HOBBIT<span>,</span> MAN<span>)</span><span>)</span>
                               <span>.</span><span>containsOnly</span><span>(</span>gandalf<span>,</span> gimli<span>,</span> legolas<span>)</span><span>;</span>

<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>filteredOn</span><span>(</span><span>"race"</span><span>,</span> <span>in</span><span>(</span>MAIA<span>,</span> MAN<span>)</span><span>)</span>
                               <span>.</span><span>containsOnly</span><span>(</span>gandalf<span>,</span> boromir<span>,</span> aragorn<span>)</span><span>;</span>

<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>filteredOn</span><span>(</span><span>"race"</span><span>,</span> <span>not</span><span>(</span>HOBBIT<span>)</span><span>)</span>
                               <span>.</span><span>containsOnly</span><span>(</span>gandalf<span>,</span> boromir<span>,</span> aragorn<span>,</span> gimli<span>,</span> legolas<span>)</span><span>;</span>

<span>// you can chain multiple filter criteria</span>
<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>filteredOn</span><span>(</span><span>"race"</span><span>,</span> MAN<span>)</span>
                               <span>.</span><span>filteredOn</span><span>(</span><span>"name"</span><span>,</span> <span>not</span><span>(</span><span>"Boromir"</span><span>)</span><span>)</span>
                               <span>.</span><span>containsOnly</span><span>(</span>aragorn<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>람다식을 사용하여 필터링도 가능하다</p>
<h4 id="assertions-on-extracted-properties-fields-of-iterable-array-elements"> Assertions on extracted properties/fields of iterable/array elements</h4>
<div><pre><code><span>// extract the names ...</span>
<span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> names <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>for</span> <span>(</span><span>TolkienCharacter</span> tolkienCharacter <span>:</span> fellowshipOfTheRing<span>)</span> <span>{</span>
  names<span>.</span><span>add</span><span>(</span>tolkienCharacter<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>// ... and finally assert something</span>
<span>assertThat</span><span>(</span>names<span>)</span><span>.</span><span>contains</span><span>(</span><span>"Boromir"</span><span>,</span> <span>"Gandalf"</span><span>,</span> <span>"Frodo"</span><span>,</span> <span>"Legolas"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>extracing()</li>
</ul>
<div><pre><code><span>// 단일필드검사</span>
<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>extracting</span><span>(</span><span>"name"</span><span>,</span> <span>String</span><span>.</span><span>class</span><span>)</span>
                               <span>.</span><span>contains</span><span>(</span><span>"Boromir"</span><span>,</span> <span>"Gandalf"</span><span>,</span> <span>"Frodo"</span><span>,</span> <span>"Legolas"</span><span>)</span>
                               <span>.</span><span>doesNotContain</span><span>(</span><span>"Sauron"</span><span>,</span> <span>"Elrond"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>// 여러필드검사</span>
<span>import</span> <span>static</span> <span>org<span>.</span>assertj<span>.</span>core<span>.</span>api<span>.</span></span><span>Assertions</span><span>.</span>tuple<span>;</span>

<span>// extracting name, age and and race.name nested property</span>
<span>assertThat</span><span>(</span>fellowshipOfTheRing<span>)</span><span>.</span><span>extracting</span><span>(</span><span>"name"</span><span>,</span> <span>"age"</span><span>,</span> <span>"race.name"</span><span>)</span>
                               <span>.</span><span>contains</span><span>(</span><span>tuple</span><span>(</span><span>"Boromir"</span><span>,</span> <span>37</span><span>,</span> <span>"Man"</span><span>)</span><span>,</span>
                                         <span>tuple</span><span>(</span><span>"Sam"</span><span>,</span> <span>38</span><span>,</span> <span>"Hobbit"</span><span>)</span><span>,</span>
                                         <span>tuple</span><span>(</span><span>"Legolas"</span><span>,</span> <span>1000</span><span>,</span> <span>"Elf"</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="soft-assertions"> Soft assertions</h4>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>host_dinner_party_where_nobody_dies</span><span>(</span><span>)</span> <span>{</span>
   <span>Mansion</span> mansion <span>=</span> <span>new</span> <span>Mansion</span><span>(</span><span>)</span><span>;</span>
   mansion<span>.</span><span>hostPotentiallyMurderousDinnerParty</span><span>(</span><span>)</span><span>;</span>
   <span>// use SoftAssertions instead of direct assertThat methods</span>
   <span>SoftAssertions</span> softly <span>=</span> <span>new</span> <span>SoftAssertions</span><span>(</span><span>)</span><span>;</span>
   softly<span>.</span><span>assertThat</span><span>(</span>mansion<span>.</span><span>guests</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"Living Guests"</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>7</span><span>)</span><span>;</span>
   softly<span>.</span><span>assertThat</span><span>(</span>mansion<span>.</span><span>kitchen</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"Kitchen"</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"clean"</span><span>)</span><span>;</span>
   softly<span>.</span><span>assertThat</span><span>(</span>mansion<span>.</span><span>library</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"Library"</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"clean"</span><span>)</span><span>;</span>
   softly<span>.</span><span>assertThat</span><span>(</span>mansion<span>.</span><span>revolverAmmo</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"Revolver Ammo"</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>6</span><span>)</span><span>;</span>
   softly<span>.</span><span>assertThat</span><span>(</span>mansion<span>.</span><span>candlestick</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"Candlestick"</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"pristine"</span><span>)</span><span>;</span>
   softly<span>.</span><span>assertThat</span><span>(</span>mansion<span>.</span><span>colonel</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"Colonel"</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"well kempt"</span><span>)</span><span>;</span>
   softly<span>.</span><span>assertThat</span><span>(</span>mansion<span>.</span><span>professor</span><span>(</span><span>)</span><span>)</span><span>.</span><span>as</span><span>(</span><span>"Professor"</span><span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"well kempt"</span><span>)</span><span>;</span>
   <span>// Don't forget to call SoftAssertions global verification !</span>
   softly<span>.</span><span>assertAll</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>모든 assertions을 실행한 후 실패 내역을 확인</p>
<h3 id="exception-assertions"> Exception assertions</h3>
<div><pre><code><span>@ParameterizedTest</span>
  <span>@ValueSource</span><span>(</span>strings <span>=</span> <span>{</span><span>""</span><span>,</span> <span>"spring"</span><span>}</span><span>)</span>
  <span>@DisplayName</span><span>(</span><span>"이름 길이가 0 이하 또는 5 이상일 때 에러 확인"</span><span>)</span>
  <span>void</span> <span>car_name_exception</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
    <span>assertThatThrownBy</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>new</span> <span>Car</span><span>(</span>name<span>)</span><span>)</span>
        <span>.</span><span>isInstanceOf</span><span>(</span><span>IllegalStateException</span><span>.</span><span>class</span><span>)</span>
        <span>.</span><span>hasMessageContaining</span><span>(</span><span>"이름 길이는 0이하 또는 5이상이어야 합니다."</span><span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><br>
<h2 id="_0723-자바-자료구조"> 0723 - 자바 자료구조</h2>
<p>자바 자료구조 구조 및 사용법 정리</p>
<h3 id="큐-queue"> 큐(Queue)</h3>
<p>순서대로 처리되는 자료구조(FIFO : First In First Out)</p>
<ul>
<li>Enqueue : 큐 맨 뒤에 데이터 추가</li>
<li>Dequeue : 큐 맨앞쪽의 데이터 삭제</li>
</ul>
<h4 id="queue-특징"> Queue 특징</h4>
<ul>
<li>FIFO(First In First Out) 구조</li>
<li>큐는 한 쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행함</li>
<li>다른 한 쪽 끝은 리어(rear)로 정하여 삽입 연산만 수행함</li>
<li>그래프의 넓이 우선 탐색(BFS)에서 사용</li>
<li>컴퓨터 버퍼에서 주로 사용, 마구 입력이 되었으나 처리를 하지 못할 때, 버퍼(큐)를 만들어 대기</li>
</ul>
<h4 id="queue-사용법"> Queue 사용법</h4>
<ul>
<li>선언</li>
</ul>
<div><pre><code><span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> intQueue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
<span>Queue</span><span><span>&lt;</span><span>String</span><span>></span></span> stringQueue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>값 추가</li>
</ul>
<div><pre><code><span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
queue<span>.</span><span>add</span><span>(</span><span>1</span><span>)</span><span>;</span>
queue<span>.</span><span>add</span><span>(</span><span>2</span><span>)</span><span>;</span>
queue<span>.</span><span>offer</span><span>(</span><span>3</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>값 삭제</li>
</ul>
<div><pre><code><span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>

queue<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>   <span>// 첫번째 값 반환 및 제거 비어있을시 null</span>
queue<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span> <span>// 첫번째 값 제거</span>
queue<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>  <span>// 초기화</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>첫번째 값 출력</li>
</ul>
<div><pre><code><span>Queue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>List</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>

queue<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>   <span>// 출력</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="스택-stack"> 스택(Stack)</h3>
<p>데이터를 쌓아올리는 자료구조(Last In First Out)</p>
<h4 id="특징"> 특징</h4>
<ul>
<li>먼저 들어간 자료가 나중에 나옴 LIFO(Last In First Out)</li>
<li>시스템 해킹에서 버퍼오버플로우 취약점을 이용한 공격을 할 때 스택메모리의 영역에서 함</li>
<li>인터럽트 처리, 수식의 계산, 서브루틴의 복귀 번지 저장 등에 쓰임</li>
<li>그래프의 깊이 우선 탐색(DFS)에서 사용</li>
<li>재귀적(Recursion) 함수를 호출 할 때 사용</li>
</ul>
<h4 id="stack-사용법"> stack 사용법</h4>
<ul>
<li>선언</li>
</ul>
<div><pre><code><span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>값 추가</li>
</ul>
<div><pre><code><span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

stack<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span><span>;</span>
stack<span>.</span><span>push</span><span>(</span><span>2</span><span>)</span><span>;</span>
stack<span>.</span><span>push</span><span>(</span><span>3</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>값 삭제</li>
</ul>
<div><pre><code><span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

stack<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span><span>;</span>
stack<span>.</span><span>push</span><span>(</span><span>2</span><span>)</span><span>;</span>
stack<span>.</span><span>push</span><span>(</span><span>3</span><span>)</span><span>;</span>

stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>
stack<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>상단 값 출력</li>
</ul>
<div><pre><code><span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

stack<span>.</span><span>push</span><span>(</span><span>1</span><span>)</span><span>;</span>
stack<span>.</span><span>push</span><span>(</span><span>2</span><span>)</span><span>;</span>
stack<span>.</span><span>push</span><span>(</span><span>3</span><span>)</span><span>;</span>

stack<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
      <enclosure url="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAq1DL%2FbtqvtfTTA4N%2F5UelKaZfgzz0ZGyvBbfoY0%2Fimg.png" type="image/png"/>
    </item>
    <item>
      <title>0822 ~ 0911</title>
      <link>ahnjs/TIL/2022/0822/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0822/</guid>
      <source url="ahnjs/TIL/rss.xml">0822 ~ 0911</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0822-0911"> 0822 ~ 0911</h1>
<h2 id="_0823-elk"> 0823 - ELK</h2>
<h3 id="elk란"> ELK란?</h3>
<p>ELK는 Elasticsearch, Logstash, Kibana의 앞글자를 따와서 만든 약어이다.</p>
<ul>
<li>Elasticsearch는 검색 및 분석 엔진</li>
<li>Logstash는 데이터를 수집하여 변환 후 Elastic search같은 서버로 전송하는 데이터 처리 파이프라인</li>
<li>Kibana는 사용자가 수집한 데이터를 시각화하여 볼 수 있다.<br>
즉, 데이터를 수집해 시각화 하는 오픈소스</li>
</ul>
<p>ELK는 오픈소스로, 무료로 사용이 가능하다.<br>
클라우드 같이 많은 데이터를 수집하는 서버는 로그가 많아 분석하는데 어려움이 존재하는데, 로그 파일의 용량이 커져 디스크 공간이 부족하거나, 특정 로그를 검색하기엔 너무 데이터가 많아 찾기 어려운 부분이 있다.<br>
그래서 ELK를 사용하여 로그의 분석 및 검색을 효율적으로 할 수 있다는 장점이 있다. ㅇ여기에 데이터 수집을 하는 Filebeat가 추가되면서 ELK Stack으로 불리게 되었다.</p>
<h3 id="elk-stack"> ELK Stack</h3>
<h4 id="_1-elastic-search"> 1. Elastic search</h4>
<ul>
<li>Apache Lucene 기반의 Java 오픈소스 분산 검색엔진.</li>
<li>Elasticsearch는 Logstash로부터 받은 데이터를 검색 및 분석하여 필요한 정보를 얻을수 있다.</li>
<li>얼마나 빠르냐면 10년치 데이터를 OracleDB에서 검색하면 1달정도 기다려야 결과를 볼 수 있는데, Elasticsearch를 사용하여 검색하니 결과가 단 몇분만에 나올 수 있다.</li>
</ul>
<h4 id="_2-logstash"> 2. Logstash</h4>
<ul>
<li>scv, DB 등 다양한 소스에서 로그 등의 데이터를 수집, 집계, 파싱하여 Elasticsearch로 전달.</li>
<li>서버측 데이터 처리 파이프 라인으로 데이터 수집 엔진이다.</li>
</ul>
<h4 id="_3-kibana"> 3. Kibana</h4>
<ul>
<li>Elasticsearch와 함께 동작하도록 설꼐된 오픈소스 분석 및 시각화 플랫폼.</li>
<li>히스토그램, 선형 그래프, 원형 차트 등 다양한 차트 및 분석에 대해 시각화할 수 있는 기능을 제공.</li>
</ul>
<h4 id="_4-filebeat"> 4. Filebeat</h4>
<ul>
<li>서버에 에이전트로 설치하여 다양한 유형의 데이터를 Elasticsearch 또는 Logstash에 전송하는 데이터 전달자이다.</li>
<li>Filebeat은로그 데이터를 지정하는 inputs를 가지는데, 여기서 데이터가 발생할 때마다 수집하여 전송.</li>
</ul>
<br>
<h2 id="_0829-mockmvc-vs-restassured"> 0829 - MockMvc vs Restassured</h2>
<h3 id="mockmvc"> MockMvc</h3>
<h4 id="사용목적"> 사용목적</h4>
<p>MockMvc는 웹 어플리케이션을 애플리케이션 서버에 배포하지 않고도 스프링 MVC의 동작을 재현할 수 있는 라이브러리이며 대부분 Controller Layer Unit Test(단위 테스트)에 사용된다.</p>
<p>실제 서버 환경과 동일한 @SpringBootTest를 사용할 필요가 없으므로 @WebMvcTest를 통해 Presentation Layer Bean들만 불로온다. 그리고 그 외 Bean은 Mock 객체 설정을 해주어 순수한 Controller 로직을 테스트한다.</p>
<h4 id="의존성"> 의존성</h4>
<p>MockMvc는 Spring Framework Test 클래스 중 하나다. 즉 Spring test 의존성이 추가되어있는 경우 별도의 의존성 추가를 하지 않아도 사용할 수 있다.</p>
<h4 id="속도"> 속도</h4>
<p>MockMvc는 별도의 구성없이도 @WebMvcTest로 테스트를 수행할 수 있다. 물론 @SpringBootTest로도 수행할 수 있다. MockMvc를 @WebMvcTest로 수행하는 방법은 아래와 같다.</p>
<div><pre><code><span>@WebMvcTest</span>
<span>@AutoConfigureMockMvc</span>
<span>public</span> <span>class</span> <span>ApiTest</span> <span>{</span>
    <span>@Autowired</span>
    <span>private</span> <span>MockMvc</span> mockMvc<span>;</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="가독성"> 가독성</h4>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>getMember</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
    mockMvc<span>.</span><span>perform</span><span>(</span><span>get</span><span>(</span><span>"/members/1"</span><span>)</span>
            <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span><span>)</span>
            <span>.</span><span>andExpect</span><span>(</span><span>status</span><span>(</span><span>)</span><span>.</span><span>isOk</span><span>(</span><span>)</span><span>)</span>
            <span>.</span><span>andExpect</span><span>(</span><span>jsonPath</span><span>(</span><span>"$.id"</span><span>,</span> <span>Matchers</span><span>.</span><span>is</span><span>(</span><span>1</span><span>)</span><span>)</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="restassured"> RestAssured</h3>
<h4 id="사용목적-2"> 사용목적</h4>
<p>RestAssured는 REST 웹 서비스를 겁증하기 위한 라이브러리이며 대부분 End-to-End Test(전 구간 테스트)에 사용된다.</p>
<p>@SpringBootTest로 실제 요청을 보내서 전체적인 로직을 테스트한다. 실제 요청시 필요한 다양한 메서드도 제공한다.</p>
<h4 id="의존성-2"> 의존성</h4>
<p>RestAssured는 직접 의존성을 추가해줘야 한다.</p>
<div><pre><code>dependencies {
    testImplementation &#39;io.rest-assured:rest-assured:3.3.0&#39;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="속도-2"> 속도</h4>
<p>RestAssured는 별도의 구성없이 @WebMvcTest를 사용하지 못한다. 사용하기 위해선 아래와 같이 @SpringBootTest로 수행해야 한다.</p>
<div><pre><code><span>@SpringBootTest</span><span>(</span>webEnvironment <span>=</span> <span>SpringBootTest<span>.</span>WebEnvironment</span><span>.</span>RANDOM_PORT<span>)</span>
<span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>@LocalServerPort</span>
    <span>public</span> <span>int</span> port<span>;</span>

    <span>@BeforeEach</span>
    <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>
        <span>RestAssured</span><span>.</span>port <span>=</span> port<span>;</span>
    <span>}</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>@SpringBootTest로 테스트를 수행하면 등록된 Spring Bean을 전부 로드하기 때문에 시간이 오래 걸린다. 반면에 @WebMvcTest는 Presentation Layer의 Bean들만 로드하기 때문에 시간이 상대적으로 빠르다.</p>
<h4 id="가독성-2"> 가독성</h4>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>getMember</span><span>(</span><span>)</span> <span>{</span>
    <span>given</span><span>(</span><span>)</span><span>.</span>
            <span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span><span>.</span>
    <span>when</span><span>(</span><span>)</span><span>.</span>
            <span>get</span><span>(</span><span>"/members/1"</span><span>)</span><span>.</span>
    <span>then</span><span>(</span><span>)</span><span>.</span>
            <span>log</span><span>(</span><span>)</span><span>.</span><span>all</span><span>(</span><span>)</span><span>.</span>
            <span>statusCode</span><span>(</span><span>HttpStatus</span><span>.</span>OK<span>)</span><span>.</span>
            <span>assertThat</span><span>(</span><span>)</span><span>.</span><span>body</span><span>(</span><span>"id"</span><span>,</span> <span>equalTo</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>RestAssured는 BDD 스타일로 작성할 수 있고 가독성이 좋다.</p>
<br>
<h2 id="_0904-객체지향-설계-5원칙-solid-srp-ocp-lsp-isp-dip"> 0904 - 객체지향 설계 5원칙 SOLID (SRP, OCP, LSP, ISP, DIP)</h2>
<h3 id="sold란"> SOLD란?</h3>
<ul>
<li>객체지향 설계는 긴 세월과 수많은 시행착오를 거치며 5가지 원칙이 정리되었다. 이것을 객체지향 설계의 5원칙이라고 하며, 앞글자를 따서 SOLID라고 한다.
<ol>
<li>SPR(Single Responsibility Principle) : 단일 책임 원칙</li>
<li>OCP(Open Closed Principle) : 개방 폐쇄 원칙</li>
<li>LSP(Liskov Substitution Principle) : 리스코프 치환 원칙</li>
<li>ISP(Interface Segregation Principle) : 인터페이스 분리 원칙</li>
<li>DIP(Dependency Inversion Principle) : 의존 역전 원칙
이 원칙들은 응집도는 높이고 결합도는 낮추자는 고전 원칙을 객체 지향의 관점에서 재정립한 것으로 볼 수 있다.</li>
</ol>
</li>
</ul>
<h3 id="srp-단일-책임-원칙"> SRP = 단일 책임 원칙</h3>
<p>어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다.</p>
<ul>
<li>SRP가 안지켜진 사례
<ul>
<li>변수레벨
<ul>
<li>하나의 속성이 여러 의미를 갖는 경우</li>
<li>어떤 곳에서는 쓰고, 어떤 곳에선 안쓰는 속성이 있는 경우</li>
</ul>
</li>
<li>메소드레벨
<ul>
<li>분기처리를 위한 if문이 많을 경우</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ocp-개방-폐쇄-원칙"> OCP = 개방 폐쇄 원칙</h3>
<p>소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. 즉, 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다는 것이다. 이것은 interface를 통해 구현하여 해결한다.<br>
현실의 예를들면 상점직원이 아무리 바뀐다고해서 손님이 상품을 구매하는 데는 지장이 없다.</p>
<h3 id="lsp-리스코프-치환-원칙"> LSP = 리스코프 치환 원칙</h3>
<p>서브타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다. 즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 수행하는데 문제가 없어야 한다. 이것은 OOP 4대 특성의 상속, 인터페이스 원칙이 잘 지켜진다면 LSP는 자동으로 잘 적용된 것이다. (주로 조직도, 계층도 관점에서의 상속이 LSP를 위배하는 문제가 생긴다)</p>
<h3 id="isp-인터페이스-분리-원칙"> ISP = 인터페이스 분리 원칙</h3>
<p>클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다. ISP는 SRP와 비슷하지만 인터페이스를 통한 다른 해결책을 제안하고 있다. 예를들어 <code>class 사람 implemnets 군인</code> 이면 <code>군인 홍길동 = new 사람()</code> 을 통해 군인 인터페이스의 메소드만을 사용하도록 제한하는 것이다. SRP 였다면 class를 나누겠지만, 일반적으론 ISP보다 SRP를 권장한다.</p>
<h3 id="dip-의존-역전-원칙"> DIP = 의존 역전 원칙</h3>
<p>고차원 모듈은 저차원 모듈에 의존하면 안된다. 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다. <code>자주 변경되는 클래스에 의존하지 말자.</code>로 요약 할 수 있다. 즉, 자신보다 변하기 쉬운 것에 의존하지 말라는 것이다. 해결방법은 OCP와 비슷한데, 구체적인 class가 아닌, 인터페이스에 의존함으로써 DIP를 해결한다.</p>
]]></content:encoded>
    </item>
    <item>
      <title>0808 ~ 0814</title>
      <link>ahnjs/TIL/2022/0808/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0808/</guid>
      <source url="ahnjs/TIL/rss.xml">0808 ~ 0814</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0808-0814"> 0808 ~ 0814</h1>
<h2 id="_0808-procedure와-function-차이"> 0808 - Procedure와 Function 차이</h2>
<h3 id="procedure-프로시저란"> [ Procedure 프로시저란? ]</h3>
<blockquote>
<p>데이터베이스에 대한 일련의 작업을 정리한 절차를 관계형 데이터베이스 관리 시스템에 저장한 것으로 영구저장모듈(Persistent Storage Module)이라고 불린다.<br>
일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리의 집합이다.<br>
즉, 하나의 작업을 수행하기 위한 쿼리의 모음이다.</p>
</blockquote>
<div><pre><code><span>CALL</span> 프로시저명<span>(</span><span>IN</span>파라미터명<span>,</span> <span>@OUT</span>파라미터명<span>)</span>
<span>EXECUTE</span> 프로시저명<span>(</span><span>IN</span>파라미터명<span>,</span> <span>@OUT</span>파라미터명<span>)</span>

<span>---</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>PROCEDURE</span> 프로시져이름 <span>(</span>파라미터<span>1</span><span>,</span>파라미터<span>2.</span><span>.</span><span>.</span><span>)</span><span>;</span>

<span>IS</span>
변수

<span>BEGIN</span>

쿼리문

<span>END</span> 프로시져 이름<span>;</span>

<span>---</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>PROCEDURE</span> GET_TIER<span>(</span>in_name <span>IN</span> VARCHAR2<span>,</span>out_tier <span>OUT</span> VARCHAR2<span>)</span>

<span>IS</span>

<span>BEGIN</span>
	
    <span>SELECT</span> TIER <span>INTO</span> out_tier <span>FROM</span> SUMMONER_TB <span>WHERE</span> NAME <span>=</span> in_name<span>;</span>

EXCEPTION
  <span>--소환사를 찾을 수 없을 때</span>
  WEHN NO_DATA_FOUND <span>THEN</span>
  
    out_tier:<span>=</span><span>'NO_SUMMONER_FOUND'</span><span>;</span>

<span>END</span> GET_TIER<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="function-함수란"> [ Function 함수란? ]</h3>
<blockquote>
<p>하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합.<br>
즉, 함수가 여러 작업을 위한 기능이라면 프로시저는 작업을 정리한 절차이다.<br>
보통 로직을 도와주는 역할이며, 간단한 계산, 수치 등을 나타낼 때 사용한다.</p>
</blockquote>
<div><pre><code><span>SELECT</span> 함수명<span>(</span><span>IN</span> 파라미터명<span>)</span> <span>FROM</span> DUAL<span>;</span>

<span>---</span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>FUNCTION</span> 함수이름<span>(</span>파라미터<span>1</span>이름 타입<span>,</span> 파라미터<span>2</span>이름 타입<span>.</span><span>.</span><span>.</span><span>)</span>
<span>RETURN</span> 반환할타입
<span>IS</span>
	변수 선언
<span>BEGIN</span>
	실행문 작성
	<span>RETURN</span> 반환할값
<span>END</span><span>;</span>

<span>--- </span>

<span>CREATE</span> <span>OR</span> <span>REPLACE</span> <span>FUNCTION</span> SUM_TWICE<span>(</span>n1 NUMBER<span>,</span> n2 NUMBER<span>)</span>
<span>RETURN</span> NUMBER
<span>IS</span>
	twice_sum  NUMBER :<span>=</span> <span>0</span><span>;</span>
<span>BEGIN</span>
	twice_sum :<span>=</span> <span>(</span>n1 <span>+</span> n2<span>)</span><span>*</span><span>2</span><span>;</span>
	<span>RETURN</span> twice_sum<span>;</span>
<span>END</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="함수와-프로시저의-차이"> [ 함수와 프로시저의 차이 ]</h3>
<p>프로시저 또한 매개변수를 받아 여러 작업을 수행하여 값을 반환할 수 있고, 함수 또한 매겨변수를 받아 여러 작업을 수행하여 값을 반환할 수 있다.</p>
<h4 id="매개변수"> 매개변수</h4>
<ul>
<li>프로시저는 매개변수를 입력, 출력, 입출력 형식으로 받을 수 있다.</li>
<li>함수는 매개변수를 입력 형식으로만 받을 수 있다.</li>
</ul>
<h4 id="반환값"> 반환값</h4>
<ul>
<li>프로시저는 반환값을 가질 수 도 있고 가지지 않을 수도 있다.</li>
<li>함수는 반환값을 반드시 가져야 한다.</li>
</ul>
<h4 id="쿼리문-내에서-실행가능"> 쿼리문 내에서 실행가능</h4>
<ul>
<li>프로시저는 SELECT, WHERE 문등에서 사용 불가하다.</li>
<li>함수는 SELECT, WHERE 문 등에서 사용이 가능하다.</li>
</ul>
<h4 id="처리-장소"> 처리 장소</h4>
<ul>
<li>프로시저는 클라이언트(화면)에서 값을 건네받아 서버에서 작업을 한 뒤 클라이언트에게 전달한다. 즉, 서버에서 실행이 되어 속도면에서 빠른 성능을 보여준다.</li>
<li>함수는 클라이언트(화면)에서 실행이 되어 프로시저보다 속도가 느리다.</li>
</ul>
<br>
<h2 id="_0809-feign-client"> 0809 - Feign Client</h2>
<p>페인은 넷플릭스에서 개발한 웹 서비스 클라이언트 도구(Http Client 모듈)로 애노테이션을 템플릿화된 요청으로 처리해 동작하는 HTTP 클라이언트 바인더다. 기존 HTTP client 작성을 쉽게 만들어주며 인터페이스를 만들고 애노테이션을 붙이는 방식이기 때문에 간단하게 사용할 수 있는 장점이 있다.</p>
<h3 id="feign-기본-사용법"> Feign 기본 사용법</h3>
<h4 id="의존성주입"> [ 의존성주입 ]</h4>
<ul>
<li>maven</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>properties</span><span>></span></span>
    <span><span><span>&lt;</span>spring.cloud-version</span><span>></span></span>Hoxton.SR8<span><span><span>&lt;/</span>spring.cloud-version</span><span>></span></span>
<span><span><span>&lt;/</span>properties</span><span>></span></span>
<span><span><span>&lt;</span>dependencyManagement</span><span>></span></span>
    <span><span><span>&lt;</span>dependencies</span><span>></span></span>
        <span><span><span>&lt;</span>dependency</span><span>></span></span>
            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.cloud<span><span><span>&lt;/</span>groupId</span><span>></span></span>
            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-cloud-dependencies<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
            <span><span><span>&lt;</span>version</span><span>></span></span>${spring.cloud-version}<span><span><span>&lt;/</span>version</span><span>></span></span>
            <span><span><span>&lt;</span>type</span><span>></span></span>pom<span><span><span>&lt;/</span>type</span><span>></span></span>
            <span><span><span>&lt;</span>scope</span><span>></span></span>import<span><span><span>&lt;/</span>scope</span><span>></span></span>
        <span><span><span>&lt;/</span>dependency</span><span>></span></span>
    <span><span><span>&lt;/</span>dependencies</span><span>></span></span>
<span><span><span>&lt;/</span>dependencyManagement</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ul>
<li>gradle</li>
</ul>
<div><pre><code>buildscript {
  dependencies {
    classpath &quot;io.spring.gradle:dependency-management-plugin:1.0.10.RELEASE&quot;
  }
}

ext {
  set(&#39;springCloudVersion&#39;, &quot;Hoxton.SR8&quot;)
}

apply plugin: &quot;io.spring.dependency-management&quot;

dependencyManagement {
  imports {
    mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:${springCloudVersion}&quot;
  }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="application"> [ Application ]</h4>
<div><pre><code><span>@SpringBootApplication</span>
<span>@EnableFeignClients</span>
<span>public</span> <span>class</span> <span>Application</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>Application</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>@EnableFeignClients 어노테이션이 지정된 package들을 돌아다니면서 @FeignClient 어노테이션을 찾아 구현체를 만들어 준다.</p>
<h4 id="interface-작성"> [ Interface 작성 ]</h4>
<div><pre><code><span>@FeignClient</span><span>(</span>name <span>=</span> <span>"stores"</span><span>,</span> configuration <span>=</span> <span>FooConfiguration</span><span>.</span><span>class</span><span>,</span> url <span>=</span> <span>"${feign.url}"</span><span>)</span>
<span>public</span> <span>interface</span> <span>StoreClient</span> <span>{</span>
    <span>@RequestMapping</span><span>(</span>method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>,</span> value <span>=</span> <span>"/stores"</span><span>)</span>
    <span>List</span><span><span>&lt;</span><span>Store</span><span>></span></span> <span>getStores</span><span>(</span><span>)</span><span>;</span>

    <span>@RequestMapping</span><span>(</span>method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>,</span> value <span>=</span> <span>"/stores"</span><span>)</span>
    <span>Page</span><span><span>&lt;</span><span>Store</span><span>></span></span> <span>getStores</span><span>(</span><span>Pageable</span> pageable<span>)</span><span>;</span>

    <span>@RequestMapping</span><span>(</span>method <span>=</span> <span>RequestMethod</span><span>.</span>POST<span>,</span> value <span>=</span> <span>"/stores/{storeId}"</span><span>,</span> consumes <span>=</span> <span>"application/json"</span><span>)</span>
    <span>Store</span> <span>update</span><span>(</span><span>@PathVariable</span><span>(</span><span>"storeId"</span><span>)</span> <span>Long</span> storeId<span>,</span> <span>Store</span> store<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>@FeignClent 어노테이션을 통해 feign을 사용하는 인터페이스라고 알린다.</li>
<li>configuration 옵션을 통해 default 값을 override 할 수 있다.</li>
<li>url 옵션을 통해 불러올 url을 세팅한다.</li>
</ul>
<h4 id="service-작성"> [ Service 작성 ]</h4>
<div><pre><code><span>@Service</span>
<span>public</span> <span>class</span> <span>StoreService</span> <span>{</span>
    
    <span>private</span> <span>final</span> <span>StoreClient</span> storeClient<span>;</span>

	<span>public</span> <span>StoreService</span><span>(</span><span>StoreClient</span> storeClient<span>)</span> <span>{</span>
		<span>this</span><span>.</span>storeClient <span>=</span> storeClient<span>;</span>
	<span>}</span>

    <span>public</span> <span>List</span><span><span>&lt;</span><span>Store</span><span>></span></span> <span>getStores</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> storeClient<span>.</span><span>getStores</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><ul>
<li>getStores()를 호출하여 FeignClient를 호출한다.</li>
</ul>
<br>
<h2 id="_0811-jenkins-pipeline"> 0811 - jenkins pipeline</h2>
<p>웹훅없이 기본적이 pipeline으로 클론, 빌드, 배포까지만 진행하는 방법</p>
<h4 id="credentials-세팅"> [ Credentials 세팅 ]</h4>
<ul>
<li>Jenkins 관리 -&gt; Manage Credentials -&gt; Add Credentials</li>
<li>Jenkins 관리 -&gt; 시스템 설정 -&gt; GitHub -&gt; 서버등록</li>
</ul>
<h4 id="git-parameter"> [ Git Parameter ]</h4>
<ul>
<li>Git Parameter Plug-In 설치</li>
<li>파이프라인 -&gt; 매개변수 설정</li>
</ul>
<h4 id="ssh-서버로-파일전송"> [ SSH 서버로 파일전송 ]</h4>
<ul>
<li>publish over ssh 플러그인 설치</li>
<li>Jenkins 관리 -&gt; 시스템 설정 -&gt; 원격 서버 설정</li>
</ul>
<h4 id="파이프-라인-생성"> [ 파이프 라인 생성 ]</h4>
<ul>
<li>새로운 item -&gt; 파이프라인 생성</li>
<li>Pipeline Syntax통해 스니펫 설정</li>
</ul>
<div><pre><code>pipeline <span>{</span>
    agent any
    parameters <span>{</span>
        gitParameter branchFilter: <span>'origin/(.*)'</span>, defaultValue: <span>'develop'</span>, name: <span>'BRANCH'</span>, type: <span>'PT_BRANCH'</span>
    <span>}</span>
    stages <span>{</span>
        stage<span>(</span><span>'github clone'</span><span>)</span> <span>{</span>
            steps <span>{</span>
                <span>git</span> branch: <span>"<span>${params.BRANCH}</span>"</span>, credentialsId: <span>'jaesungahn91'</span>, url: <span>'https://github.com/wiiee-kr/wiiee-server.git'</span>
            <span>}</span>
        <span>}</span>
        
        stage<span>(</span><span>'build'</span><span>)</span><span>{</span>
            steps<span>{</span>
                <span>sh</span><span>''</span>'
                    ./gradlew api:clean api:bootJar
                <span>''</span>'
            <span>}</span>
        <span>}</span>   
        
        stage<span>(</span><span>'publish on ssh'</span><span>)</span><span>{</span>
            steps<span>{</span>
                sshPublisher<span>(</span>
                  publishers: 
                    <span>[</span>
                      sshPublisherDesc<span>(</span>
                        configName: <span>'wiiee-api-test'</span>, 
                        transfers: 
                          <span>[</span>
                            sshTransfer<span>(</span>
                              cleanRemote: false, 
                              excludes: <span>''</span>,
                              execCommand: <span>'sh /home/ec2-user/deploy.sh'</span>, 
                              execTimeout: <span>120000</span>, 
                              flatten: false, 
                              makeEmptyDirs: false, 
                              noDefaultExcludes: false, 
                              patternSeparator: <span>'[, ]+'</span>, 
                              remoteDirectory: <span>'./'</span>, 
                              remoteDirectorySDF: false, 
                              removePrefix: <span>'api/build/libs/'</span>, 
                              sourceFiles: <span>'api/build/libs/*.jar'</span><span>)</span>
                          <span>]</span>, 
                        usePromotionTimestamp: false, 
                        useWorkspaceInPromotion: false, 
                        verbose: <span>true</span><span>)</span>
                    <span>]</span>
                <span>)</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><br>
<h2 id="_0813-git-submodule"> 0813 - Git Submodule</h2>
<p>credential 파일 관리를 위한 방법중 하나로 사용하고 있는 Git Submodule에 대해 학습하자.</p>
<ul>
<li>git submodule</li>
<li>설정파일 암호화
<ul>
<li>Jasypt 라이브러리</li>
</ul>
</li>
<li>Spring Cloud Config를 통한 설정파일 분리</li>
</ul>
<h3 id="git-submodule이란"> [ Git Submodule이란 ]</h3>
<p>메인 레포지토리에 하위 레포지토리를 두고 관리하기 위한 도구이다. 하나의 프로젝트에서 다른 프로젝트를 함께 사용해야 하는 경우 주로 사용한다. 즉, Git 저장소 안에 다른 Git 저장소를 디렉토리로 분리해 넣는 것이 서브모듈이다. 다른 독립된 Git 저장소를 Clone 해서 내 Git 저장소 안에 포함할 수 있으며 각 저장소의 커밋은 독립적으로 관리한다.</p>
<h3 id="git-submodule-사용방법"> [ Git Submodule 사용방법 ]</h3>
<h4 id="서브-모듈추가"> 서브 모듈추가</h4>
<ul>
<li>git submodule add {URL}</li>
</ul>
<div><pre><code>$ <span>git</span> submodule <span>add</span> https://github.com/chaconinc/DbConnector
Cloning into <span>'DbConnector'</span><span>..</span>.
remote: Counting objects: <span>11</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>10</span>/10<span>)</span>, done.
remote: Total <span>11</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>11</span> <span>(</span>delta <span>0</span><span>)</span>
Unpacking objects: <span>100</span>% <span>(</span><span>11</span>/11<span>)</span>, done.
Checking connectivity<span>..</span>. done.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>기본적으로 서브모듈은 프로젝트 저장소의 이름으로 디렉토리를 만든다. 디렉토리 이름으로 서브모듈을 추가할 수도 있다.</li>
</ul>
<h4 id="서브모듈-확인"> 서브모듈 확인</h4>
<ul>
<li>git status</li>
</ul>
<div><pre><code>$ <span>git</span> status
On branch master
Your branch is up-to-date with <span>'origin/master'</span><span>.</span>

Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   .gitmodules
    new file:   DbConnector
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>.gitmodules</li>
</ul>
<div><pre><code>[submodule &quot;DbConnector&quot;]
    path = DbConnector
    url = https://github.com/chaconinc/DbConnector
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>git diff</li>
</ul>
<div><pre><code>$ <span>git</span> <span>diff</span> --cached DbConnector
<span>diff</span> --git a/DbConnector b/DbConnector
new <span>file</span> mode <span>160000</span>
index 0000000<span>..</span>c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>Git은 DbConnector 디렉토리를 서브모듈로 취급하기 때문에 해당 디렉토리 아래의 파일 수정사항을 직접 추적하지 않는다. 대신 서브모듈 디렉토리를 통째로 특별한 커밋으로 취급한다.</li>
</ul>
<div><pre><code>$ <span>git</span> <span>diff</span> --cached --submodule
<span>diff</span> --git a/.gitmodules b/.gitmodules
new <span>file</span> mode <span>100644</span>
index 0000000<span>..</span>71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+<span>[</span>submodule <span>"DbConnector"</span><span>]</span>
+       path <span>=</span> DbConnector
+       url <span>=</span> https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000<span>..</span>.c3f01dc <span>(</span>new submodule<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>git commit &amp; git push</li>
</ul>
<div><pre><code>$ <span>git</span> commit -am <span>'added DbConnector module'</span>
<span>[</span>master fb9093c<span>]</span> added DbConnector module
 <span>2</span> files changed, <span>4</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> .gitmodules
 create mode <span>160000</span> DbConnector
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>DbConnector 디렉토리 모드는 160000이다. git에게 있어 160000모드는 일반적인 파일이나 디렉토리가 아니라 특별하다는 의미이다.</p>
<div><pre><code>$ <span>git</span> push origin master
</code></pre>
<div><span>1</span><br></div></div><h4 id="서브모듈-포함한-프로젝트-clone"> 서브모듈 포함한 프로젝트 Clone</h4>
<div><pre><code>$ <span>git</span> clone https://github.com/chaconinc/MainProject
Cloning into <span>'MainProject'</span><span>..</span>.
remote: Counting objects: <span>14</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>13</span>/13<span>)</span>, done.
remote: Total <span>14</span> <span>(</span>delta <span>1</span><span>)</span>, reused <span>13</span> <span>(</span>delta <span>0</span><span>)</span>
Unpacking objects: <span>100</span>% <span>(</span><span>14</span>/14<span>)</span>, done.
Checking connectivity<span>..</span>. done.
$ <span>cd</span> MainProject
$ <span>ls</span> -la
total <span>16</span>
drwxr-xr-x   <span>9</span> schacon  staff  <span>306</span> Sep <span>17</span> <span>15</span>:21 <span>.</span>
drwxr-xr-x   <span>7</span> schacon  staff  <span>238</span> Sep <span>17</span> <span>15</span>:21 <span>..</span>
drwxr-xr-x  <span>13</span> schacon  staff  <span>442</span> Sep <span>17</span> <span>15</span>:21 .git
-rw-r--r--   <span>1</span> schacon  staff   <span>92</span> Sep <span>17</span> <span>15</span>:21 .gitmodules
drwxr-xr-x   <span>2</span> schacon  staff   <span>68</span> Sep <span>17</span> <span>15</span>:21 DbConnector
-rw-r--r--   <span>1</span> schacon  staff  <span>756</span> Sep <span>17</span> <span>15</span>:21 Makefile
drwxr-xr-x   <span>3</span> schacon  staff  <span>102</span> Sep <span>17</span> <span>15</span>:21 includes
drwxr-xr-x   <span>4</span> schacon  staff  <span>136</span> Sep <span>17</span> <span>15</span>:21 scripts
drwxr-xr-x   <span>4</span> schacon  staff  <span>136</span> Sep <span>17</span> <span>15</span>:21 src
$ <span>cd</span> DbConnector/
$ <span>ls</span>
$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>프로젝트를 Clone하면 기본적으로 서브모듈 디렉토리는 빈 디렉토리이다.</li>
<li>이후에 <code>git submodule init</code> 명령을 실행하면 서브모듈 정보를 기반으로 로컬 환경설정 파일이 준비된다. 이후 <code>git submodule update</code> 명령으로 서브모듈의 리모트 저장소에서 데이터를 가져오고 서브모듈을 포함한 프로젝트의 현재 스냅샷에서 Checkout 해야 할 커밋 정보를 가져와서 서브모듈 프로젝트에 대 한 Checkout을 한다.</li>
</ul>
<div><pre><code>$ <span>git</span> submodule init
Submodule <span>'DbConnector'</span> <span>(</span>https://github.com/chaconinc/DbConnector<span>)</span> registered <span>for</span> path <span>'DbConnector'</span>
$ <span>git</span> submodule update
Cloning into <span>'DbConnector'</span><span>..</span>.
remote: Counting objects: <span>11</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>10</span>/10<span>)</span>, done.
remote: Total <span>11</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>11</span> <span>(</span>delta <span>0</span><span>)</span>
Unpacking objects: <span>100</span>% <span>(</span><span>11</span>/11<span>)</span>, done.
Checking connectivity<span>..</span>. done.
Submodule path <span>'DbConnector'</span><span>:</span> checked out <span>'c3f01dc8862123d317dd46284b05b6892c7b29bc'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>DbConnector 디렉토리는 마지막으로 커밋을 했던 상태로 복원된다.</li>
<li>방금 과정을 메인 프로젝트를 Clone 할 때 git clone 명령 뒤에 <code>--recurse-submodules</code> 옵션을 붙이면 서브모듈을 자동으로 초기화하고 업데이트한다.</li>
</ul>
<div><pre><code>$ <span>git</span> clone --recurse-submodules https://github.com/chaconinc/MainProject
Cloning into <span>'MainProject'</span><span>..</span>.
remote: Counting objects: <span>14</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>13</span>/13<span>)</span>, done.
remote: Total <span>14</span> <span>(</span>delta <span>1</span><span>)</span>, reused <span>13</span> <span>(</span>delta <span>0</span><span>)</span>
Unpacking objects: <span>100</span>% <span>(</span><span>14</span>/14<span>)</span>, done.
Checking connectivity<span>..</span>. done.
Submodule <span>'DbConnector'</span> <span>(</span>https://github.com/chaconinc/DbConnector<span>)</span> registered <span>for</span> path <span>'DbConnector'</span>
Cloning into <span>'DbConnector'</span><span>..</span>.
remote: Counting objects: <span>11</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>10</span>/10<span>)</span>, done.
remote: Total <span>11</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>11</span> <span>(</span>delta <span>0</span><span>)</span>
Unpacking objects: <span>100</span>% <span>(</span><span>11</span>/11<span>)</span>, done.
Checking connectivity<span>..</span>. done.
Submodule path <span>'DbConnector'</span><span>:</span> checked out <span>'c3f01dc8862123d317dd46284b05b6892c7b29bc'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>메인 프로젝트에 submodule이 이미 있고, 하위 프로젝트의 새로운 커밋을 가져와야 하는 상황에선 update 명령어를 활용한다. 이 명령어로 메인 프로젝트에서 submodule의 커밋을 가져오면, 이전에 봤던 것처럼 새로 커밋해야 하는 파일이 생긴다. 앞서 한것과 동일하게 해당 파일을 add, commit, push해서 로컬과 원격프로젝트에 반영한다.</p>
<div><pre><code>$ <span>git</span> submodule update --remote --merge

// .gitmodules 파일에 정의되어 있는 브랜치<span>(</span>default는 main 또는 master<span>)</span>의 최신 버전으로 업데이트
// $ <span>git</span> submodule update --remote

// 로컬에서 작업 중인 부분과 원격에 작업된 부분이 다른 경우 머지까지 진행
// $ <span>git</span> submodule update --remote --merge
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><br>
<h2 id="_0814-애노테이션-프로세서-annotation-processor"> 0814 - 애노테이션 프로세서(Annotation Processor)</h2>
<h3 id="annotation-processor란"> Annotation Processor란?</h3>
<blockquote>
<p>“Annotation Processing” is a hook into the compile process of the java compiler, to analyse the source code for user defined annotations and handle then (by producing compiler errors, compiler warning, emitting source code, byte code …).</p>
</blockquote>
<p>Annotation Processor는 컴파일 단계에서 Annotation에 정의된 일렬의 프로세스를 동작하게 하는 것을 의미한다. 컴파일 단계에서 실행되기 때문에, 빌드 단계에서 에러를 출력하게 할 수 있고 소스코드 및 바이트 코드를 생성할 수도 있다.<br>
사용하는 예로 자바의 @Override가 있으며, Lombok(롬북) 라이브러리도 있다.<br>
기본적으로 포함되어 있는 어노테이션이 아니면 annotationProcessor를 통해 추가해줘야 한다.</p>
<h3 id="lombok과-annotation-processor"> Lombok과 Annotation Processor</h3>
<p>Lombok이란 @Getter, @Setter, @Builder 등의 Annotation과 Annotation Processor를 제공하여 표준적으로 작성해야 할 코드를 개발자 대신 생성해주는 라이브러리다.<br>
컴파일 시점에 Annotation Processor를 사용하여 abstract syntaxtree를 조작한다.</p>
<h3 id="작동원리"> 작동원리</h3>
<h4 id="moja-interface"> Moja Interface</h4>
<div><pre><code><span>@Magic</span>
<span>public</span> <span>interface</span> <span>Moja</span> <span>{</span>

    <span>String</span> <span>pullOut</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="magic-애노테이션"> Magic 애노테이션</h4>
<ul>
<li>Target을 TYPE으로 지정하면, 인터페이스, 클래스, ENUM에 지정이 가능하다.</li>
<li>Rentention정보를 소스레벨 까지만 유지하고, 컴파일 시점에 애토네이션 프로세서를 사용해 MagicMoja를 생성한다.</li>
</ul>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span> <span>// TYPE 으로 지정하면, 인터페이스 ,클래스, enum에 지정이 가능함.</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>SOURCE<span>)</span> <span>// 소스레벨에서 만 유지하고, 컴파일시 애노테이션 프로세서로 소스코드를 생성할것임</span>
<span>public</span> <span>@interface</span> <span>Magic</span> <span>{</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>App</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span> <span>String</span><span>[</span><span>]</span> args <span>)</span> <span>{</span>
        <span>// MagicMoja 가 애노테이션 프로세서를 사용해서생성할 클래스이다.</span>
        <span>Moja</span> moja <span>=</span> <span>new</span> <span>MagicMoja</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>moja<span>.</span><span>pullOut</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>애노테이션 프로세서를 사용하여, @Magic 애노테이션이 적용된 인터페이스가 존재하면, MagicMoja 라는 클래스를 생성한다.</li>
</ul>
<h4 id="magicmojaprocessor"> MagicMojaProcessor</h4>
<div><pre><code><span>/**
 * Process 인터페이스를 구현해도 되지만, 자바에서 제공하는 AbstractProcessor 추상클래스를 구현해도 된다.
 * Process 에서 구현해야하는 여러 메서드들을 구현해주고 있다.
 */</span>
<span>public</span> <span>class</span> <span>MagicMojaProcessor</span> <span>extends</span> <span>AbstractProcessor</span> <span>{</span>

    <span>/**
     * 이 프로세서가 어떤 애노테이션들을 처리할 것인지 설정하는 메서드 오버라이딩.
     *
     * Element란 ?
     * - 패키지
     * - 클래스
     * - 메서드
     * 소스코드의 구성요소를 엘리먼트라고 부른다
     * 각 엘리먼트들이 프로세스를 할때 참조할 수 있다.
     * @return
     */</span>
    <span>@Override</span>
    <span>public</span> <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> <span>getSupportedAnnotationTypes</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>Set</span><span>.</span><span>of</span><span>(</span><span>Magic</span><span>.</span><span>class</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 몇 버전의 소스코드를 지원하는지 설정.
     * - 최신버전 지원하도록 설정
     * @return
     */</span>
    <span>@Override</span>
    <span>public</span> <span>SourceVersion</span> <span>getSupportedSourceVersion</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>SourceVersion</span><span>.</span><span>latestSupported</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 애노테이션 프로세서는 라운드 라는 개념으로 처리를 한다.
     * - 여러 라운드에 거쳐 처리를 한다.
     * - 각 라운드마다 프로세서에게 특정 애노테이션을 가지고 있는 엘리먼트를 찾으면 처리를 요청한다.
     * - 처리된 결과가 다음 라운드에게 전달될 수 있다.
     * - Filter Chaining 과 어찌보면 비슷한 느낌이다.
     *
     * 만약 여기서 true를 리턴하면, 애노테이션 프로세서가 처리를 한것이다.
     * true를 리턴하면, 다른 프로세서가 이를 처리하지 않는다.
     * @param annotations
     * @param roundEnv
     * @return
     */</span>
    <span>@Override</span>
    <span>public</span> <span>boolean</span> <span>process</span><span>(</span><span>Set</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>TypeElement</span><span>></span></span> annotations<span>,</span> <span>RoundEnvironment</span> roundEnv<span>)</span> <span>{</span>
        <span>/* 적절한 위치에 애노테이션을 사용했는지 체크 */</span>
        <span>/* 애노테이션을 사용한 엘리먼트에 대한 정보를 가져올수 있다.*/</span>
        <span>Set</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Element</span><span>></span></span> elementsAnnotatedWith <span>=</span> roundEnv<span>.</span><span>getElementsAnnotatedWith</span><span>(</span><span>Magic</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Element</span> element <span>:</span> elementsAnnotatedWith<span>)</span> <span>{</span>
            <span>/* 애노테이션이 인터페이스 아닌곳에 사용했을 경우 */</span>
            <span>if</span> <span>(</span>element<span>.</span><span>getKind</span><span>(</span><span>)</span> <span>!=</span> <span>ElementKind</span><span>.</span>INTERFACE<span>)</span> <span>{</span>
                processingEnv<span>.</span><span>getMessager</span><span>(</span><span>)</span><span>.</span><span>printMessage</span><span>(</span><span>Diagnostic<span>.</span>Kind</span><span>.</span>ERROR<span>,</span> <span>"@Magic 애노테이션은 Interface만 지원하는 애노테이션 입니다."</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// 로깅</span>
                processingEnv<span>.</span><span>getMessager</span><span>(</span><span>)</span><span>.</span><span>printMessage</span><span>(</span><span>Diagnostic<span>.</span>Kind</span><span>.</span>NOTE<span>,</span> <span>"Processing "</span> <span>+</span> element<span>.</span><span>getSimpleName</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><ul>
<li>Processor Interface를 사용해도 되지만, 자바에서 기본으로 제공하는 AbstractProcessor 추상 클래스를 사용한다.
<ul>
<li>인터페이스에서 기본으로 구현해야할 것들을 어느정도 구현하고 있다.</li>
</ul>
</li>
</ul>
<blockquote>
<p>주요 메서드</p>
</blockquote>
<ul>
<li>getSupportedAnnotationTypes : 이 프로세서가 처리할 애노테이션들을 지정한다.</li>
<li>getSupportedSourceVersion : 소스코드 버전을 몇까지 지원할 것인지 지정한다.</li>
<li>process : 애노테이션 프로세서가 애노테이션 프로세서가 처리할 애노테이션을 사용하고 있는 엘리먼트 들을 참조할 수 있다.
<ul>
<li>엘리먼트란? 소스코드의 구성요소들을 엘리먼트라고 한다(패키지 엘리먼트, 클래스 엘리먼트, 메서드 엘리먼트)</li>
<li>각 엘리먼트들을 프로세스할때 참조가 가능하다.</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0912 ~ 0918</title>
      <link>ahnjs/TIL/2022/0912/</link>
      <guid isPermaLink="false">ahnjs/TIL/2022/0912/</guid>
      <source url="ahnjs/TIL/rss.xml">0912 ~ 0918</source>
      <pubDate>Tue, 13 Sep 2022 12:44:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0912-0918"> 0912 ~ 0918</h1>
<h2 id="_0913-http의-진화-과정"> 0913 - HTTP의 진화 과정</h2>
<ul>
<li>HTTP/1.1: ASCII over TCP</li>
<li>HTTP/2: Binary Multiplexed over SPDY(TCP)</li>
<li>HTTP/3: Binary over Multiplexed QUIC(UDP)</li>
</ul>
<h3 id="http-1-1"> HTTP/1.1</h3>
<ul>
<li>연결 상태 유지</li>
<li>파이프라이닝</li>
<li>HOLB 문제</li>
<li>헤더 중복 문제</li>
<li>HTTPS/RESTful API의 탄생</li>
</ul>
<h3 id="http-2"> HTTP/2</h3>
<ul>
<li>TCP 기반의 SPDY 프로토콜 -&gt; HTTPS 강제</li>
<li>이진 프로토콜(바이너리 프레이밍)</li>
<li>스트림, 메시지, 프레임으로 구분</li>
<li>멀티플렉싱(응답 다중화) -&gt; HOLB 문제 해결</li>
<li>HPACK -&gt; 헤더 중복 문제 해결</li>
<li>서버 푸시</li>
<li>스트림 별 우선 순위 설정</li>
<li>TCP 자체의 HOLB 문제</li>
</ul>
<h3 id="http-3"> HTTP/3</h3>
<ul>
<li>UDP 기반의 QUIC 프로토콜</li>
<li>독립 스트림 -&gt; TCP HOLB 문제 해결</li>
<li>QPACK -&gt; 헤더 압축 문제 개선</li>
<li>캐싱을 이용한 ORTT</li>
<li>서버 푸시</li>
<li>스트림 별 우선 순위</li>
<li>Connection ID 기반</li>
<li>TLS -&gt; HTTPS 강제</li>
</ul>
<br>
<h2 id="_0914-비트-연산"> 0914 - 비트 연산</h2>
<h3 id="비트-단위-연산-bitwise-operation"> 비트 단위 연산(bitwise operation)</h3>
<p>컴퓨터는 모든 데이터를 비트(bit) 단위로 표현하고 처리한다.<br>
과거에는 개발자가 직접 비트 단위 연산을 사용하여, 복잡한 연산을 훨씬 더 빠르고 효율적으로 수행해야만 했다.<br>
하지만 하드웨어의 발달로 이제는 비트 단위까지 생각하지 않더라도, 충분히 빠른 프로그램을 작성할 수 있게 됐다.</p>
<p>그러나 아직도 하드웨어 관련 프로그래밍이나 시스템 프로그래밍등 제한된 자원을 가진 시스템을 위한 프로그램에서는 비트 단위의 연산이 자주 사용되고 있다.<br>
이러한 비트 단위 연산을 통해 사용되는 메모리 공간을 줄이거나, 성능의 향상을 기대할 수 있다.</p>
<h3 id="비트-연산자"> 비트 연산자</h3>
<p>비트 연산자는 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자이다.<br>
또한, 왼쪽이나 오른쪽으로 전체 비트를 이동시킬 때에도 사용한다.</p>
<ul>
<li>~ : 비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산)</li>
<li>&amp; : 대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산)</li>
<li>| : 대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)</li>
<li>^ : 대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산)</li>
<li>&lt;&lt; : 지정한 수만큼 비트들을 전부 왼쪽으로 이동시킴. (left shift 연산)</li>
<li>
<blockquote>
<blockquote>
<p>: 지정한 수만큼 비트들을 전부 오른쪽으로 이동시킴. (right shift 연산)</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="비트연산-관련-용어"> 비트연산 관련 용어</h3>
<h4 id="비트-필드-bit-field"> 비트 필드(bit field)</h4>
<p>인접한 비트들의 연속적인 공간<br>
ex)</p>
<ul>
<li>char : 8bit(1byte) 비트 필드를 갖는 자료형</li>
<li>int, float : 32bit(4byte) 비트 필드를 갖는 자료형</li>
</ul>
<h4 id="비트-플래그-bit-flag"> 비트 플래그(bit flag)</h4>
<p>비트 필드에서 비트들의 상태값을 확인 하기 위한 특정 값<br>
(깃발을 통해 어떤 상태를 확인하듯이, bit를 통해 어떤 상태를 확인 한다는 의미)<br>
비트 플래그는 특정 상태값을 확인하거나, 비트를 조작하는데 사용 될 수 있다.<br>
플래그(flag)라고도 한다. 굳이 구분하자면 어감상 다음과 같은 차이가 있을 수 있다.</p>
<ul>
<li>bit flag : 특정 단일 비트 값이 1로 세팅 되어 있는 경우</li>
<li>flag : 1개 이상의 bit값이 1로 되어 있는 경우, bit flag를 결합해서 하나의 새로운 flag를 만들 수 있따.</li>
</ul>
<h4 id="비트마스트-bit-masking"> 비트마스트(bit masking)</h4>
<p>비트 연산에 사용되는 플래그<br>
즉, 플래그인데 특정 연산에 사용될 때 마스크라고도 한다.<br>
마스크를 사용한 비트 연사을 '비트 마스킹'이라고 한다.<br>
활용 예
이미지 마스킹, IP 주소의 mask 값, 해시 테이블</p>
<br>
<h2 id="_0918-reflectiontestutils를-통한-private-메소드-테스트"> 0918 - ReflectionTestUtils를 통한 private 메소드 테스트</h2>
<p>private 메소드를 테스트 하는 방법은 크게 두가지가 있다.</p>
<ol>
<li>스프링 테스트 유틸</li>
<li>자바 lang에서 제공하는 기능</li>
</ol>
<h3 id="reflectiontestutils"> ReflectionTestUtils</h3>
<blockquote>
<p>ReflectionTestUtils is a collection of reflection-based utility methods. You can use these methods in testing scenarios where you need to change the value of a constant, set a non-public field, invoke a non-public setter method, or invoke a non-public configuration or lifecycle callback method when testing application code for use cases such as the following:</p>
</blockquote>
<div><pre><code><span>@Component</span>
<span>@Getter</span>
<span>public</span> <span>class</span> <span>ReflectionTestUtilsComponent</span> <span>{</span>

    <span>private</span> <span>int</span> privateValue<span>;</span>

    <span>private</span> <span>int</span> <span>privateMethod</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
        privateValue <span>+=</span> a<span>;</span>
        privateValue <span>+=</span> b<span>;</span>
        <span>return</span> privateValue<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>private 변수 주입</li>
</ul>
<div><pre><code><span>static</span> <span>void</span>	<span>setField</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span> <span>String</span> name<span>,</span> <span>Object</span> value<span>)</span>

<span>static</span> <span>void</span>	<span>setField</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span> <span>String</span> name<span>,</span> <span>Object</span> value<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span>

<span>static</span> <span>void</span>	<span>setField</span><span>(</span><span>Object</span> targetObject<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span> <span>String</span> name<span>,</span> <span>Object</span> value<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span>

<span>static</span> <span>void</span>	<span>setField</span><span>(</span><span>Object</span> targetObject<span>,</span> <span>String</span> name<span>,</span> <span>Object</span> value<span>)</span>

<span>static</span> <span>void</span>	<span>setField</span><span>(</span><span>Object</span> targetObject<span>,</span> <span>String</span> name<span>,</span> <span>Object</span> value<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> type<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>testPrivateValue</span><span>(</span><span>)</span> <span>{</span>
    <span>ReflectionTestUtils</span><span>.</span><span>setField</span><span>(</span>reflectionTestUtilsComponent<span>,</span> <span>"privateValue"</span><span>,</span> <span>100</span><span>)</span><span>;</span>
    <span>// ReflectionTestUtils.setField(대상 객체, "변수명", 원하는 값);</span>

    <span>Assertions</span><span>.</span><span>assertEquals</span><span>(</span><span>100</span><span>,</span> reflectionTestUtilsComponent<span>.</span><span>getPrivateValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>private 메소드 테스트</li>
</ul>
<div><pre><code><span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span>	<span>invokeMethod</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span> <span>String</span> name<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span>

<span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span>	<span>invokeMethod</span><span>(</span><span>Object</span> targetObject<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> targetClass<span>,</span> <span>String</span> name<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span>

<span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span>	<span>invokeMethod</span><span>(</span><span>Object</span> target<span>,</span> <span>String</span> name<span>,</span> <span>Object</span><span>.</span><span>.</span><span>.</span> args<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>testPrivateMethod</span><span>(</span><span>)</span> <span>{</span>
    <span>ReflectionTestUtils</span><span>.</span><span>setField</span><span>(</span>reflectionTestUtilsComponent<span>,</span> <span>"privateValue"</span><span>,</span> <span>100</span><span>)</span><span>;</span>
    <span>// ReflectionTestUtils.setField(대상 객체, "변수명", 원하는 값);</span>

    <span>Assertions</span><span>.</span><span>assertEquals</span><span>(</span><span>103</span><span>,</span> <span>(</span><span>Integer</span><span>)</span> <span>ReflectionTestUtils</span><span>.</span><span>invokeMethod</span><span>(</span>reflectionTestUtilsComponent<span>,</span> <span>"privateMethod"</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span>
    <span>// ReflectionTestUtils.invokeMethod(대상 객체, "메소드(함수)명", 인자);</span>

    <span>Assertions</span><span>.</span><span>assertEquals</span><span>(</span><span>103</span><span>,</span> reflectionTestUtilsComponent<span>.</span><span>getPrivateValue</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0906 - 0919</title>
      <link>ahnjs/TIL/2021/0906/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0906/</guid>
      <source url="ahnjs/TIL/rss.xml">0906 - 0919</source>
      <pubDate>Sun, 12 Sep 2021 17:20:26 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0906-0919"> 0906 - 0919</h1>
<h2 id="_0907-static-stack-heap-java-메모리-영역"> 0907 - Static, Stack, Heap / Java 메모리 영역</h2>
<blockquote>
<p>프로그램을 구동하기 위해서는 운영체제가 메모리에 데이터 및 명령을 저장할 공간을 할당해야함.<br>
메모리는 CPU가 처리할 데이터가 임시로 저장되는 공간. 동작은 하드디스크에  저장된 데이터가 메모리에 올라가서 실행되며, 메모리를 주 기억 장치라고 부름<br>
=&gt; 메모리는 사용 공간이 한정되어 있기 때문에 효율적으로 관리되어야함.</p>
</blockquote>
<h3 id="static-area-스태틱-메모리-영역"> Static Area (스태틱 메모리 영역)</h3>
<ul>
<li>static(정적)은 고정된 이라는 의미를 가지고 있다. static 이라는 키워드를 사용하여 정적 필드와 정적 메서드를 만들 수 있는데, 두 가지를 합쳐서 정적 멤버라고 한다.(= 클래스 멤버)</li>
<li>Static Area(스태틱 메모리 영역)에서는 필드 부분에 선언된 변수(전역 벽수)와 정적 멤버 변수(static이 붙은 자료형)의 데이터를 저장한다.</li>
<li>Static Area(스태틱 메모리 영역)에 데이터는 프로그램의 시작부터 종료가 될 때까지 메모리에 남아있게 된다. 즉, 프로그램이 종료될 때가지 어디서든지 사용이 가능하지만, 주의할 점은 전역 변수를 무분별하게 많이 사용하게 되면 메모리가 부족한 문제가 발생할 수 있다.</li>
</ul>
<p>*** <code>객체에 소소된 멤버가 아닌 클래스에 고정된 멤버</code></p>
<h3 id="stack-area-스택-메모리-영역"> Stack Area (스택 메모리 영역)</h3>
<ul>
<li>메소드 내에서 정의하는 기본 자료형에 해당되는 지역변수의 데이터 값이 저장되는 공간이 Stack Area이다. 해당 메서드가 호출될 때 메모리에 할당되고, 종료되면 메모리에서 사라진다.</li>
<li>참조형 타입 변수는 참조값만 저장된다. 이 참조값은 Heap 영역에 존재하는 인스턴스(객체)를 가르키는 역할을 한다.(인스턴스의 주소 값)</li>
</ul>
<p>*** <code>메서드 내에서 정의하는 기본 자료형</code></p>
<ul>
<li>프로세스는 완벽히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않지만, 스레드는 프로세스 안에서 해당 스렏드를 위한 Stack영역을 생성하기 때문에 하나의 스레드에서 다른 스레드로의 접근은 불가능하지만 static, heap 영역에 저장된 데이터들은 공유해서 사용할 수 있다.</li>
</ul>
<h3 id="heap-area-힙-메모리-영역"> Heap Area (힙 메모리 영역)</h3>
<ul>
<li>참조형(Reference Type)의 데이터 타입을 갖는 객체, 배열 등은 Heap 영역에 데이터가 저장된다.</li>
<li>이때 변수(객체, 객체 변수, 참조 변수)는 Stack 영역의 공간에서 실제 데이터가 저장된 Heap 영역의 참조값(Reference key, 해시 코드 = 메모리에 저장된 주소를 연결해주는 값)을 new 연산자를 통해서 리턴 받는다.
<ul>
<li>실제 데이터를 가지고 있는 Heap 영역의 주소 값을 Stack 영역의 객체가 갖고 있는 것</li>
</ul>
</li>
<li>이렇게 리턴 받은 참조값을 가지고 있는 객체를 통해서만 해당 인스턴스를 컨트롤 할 수 있다.</li>
<li>인스턴스의 실제 데이터는 Heap 영역에 올라간다. 저장된 메모리 위치가 다르기 때문에 static 메서드에서 외부 인스턴스 멤버에 접근할 수 없다.</li>
</ul>
<p>*** <code>Heap은 참조형의 데이터 객체에 실제 데이터들이 담기는 공간이고, 실제 데이터를 가지고 있는 Heap 영역의 참조값을 Stack 영역의 객체가 가지고 있는 것</code></p>
<p>*** <code>new를 통해 인스턴스 객체를 생성했을 때, heap 영역에는 생성된 객체가 올라가고, Stack 영역에는 해당 객체에 대한 주소 값(Reference)이 저장</code></p>
<p>*** <code>어떤 참조 변수도 Heap 영역에 있는 인스턴스를 참조하지 않게 된다면, GC에 의해 메모리에서 사라진다.</code></p>
<br>
<h2 id="_0909-jacoco"> 0909 - jacoco</h2>
<h3 id="jacoco"> JaCoCo</h3>
<blockquote>
<p>Java code coverage의 약자로 jUnit 테스트의 결과를 바탕으로 커버리지의 툴<br>
코드정적분석도구인 sonarqube와 연계하여 사용하는 경우가 많다.</p>
</blockquote>
<h4 id="jacoco-특징"> JaCoCo 특징</h4>
<ul>
<li>Line, Branch Coverage를 제공한다.</li>
<li>코드 커버리지 결과를 보기 좋도록 파일  형태로 저장할 수 있다.
<ul>
<li>html, xml, csv 등으로 Report를 생성할 수 있다.</li>
</ul>
</li>
<li>설정한 커버리지 기준을 만족하는지 확인할 수 있다.</li>
<li>결과적으로 코드 커버리지를 쉽게 확인하고 관리할 수 있도록 도와준다.</li>
</ul>
<h3 id="jacoco-maven-예제"> JaCoCo Maven 예제</h3>
<h4 id="jacoco-플러그인-추가"> jacoco 플러그인 추가</h4>
<div><pre><code><span><span><span>&lt;</span>plugin</span><span>></span></span> 
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.jacoco<span><span><span>&lt;/</span>groupId</span><span>></span></span> 
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jacoco-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span> 
    <span><span><span>&lt;</span>version</span><span>></span></span>0.8.2<span><span><span>&lt;/</span>version</span><span>></span></span> 
    <span><span><span>&lt;</span>executions</span><span>></span></span> 
        <span><span><span>&lt;</span>execution</span><span>></span></span> 
            <span><span><span>&lt;</span>goals</span><span>></span></span> 
                <span><span><span>&lt;</span>goal</span><span>></span></span>prepare-agent<span><span><span>&lt;/</span>goal</span><span>></span></span> 
            <span><span><span>&lt;/</span>goals</span><span>></span></span> 
        <span><span><span>&lt;/</span>execution</span><span>></span></span> 
        <span><span><span>&lt;</span>execution</span><span>></span></span> 
            <span><span><span>&lt;</span>id</span><span>></span></span>report<span><span><span>&lt;/</span>id</span><span>></span></span> 
            <span><span><span>&lt;</span>phase</span><span>></span></span>test<span><span><span>&lt;/</span>phase</span><span>></span></span> 
            <span><span><span>&lt;</span>goals</span><span>></span></span> 
                <span><span><span>&lt;</span>goal</span><span>></span></span>report<span><span><span>&lt;/</span>goal</span><span>></span></span> 
            <span><span><span>&lt;/</span>goals</span><span>></span></span> 
        <span><span><span>&lt;/</span>execution</span><span>></span></span> 
    <span><span><span>&lt;/</span>executions</span><span>></span></span> 
<span><span><span>&lt;/</span>plugin</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h4 id="jacococontroller-java"> JacocoController.java</h4>
<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>jacocotest</span><span>;</span>

<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>GetMapping</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RequestParam</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>bind<span>.</span>annotation<span>.</span></span><span>RestController</span><span>;</span>

<span>@RestController</span>
<span>public</span> <span>class</span> <span>JacocoController</span> <span>{</span>
    <span>@GetMapping</span><span>(</span><span>"/test"</span><span>)</span>
    <span>public</span> <span>String</span> <span>test</span><span>(</span><span>@RequestParam</span> <span>int</span> n<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>>=</span> <span>0</span><span>)</span> <span>{</span>
            <span>return</span> <span>"hello"</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>return</span> <span>"world"</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h4 id="jacococontrollertest-java"> JacocoControllerTest.java</h4>
<div><pre><code><span>package</span> <span>com<span>.</span>example<span>.</span>jacocotest</span><span>;</span>

<span>import</span> <span>static</span> <span>org<span>.</span>springframework<span>.</span>test<span>.</span>web<span>.</span>servlet<span>.</span>request<span>.</span></span><span>MockMvcRequestBuilders</span><span>.</span>get<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>springframework<span>.</span>test<span>.</span>web<span>.</span>servlet<span>.</span>result<span>.</span></span><span>MockMvcResultMatchers</span><span>.</span>content<span>;</span>
<span>import</span> <span>static</span> <span>org<span>.</span>springframework<span>.</span>test<span>.</span>web<span>.</span>servlet<span>.</span>result<span>.</span></span><span>MockMvcResultMatchers</span><span>.</span>status<span>;</span>

<span>import</span> <span>org<span>.</span>junit<span>.</span>jupiter<span>.</span>api<span>.</span></span><span>Test</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>annotation<span>.</span></span><span>Autowired</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>boot<span>.</span>test<span>.</span>autoconfigure<span>.</span>web<span>.</span>servlet<span>.</span></span><span>AutoConfigureMockMvc</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>boot<span>.</span>test<span>.</span>context<span>.</span></span><span>SpringBootTest</span><span>;</span>
<span>import</span> <span>org<span>.</span>springframework<span>.</span>test<span>.</span>web<span>.</span>servlet<span>.</span></span><span>MockMvc</span><span>;</span>

<span>@SpringBootTest</span>
<span>@AutoConfigureMockMvc</span>
<span>public</span> <span>class</span> <span>JacocoControllerTest</span> <span>{</span>
    <span>@Autowired</span>
    <span>private</span> <span>MockMvc</span> mvc<span>;</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        mvc<span>.</span><span>perform</span><span>(</span><span>get</span><span>(</span><span>"/test"</span><span>)</span><span>.</span><span>param</span><span>(</span><span>"n"</span><span>,</span> <span>"3"</span><span>)</span><span>)</span><span>.</span><span>andExpect</span><span>(</span><span>content</span><span>(</span><span>)</span><span>.</span><span>string</span><span>(</span><span>"hello"</span><span>)</span><span>)</span><span>.</span><span>andExpect</span><span>(</span><span>status</span><span>(</span><span>)</span><span>.</span><span>isOk</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h4 id="mvn-package"> mvn package</h4>
<ul>
<li>mvn package 명령어를 입력한다.</li>
</ul>
<blockquote>
<p>maven의 라이프사이클의 phase는<br>
<code>validate -&gt; compile -&gt; test -&gt; package -&gt; install -&gt; deploy</code><br>
test 이후 package를 할때 Jacoco가 활약하므로 package까지만 입력시에도 Jacoco를 사용 가능</p>
</blockquote>
<h3 id="특정-케이스-제외"> 특정 케이스 제외</h3>
<ul>
<li>plugin에 configuration으로 제외</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>plugin</span><span>></span></span> 
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.jacoco<span><span><span>&lt;/</span>groupId</span><span>></span></span> 
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>jacoco-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span> 
    <span><span><span>&lt;</span>version</span><span>></span></span>0.8.2<span><span><span>&lt;/</span>version</span><span>></span></span> 

    <span><span><span>&lt;</span>configuration</span><span>></span></span>
        <span><span><span>&lt;</span>excludes</span><span>></span></span> 
            <span><span><span>&lt;</span>exclude</span><span>></span></span>**/*Application.class<span><span><span>&lt;/</span>exclude</span><span>></span></span> 
        <span><span><span>&lt;/</span>excludes</span><span>></span></span>
    <span><span><span>&lt;/</span>configuration</span><span>></span></span>

    <span><span><span>&lt;</span>executions</span><span>></span></span> 
       ...
    <span><span><span>&lt;/</span>executions</span><span>></span></span> 
<span><span><span>&lt;/</span>plugin</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><br>
<h2 id="_0910-ssr-csr"> 0910 - SSR, CSR</h2>
<h3 id="ssr-server-side-rendering"> SSR(Server Side Rendering)</h3>
<blockquote>
<p>페이지 요청을 서버에서 렌더링을 마치고, data가 결합된 html파일을 보내는 방식.</p>
</blockquote>
<ul>
<li>장점
<ul>
<li>CSR에 비해 다운 받는 페이지 리소스가 적어 초기 로딩속도가 비교적 빠르다.</li>
<li>HTML에 대한 정보가 처음부터 포함되어 있어 모든 검색엔진에 대한 SEO(검색 엔진 최적화)가 가능하다.</li>
</ul>
</li>
<li>단점
<ul>
<li>매번 페이지를 요청할 때마다 화면 깜빡임이 발생한다.</li>
<li>페이지 이동시 서버에 매번 요청을 하기 때문에, 서버 부하가 커진다.</li>
</ul>
</li>
</ul>
<h3 id="csr-client-side-rendering"> CSR(Client Side Rendering)</h3>
<blockquote>
<p>최초 로딩 시 브라우저가 서버에 html을 비롯한 css, javascript 등 각종 리소스들을 받아오는 방식이 클라이언트 사이드 렌더링 방식이다.</p>
</blockquote>
<ul>
<li>장점
<ul>
<li>초기 요청을 제외하고는 SSR에 비해 빠른 페이지 전환 속도와 깜빡임 없는 UX를 제공한다.</li>
<li>서버에 요청하는 횟수가 적기 때문에 서버 부담이 SSR에 비해 적다.</li>
</ul>
</li>
<li>단점
<ul>
<li>최초 로딩 시 모든 리소스들을 받아와야 하기 떄문에 초기 로딩 속도가 느리다.</li>
<li>처음에는 HTML이 비어 있어 크롤러가 데이터를 수집할 수 없기 때문에 SEO 문제가 발생한다.</li>
<li>쿠키나 localStorage에서 사용자에 대한 정보를 저장해야 하기 때문에 XSS 공격에 취약하다.</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0911-docker-redis-설치"> 0911 - Docker Redis 설치</h2>
<h3 id="도커로-레디스-설치"> 도커로 레디스 설치</h3>
<ul>
<li>레디스 이미지 가져오기</li>
</ul>
<div><pre><code>$ docker pull redis
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>이미지 확인</li>
</ul>
<div><pre><code>$ docker images
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>레디스 서버 실행</li>
</ul>
<div><pre><code>$ docker run --name 컨테이너이름 -d -p <span>6379</span>:6379 rdis
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>Docker의 redis-cli로 접속하기</li>
</ul>
<div><pre><code>$ docker run -it --link 컨테이너이름:redis --rm redis redis-cli -h redis -p <span>6379</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>Shell로 Docker 리눅스에 접속하기</li>
</ul>
<div><pre><code>$ docker <span>ps</span>
$ docker <span>exec</span> -it 컨테이너이름 /bin/bash
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>도커용 redis.conf</li>
</ul>
<div><pre><code>daemonize no
<span># bind 127.0.0.1</span>
protected-mode no
port <span>6001</span>
logfile <span>"redis.log"</span>
<span>dir</span> /data
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>redis.conf 파일 지정해서 실행: volume 지정</li>
</ul>
<div><pre><code>$ docker run -v /root/docker/redis-5.0.3/6001:/data --name myredis -d -p <span>6001</span>:6001 redis redis-server /data/redis.conf   
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_0918-docker-도커-이론"> 0918 - docker(도커) 이론</h2>
<h3 id="도커란"> 도커란?</h3>
<blockquote>
<p>도커란, 컨테이너 기반의 오픈소스 가상화 플랫폼이다.</p>
</blockquote>
<ul>
<li>애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼</li>
<li>도커는 소프트웨어를 컨테이너라는 표준화 된 유닛으로 패키징하며, 라이브러리, 시스템 도구, 코드, 런타임 등 소프트웨어를 실행하는 데 필요한 모든 것이 포함</li>
<li>환경에 구애 받지 않는다.</li>
</ul>
<h4 id="컨테이너"> 컨테이너</h4>
<ul>
<li>컨테이너 기술은 호스트OS를 공유하며, 여러개의 컨테이너들이 서로 영향을 미치지 않고 독립적으로 실행되어 가볍다.</li>
<li>VM과의 가장 큰 차이점은 프로세스를 격리 하는 것이다. VM은 가상머신들 사이에 오버헤드가 발생할떄 상당한 시간이 걸린다. 반면, 컨테이너 기술은 독립적으로, 호스트OS의 자원을 공유하며 각각 필요한 자원들을 할당받아 실행되기 때문에 오버헤드가 적다. **오버헤드 : 처리를 하기 위해 들어가는 간접적인 처리 시간 및 메모리</li>
</ul>
<h4 id="컨테이너-생성"> 컨테이너 생성</h4>
<p>컨테이너의 생성은 기본적으로 <code>도커파일</code>이라는 것을 이용한다.<br>
가상화 할 프로그램들을 '도커파일'이란 DSL(Domain Specific Laguage)형태로 작성한다.</p>
<ul>
<li>컨테이너의 생성과정</li>
</ul>
<div><pre><code>도커파일 -&gt; (build) = 도커이미지 생성
도커이미지 -&gt; (run) = 도커컨테이너 생성
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0809 - 0815</title>
      <link>ahnjs/TIL/2021/0809/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0809/</guid>
      <source url="ahnjs/TIL/rss.xml">0809 - 0815</source>
      <pubDate>Thu, 02 Sep 2021 13:00:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0809-0815"> 0809 - 0815</h1>
<h2 id="_0809-spring-web-socket"> 0809 - Spring Web Socket</h2>
<h3 id="websocket"> WebSocket</h3>
<ul>
<li>
<p>레퍼런스에 따르면, websocket은 웹 브라우저(클라이언트)와 서버간의 full-duplex(양방향), bi-directional(전이중적), persistent connection(지속적인 연결)의 특징을 갖는 프로토콜이라고 규정한다.</p>
</li>
<li>
<p>Websocket과 TCP의 차이</p>
<ol>
<li>웹소켓은 연결 요청에 대해 http를 통해 switching 및 Handshaking이 이루어진다.</li>
<li>TCP는 Binary 데이터만 주고 받을 수 있지만, Websocket은 Binary 데이터 뿐만 아니라 Text 데이터를 주고 받을 수 있다.</li>
</ol>
</li>
</ul>
<p>=&gt; Websocket은 HTTP와 TCP의 특성을 섞어 놓은 프로토콜이며, 웹 브라우저 환경에서 연결지향 통신을 하기 위한 기술이다.</p>
<h3 id="spring-websocket"> Spring WebSocket</h3>
<p>스프링에서는 2가지 방식으로 웹소켓을 구현 할 수 있다.</p>
<ul>
<li>WebSocket 데이터를 직접 처리</li>
<li>Stomp 프로토콜을 사용하여 메세징 처리</li>
</ul>
<h4 id="_1-websocket-data-직접-처리"> 1) Websocket Data 직접 처리</h4>
<blockquote>
<p>Config를 통해 Websocket 옵션 설정 가능. 웹소켓 핸들러를 상속받은 클래스는 low level 수준에서 원시적으로 데이터를 처리할 수 있으며, 다음과 같은 4가지 이벤트를 처리 할 수 있다.</p>
</blockquote>
<div><pre><code><span>@Configuration</span>
<span>@EnableWebSocket</span>
<span>public</span> <span>class</span> <span>WebSocketConfig</span> <span>implements</span> <span>WebSocketConfigurer</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>registerWebSocketHandlers</span><span>(</span><span>WebSocketHandlerRegistry</span> registry<span>)</span> <span>{</span>
<span>//        WebSocket을 사용할 수없는 경우 대체 전송을 사용할 수 있도록 SockJS 폴백 옵션을 활성화합니다.</span>
<span>//        SockJS 클라이언트는 "/ws"에 연결하여 사용 가능한 최상의 전송 (websocket, xhr-streaming, xhr-polling 등)을 시도.</span>
        registry<span>.</span><span>addHandler</span><span>(</span><span>new</span> <span>WsTranportHandler</span><span>(</span><span>)</span><span>,</span> <span>"/ws"</span><span>)</span><span>.</span><span>setAllowedOrigins</span><span>(</span><span>"*"</span><span>)</span><span>.</span><span>withSockJS</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>@Component</span>
<span>public</span> <span>class</span> <span>WsTranportHandler</span> <span>extends</span> <span>TextWebSocketHandler</span> <span>{</span>
 
    <span>// connection이 맺어진 후 실행된다</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>afterConnectionEstablished</span><span>(</span><span>WebSocketSession</span> session<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"session connected +="</span> <span>+</span> session<span>)</span><span>;</span>
    <span>}</span>
    <span>// 메세지 수신</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>handleMessage</span><span>(</span><span>WebSocketSession</span> session<span>,</span> <span>WebSocketMessage</span><span><span>&lt;</span><span>?</span><span>></span></span> message<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"handle message +="</span> <span>+</span> session<span>)</span> <span>+</span> <span>", message="</span> <span>+</span> message<span>)</span><span>;</span>
 
        <span>//echo Message</span>
        session<span>.</span><span>sendMessage</span><span>(</span>message<span>)</span><span>;</span>
 
    <span>}</span>
    <span>// transport 중 error</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>handleTransportError</span><span>(</span><span>WebSocketSession</span> session<span>,</span> <span>Throwable</span> exception<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"transport error ="</span> <span>+</span> session <span>+</span><span>", exception ="</span> <span>+</span> exception<span>)</span><span>;</span>
    <span>}</span>
    <span>// connection close</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>afterConnectionClosed</span><span>(</span><span>WebSocketSession</span> session<span>,</span> <span>CloseStatus</span> closeStatus<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
 
        <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span><span>"session close -="</span> <span>+</span> session<span>)</span><span>;</span>
 
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>=&gt; 세션레벨에서 데이터를 Handle</p>
<h4 id="_2-stomp-프로토콜을-사용하여-메세징-처리"> 2) Stomp 프로토콜을 사용하여 메세징 처리</h4>
<blockquote>
<p>STOMP 프로토콜은 simple text oriented messaging protocol의 약자이며, 텍스트 기반의 프로토콜이다.</p>
</blockquote>
<p>Spring 내부의 In Memory Broker를 통해 메세지를 처리한다.</p>
<ol>
<li>Receive Client
<ul>
<li>메세지를 받기 위해 특정 토픽이 사전에 서버에 subscribe 되어야 한다.</li>
</ul>
</li>
<li>Send Client
<ul>
<li>서버와 연결된 클라이언트는 특정 path로 ex) /app/message 전달한다.</li>
</ul>
</li>
<li>Broker
<ul>
<li>메세지 브로커는 Kafka, RabbitMQ, ActiveMQ 등의 오픈소스들 처럼 MQ이며, pub/sub 모델을 따른다. 토픽에 따라 메세지를 전달해야 하는 사용자를 구분하다.</li>
<li>연결된 클라이언트의 세션을 관리한다.</li>
<li>특정 토픽과 메세지를 Mpaaping 하여, 토픽을 구독하는 세션에 존재하는 클라이언트에게 메세지를 전달한다.</li>
</ul>
</li>
</ol>
<div><pre><code><span>@Configuration</span>
<span>@EnableWebSocketMessageBroker</span>
<span>public</span> <span>class</span> <span>WebSocketStompConfig</span> <span>implements</span> <span>WebSocketMessageBrokerConfigurer</span> <span>{</span>
 
    <span>//messageBroker config</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>configureMessageBroker</span><span>(</span><span>MessageBrokerRegistry</span> config<span>)</span> <span>{</span>
 
        <span>//in-memory message-broker, topic에 대한 prefix 설정</span>
         config<span>.</span><span>enableSimpleBroker</span><span>(</span><span>"/topic"</span><span>)</span><span>;</span>
 
 
        <span>//메세지를 수신하는 handler의 메세지 prefix 설정 </span>
        config<span>.</span><span>setApplicationDestinationPrefixes</span><span>(</span><span>"/api"</span><span>)</span><span>;</span>
 
    <span>}</span><span>;</span>
 
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>registerStompEndpoints</span><span>(</span><span>StompEndpointRegistry</span> registry<span>)</span> <span>{</span>
       registry<span>.</span><span>addEndpoint</span><span>(</span><span>"/ws"</span><span>)</span><span>.</span><span>setAllowedOrigins</span><span>(</span><span>"*"</span><span>)</span><span>.</span><span>withSockJS</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span>@RestController</span>
<span>public</span> <span>class</span> <span>MessageHandleController</span> <span>{</span>
 
    <span>@MessageMapping</span><span>(</span><span>"/echo"</span><span>)</span>
    <span>@SendTo</span><span>(</span><span>"/topic/messages"</span><span>)</span>
    <span>public</span> <span>EchoMessage</span> <span>echo</span><span>(</span><span>String</span> message<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>System</span><span>.</span>err<span>.</span><span>println</span><span>(</span>message<span>)</span><span>;</span>
        <span>return</span>  <span>new</span> <span>EchoMessage</span><span>(</span>message<span>,</span><span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>
<p>@MessageMapping으로 MessageHandle을 한다. 설정의 setApplicationDestinationPrefix를 /api로 설정했기 때문에, 최종적으로 메세지를 보내려고 할 경우 /api/echo 로 메세지 보낸다면, MessageHandler는 메세지를 수신한다.</p>
</li>
<li>
<p>@MeesageMapping을 통해 메세지를 수신했다면, @SendTo를 통해 특정 토픽을 구독하는 클라이언트에게 메세지를 보낼 수 있다.</p>
</li>
</ul>
<h2 id="_0812-디자인패턴-생성-구조-행위-패턴"> 0812 - 디자인패턴 : 생성, 구조, 행위 패턴</h2>
<h3 id="생성-패턴"> 생성 패턴</h3>
<blockquote>
<p>객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더해주는 패턴</p>
</blockquote>
<h3 id="구조-패턴"> 구조 패턴</h3>
<blockquote>
<p>클래스/객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴.</p>
</blockquote>
<h3 id="행위-패턴"> 행위 패턴</h3>
<blockquote>
<p>객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴. 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화 하는 것에 중점을 두는 방식</p>
</blockquote>
<img src="https://gmlwjd9405.github.io/images/design-pattern/types-of-designpattern.png" width="100%">
<br>
<h2 id="_0813-쓰로틀링과-디바운싱"> 0813 - 쓰로틀링과 디바운싱</h2>
<ul>
<li>디바운싱은 주로 ajax 검색에 주로 사용. 쓰로틀링은 스크롤을 올리거나 내릴 때 보통 사용.</li>
<li>underscore나 lodash에서 지원 하는 기능(라이브러리 사용시 따로 구현 X)
<ul>
<li>underscore : <code>_.debounce</code>, <code>_.throttle</code></li>
</ul>
</li>
</ul>
<h3 id="쓰로틀링"> 쓰로틀링</h3>
<blockquote>
<p>마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것</p>
</blockquote>
<ul>
<li>구현 예제</li>
</ul>
<div><pre><code><span>var</span> timer<span>;</span>
document<span>.</span><span>querySelector</span><span>(</span><span>'#input'</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>timer<span>)</span> <span>{</span>
    timer <span>=</span> <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
      timer <span>=</span> <span>null</span><span>;</span>
      console<span>.</span><span>log</span><span>(</span><span>'여기에 ajax 요청'</span><span>,</span> e<span>.</span>target<span>.</span>value<span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>200</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="디바운싱"> 디바운싱</h3>
<blockquote>
<p>연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것</p>
</blockquote>
<div><pre><code><span>// html</span>
<span>&lt;</span>input id<span>=</span><span>"input"</span> <span>/</span><span>></span>

<span>// script</span>
document<span>.</span><span>querySelector</span><span>(</span><span>'#input'</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'여기에 ajax 요청'</span><span>,</span> e<span>.</span>target<span>.</span>value<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>요청 낭비 =&gt; 이벤트 발생 마다 타이머를 성정</li>
</ul>
<div><pre><code><span>var</span> timer<span>;</span>
document<span>.</span><span>querySelector</span><span>(</span><span>'#input'</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>timer<span>)</span> <span>{</span>
    <span>clearTimeout</span><span>(</span>timer<span>)</span><span>;</span>
  <span>}</span>
  timer <span>=</span> <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'여기에 ajax 요청'</span><span>,</span> e<span>.</span>target<span>.</span>value<span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>200</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>디바운싱 구현</li>
</ul>
<br>
<h2 id="_0814-modelattribute-requestparam-requestbody"> 0814 - @ModelAttribute, @RequestParam, @RequestBody</h2>
<h3 id="modelattribute"> @ModelAttribute</h3>
<ul>
<li>multipart/form-data 형태의 HTTP Body 내용과 HTTP 파라미터들을 Setter를 통해 1대1로 객체 바인딩</li>
<li>Json이나 XML과 같은 형태의 데이터를 MessageConverter를 통해 변환 시키는 @RequestBody와 달리, multipart/form-data 형태의 HTTP Body와 HTTP 파라미터들을 매핑시킨다는 차이</li>
</ul>
<h3 id="requestparam"> @RequestParam</h3>
<ul>
<li>1개의 HTTP요청 파라미터를 받기 위해서 사용</li>
<li>기본적으로 반드시 해당 파라미터가 전송되어야 한다 (기본이 true)
SS</li>
</ul>
<h3 id="requestbody"> RequestBody</h3>
<ul>
<li>Json(application/json) 형태의 HTTP Body 내용을 Java Object로 변환시켜주는 역할</li>
<li>Body가 존재하지 않는 Get 메소드에서는 사용 불가</li>
<li>MessageConverter들 중 하나인 MappingJackson2HttpMessageConverte를 통해 Java 객체로 변환</li>
</ul>
<br>
<h2 id="_0815-jackson-gson"> 0815 - jackson, gson</h2>
<blockquote>
<p>jackson과 gson 모두 Java에 대한 JSON 데이터 바인딩을 지원하는 라이브러리이다.</p>
</blockquote>
<div><pre><code>직렬화, serializing, marchal : java 객체 -&gt; json
역직렬화, deserializing, umarshal : json -&gt; java 객체
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="jackson"> jackson</h3>
<blockquote>
<p>Json 뿐만 아니라 XML과 YAML 도 지원하는 라이브러리다.
속도가 빠르고 유연하며 고용량의 JSON 데이터 처리 성능도 탁월.</p>
</blockquote>
<ul>
<li>직렬화</li>
</ul>
<div><pre><code><span>ObjectMapper</span> mapper <span>=</span> <span>new</span> <span>ObjectMapper</span><span>(</span><span>)</span><span>;</span> 
<span>String</span> jsonResult <span>=</span> mapper<span>.</span><span>writeValueAsString</span><span>(</span>json으로 바꾸고싶은 java객체<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>역직렬화</li>
</ul>
<div><pre><code><span>String</span> jsonInput <span>=</span> <span>"json 데이터"</span><span>;</span>
<span>ObjectMapper</span> mapper <span>=</span> <span>new</span> <span>ObjectMapper</span><span>(</span><span>)</span><span>;</span>
<span>Example</span> exam <span>=</span> mapper<span>.</span><span>readValue</span><span>(</span>jsonInput<span>,</span> <span>Example</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="gson"> gson</h3>
<blockquote>
<p>비교적 가벼우며 메이븐 저장소도 지원한다.</p>
</blockquote>
<ul>
<li>직렬화</li>
</ul>
<div><pre><code><span>String</span> jsonResult <span>=</span> <span>new</span> <span>Gson</span><span>(</span><span>)</span><span>.</span><span>toJson</span><span>(</span>json으로 바꾸고싶은 java객체<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>역직렬화</li>
</ul>
<div><pre><code><span>String</span> jsonInput <span>=</span> <span>"json 데이터"</span><span>;</span>
<span>Example</span> exam <span>=</span> <span>new</span> <span>Gson</span><span>(</span><span>)</span><span>.</span><span>fromJson</span><span>(</span>jsonInput<span>,</span> <span>Example</span><span>.</span><span>class</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0816 - 0822</title>
      <link>ahnjs/TIL/2021/0816/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0816/</guid>
      <source url="ahnjs/TIL/rss.xml">0816 - 0822</source>
      <pubDate>Thu, 02 Sep 2021 13:00:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0816-0822"> 0816 - 0822</h1>
<h2 id="_0816-redis란"> 0816 - Redis란?</h2>
<h3 id="nosql이란"> NOSql이란?</h3>
<blockquote>
<p>비관계형 데이터베이스, 키-벨류나 컬럼, 문서 형식의 데이터 모델을 이용.<br>
Not Only Sql, 비관계형 데이터 베이스<br>
아주 많은 양의 데이터를 효율적으로 처리, 데이터 분산처리, 빠른쓰기 및 데이터의 안정성 이 필요할때 사용</p>
</blockquote>
<h3 id="레디스-redis-란"> 레디스(Redis)란?</h3>
<blockquote>
<p>REDIS(REmote Dictionary Server)는 메모리 기반의 &quot;키-값&quot; 구조 데이터 관리 시스템이며, 모든 데이터를 메모리에 저장하고 조회하기에 빠른 Read, Write 속도를 보장하는 비 관계형 데이터베이스이다.</p>
</blockquote>
<ul>
<li>데이스는 크게 5가지 <code>String, Set, Sorted Set, Hash, List</code>의 데이터 형식을 지원한다.</li>
<li>Redis는 빠른 오픈 소스인 메모리 키-값 데이터 구조 스토어이며, 다양한 인 메모리 데이터 구조 집합을 제공하므로 사용자 정의 애플리케이션을 손쉽게 생성할 수 있다.</li>
<li>서비스의 특성이나 상황에따라 <code>캐시</code> 또는 <code>Persistence Data Storage</code>로 사용할 수 있다.</li>
</ul>
<br>
<h2 id="_0818-서버리스와-컨테이너"> 0818 - 서버리스와 컨테이너</h2>
<blockquote>
<p>서버리스(serverless)란 개발자가 서버를 관리할 필요 없이 애플리케이션을 빌드하고 실행할 수 있도록 하는 클라우드 네이티브 개발 모델이다.</p>
</blockquote>
<ul>
<li>
<p>서버리스 모델에도 서버가 존재하긴 하지만, 애플리케이션 개발에서와 달리 추상화되어 있다. 클라우드 제공업체가 서버 인프라에 대한 프로비저닝, 유지 관리, 스케일링 등의 일상적인 작업을 처리하며, 개발자는 배포를 위해 코드를 컨테이너에 패키징하기만 하면 된다.</p>
</li>
<li>
<p>서버리스 애플리케이션은 배포되고 나면 필요에 따라 자동으로 스케일 업되거나 스케일 다운왼다. 퍼블릭 클라우드 제공업체의 서버리스 오퍼링은 일반적으로 이벤트 기반 실행 모델을 통해 온디맨드로 미터링됩니다. 그러므로 서버리스 기능이 유휴 상태일 때는 아무런 비용도 들지 않습니다.</p>
</li>
</ul>
<h3 id="컨테이너"> 컨테이너</h3>
<blockquote>
<p>컨테이너는 어떤 환경에서나 실행하기 위해 필요한 모든 요소를 포함하는 소프트웨어 패키지이다. 컨테이너는 이러한 방식으로 운영체제를 가상화하며 프라이빗 데이터 센터에서 퍼블릭 클라우드 또는 개발자의 개인 노트북에 이르기까지 어디서나 실행된다.</p>
</blockquote>
<ul>
<li>
<p>컨테이너는 소프트웨어 서비스를 실행하는 데 필요한 특정 버번의 프로그래밍 언어 런타임 및 라이브러리와 같은 종속 항목과 애플리케이션 코드를 함께 포함하는 경량 패키지</p>
</li>
<li>
<p>컨테이너는 운영체제 수준에서 CPU, 메모리, 스토리지, 네트워크 리소스를 쉽게 공유할 수 있게 해주며 컨테이너가 실제로 실행되는 환경에서 애플리케이션을 추상화할 수 있는 논리 패키징 메커니즘을 제공</p>
</li>
</ul>
<h4 id="컨테이너-장점"> 컨테이너 장점</h4>
<ul>
<li>책임분리
<ul>
<li>개발자는 애플리케이션의 로직과 종속 항목에 집중, IT 운영팀은 특정 소프트웨어 버전 및 구성과 같은 세부 요소 대신 배포 및 관리에 집중</li>
</ul>
</li>
<li>워크로드 이동성
<ul>
<li>컨테이너는 운영체제를 가리지 않고, 가상머신, 물리적 서버, 개발자 컴퓨터, 데이터 센터, 온프레미스 환경, 퍼블릭 클라우드 등 사실상 어느 환경에서나 구동되므로 개발 및 배포가 편리</li>
</ul>
</li>
<li>애플리케이션 격리
<ul>
<li>컨테이너는 운영체제 수준에서 CPU, 메모리, 스토리지, 네트워크 리소스를 가상화하므로 개발자에게 다른 애플리케이션으로부터 논리적으로 격리된 OS 환경을 제공</li>
</ul>
</li>
</ul>
<h4 id="컨테이너와-vm의-차이"> 컨테이너와 VM의 차이</h4>
<ul>
<li>컨테이너는 VM보다 훨씬 더 경량.</li>
<li>컨테이너는 OS 수준에서 가상화되고 VM은 하드웨어 수준에서 가상화된다.</li>
<li>컨테이너는 OS 커널을 공유하며 VM에 필요한 것보다 훨씬 적은 메모리를 사용.</li>
</ul>
<br>
<h2 id="_0819-다자인-코드설계의-중요성"> 0819 - 다자인, 코드설계의 중요성</h2>
<h3 id="디자인이-왜-중요한가"> 디자인이 왜 중요한가?</h3>
<p>요즘 웹 애플리케이션 개발에서는 객체간의 복잡한 관계, 계층화 되지 않은 구조 등 모듈화가 전혀 없어도 개발자의 머리속에 모든 것들은 담아두고 개발을 할 수 있다.</p>
<p>=&gt; 하지만 특정 누군가만 손댈수 있고, 그 사람의 머리속에만 모든 애플리케이션 구조가 담겨져 있다면 안 좋은 디자인의 신호</p>
<p>서비스가 성공을 하면 무조건 새로운 기능을 요구받는데 이때, 문제가 발생한다.</p>
<h3 id="객체지향-디자인"> 객체지향 디자인</h3>
<p>자바를 비롯한 OOP 언어들은 데이터(Data)와 행위(Method)를 객체안에 통합시켜놓는다. 그리고 이들 각 객체들의 상호작용으로 애플리케이션이 이루어져있는데, 이 상호작용은 서로 주고 받는 메세지 속에있다. 즉, 객체는 메세지를 통해 상대 객체의 행동을 실행시킨다.</p>
<p>따라서 서로간의 행동을 실행시키기 위해서는 협력 객체에 대한 어느 정도의 이해도가 필요한데, 이 이해도가 어느정도 되느냐에 따라 좋은 객체지향 디자인이 될 수도 있고, 좋지 못한 객체지향 디자인이 될 수 있다.</p>
<p>따라서 객체지향 디자인을 한다고하면, 이 객체가 어떤 행동을 할지 예상할 수 있도록 코드를 배치해야만한다.</p>
<h3 id="좋은-디자인"> 좋은 디자인</h3>
<p>결국 변화에 대응하기 위해 어떻게 코드를 배치할까를 고민해야 한다.</p>
<p>정리하면 좋은 디자인이란 변화를 손쉽게 받아들일 수 있도록 코드를 배치하는 일이 된다.</p>
<br>
<h2 id="_0821-junit5-테스트-순서"> 0821 - Junit5 테스트 순서</h2>
<h3 id="testmethodorder"> @TestMethodOrder</h3>
<blockquote>
<p>@TestMethodOrder가 선언되어 있지 않다면 기본 알고리즘에 의해 순서가 정해지지만 아닌 경우도 있다. 따라서 테스트들의 실행 순서가 반드시 필요하다면 @TestMethodOrder(value = PER CLASS)를 사용해야 한다.</p>
</blockquote>
<ul>
<li>파라미터명
<ul>
<li>value</li>
</ul>
</li>
<li>타입
<ul>
<li>Class&lt;? extends MethodOrderer&gt;</li>
</ul>
</li>
<li>설명
<ul>
<li>정렬 타입
<ul>
<li>MethodName : 메소드명</li>
<li>DisplayName : @DisplayName 명</li>
<li>OrderAnnotation : @Order(n)</li>
<li>Random : 랜덤</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0822-빌드시-프로젝트-내에서-jdk버전-변경"> 0822 - 빌드시 프로젝트 내에서 JDK버전 변경</h2>
<h3 id="발생상황"> 발생상황</h3>
<ul>
<li>local jdk : 8</li>
<li>project jdk : 11
상황에서 build 실패<br>
=&gt; 11버전 애플리케이션 빌드 시에도 Maven이 1.8버전을 JDK로 사용</li>
</ul>
<h3 id="해결"> 해결</h3>
<h4 id="maven-프로젝트"> Maven 프로젝트</h4>
<div><pre><code><span><span>&lt;</span>build<span>></span></span>
    <span><span>&lt;</span>plugins<span>></span></span>
        <span>.</span><span>.</span><span>.</span>
        <span>&lt;</span><span>!</span><span>--</span> maven<span>-</span>compiler<span>-</span>plugin 설정 추가 <span>--</span><span>></span>
        <span><span>&lt;</span>plugin<span>></span></span>
            <span><span>&lt;</span>groupId<span>></span></span>org<span>.</span>apache<span>.</span>maven<span>.</span>plugins<span>&lt;</span><span>/</span>groupId<span>></span>
            <span><span>&lt;</span>artifactId<span>></span></span>maven<span>-</span>compiler<span>-</span>plugin<span>&lt;</span><span>/</span>artifactId<span>></span>
            <span><span>&lt;</span>version<span>></span></span><span>3.8</span><span>.1</span><span>&lt;</span><span>/</span>version<span>></span>
            <span><span>&lt;</span>configuration<span>></span></span>
                <span><span>&lt;</span>fork<span>></span></span><span>true</span><span>&lt;</span><span>/</span>fork<span>></span>
                <span>&lt;</span><span>!</span><span>--</span> 사용하고자 하는 JDK의 javac 경로를 지정해준다<span>.</span> <span>--</span><span>></span>
                <span><span>&lt;</span>executable<span>></span></span><span>C</span><span>:</span>\<span>Program</span> <span>Files</span>\<span>AdoptOpenJDK</span>\jdk<span>-</span><span>11.0</span><span>.3</span><span>.7</span><span>-</span>hotspot\bin\javac<span>&lt;</span><span>/</span>executable<span>></span>
                <span><span>&lt;</span>compilerVersion<span>></span></span>$<span>{</span>java<span>.</span>version<span>}</span><span>&lt;</span><span>/</span>compilerVersion<span>></span>
            <span>&lt;</span><span>/</span>configuration<span>></span>
        <span>&lt;</span><span>/</span>plugin<span>></span>
        <span>.</span><span>.</span><span>.</span>
    <span>&lt;</span><span>/</span>plugins<span>></span>
<span>&lt;</span><span>/</span>build<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><ul>
<li>Apache Maven 웹사이트에 있는 예제를 따라 <code>pom.xml</code>에 Maven compiler plugin 설정 추가</li>
</ul>
<div><pre><code><span>&lt;</span><span>!</span><span>--</span> https<span>:</span><span>/</span><span>/</span>mvnrepository<span>.</span>com<span>/</span>artifact<span>/</span>org<span>.</span>apache<span>.</span>maven<span>.</span>plugins<span>/</span>maven<span>-</span>surefire<span>-</span>plugin <span>--</span><span>></span>
<span><span>&lt;</span>dependency<span>></span></span>
    <span><span>&lt;</span>groupId<span>></span></span>org<span>.</span>apache<span>.</span>maven<span>.</span>plugins<span>&lt;</span><span>/</span>groupId<span>></span>
    <span><span>&lt;</span>artifactId<span>></span></span>maven<span>-</span>surefire<span>-</span>plugin<span>&lt;</span><span>/</span>artifactId<span>></span>
    <span><span>&lt;</span>version<span>></span></span><span>2.19</span><span>.1</span><span>&lt;</span><span>/</span>version<span>></span>
<span>&lt;</span><span>/</span>dependency<span>></span>

<span>&lt;</span><span>!</span><span>--</span> maven<span>-</span>surefire<span>-</span>plugin 추가 <span>--</span><span>></span>
<span><span>&lt;</span>plugin<span>></span></span>
    <span><span>&lt;</span>groupId<span>></span></span>org<span>.</span>apache<span>.</span>maven<span>.</span>plugins<span>&lt;</span><span>/</span>groupId<span>></span>
    <span><span>&lt;</span>artifactId<span>></span></span>maven<span>-</span>surefire<span>-</span>plugin<span>&lt;</span><span>/</span>artifactId<span>></span>
    <span><span>&lt;</span>version<span>></span></span><span>2.19</span><span>.1</span><span>&lt;</span><span>/</span>version<span>></span>
    <span>&lt;</span><span>!</span><span>--</span> 사용하고자 하는 JDK의 java 경로 <span>--</span><span>></span>
    <span><span>&lt;</span>configuration<span>></span></span>
        <span><span>&lt;</span>jvm<span>></span></span><span>C</span><span>:</span>\<span>Program</span> <span>Files</span>\<span>AdoptOpenJDK</span>\jdk<span>-</span><span>11.0</span><span>.3</span><span>.7</span><span>-</span>hotspot\bin\java<span>&lt;</span><span>/</span>jvm<span>></span>
    <span>&lt;</span><span>/</span>configuration<span>></span>
<span>&lt;</span><span>/</span>plugin<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>Maven Surefire plugin 의존성과 플로그인을 추가</li>
<li>테스트 코드가 있는 경우 빌드 전 테스트 시에 문제 발생때문에 추가</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0823 - 0829</title>
      <link>ahnjs/TIL/2021/0823/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0823/</guid>
      <source url="ahnjs/TIL/rss.xml">0823 - 0829</source>
      <pubDate>Thu, 02 Sep 2021 13:00:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0823-0829"> 0823 - 0829</h1>
<h2 id="_0824-configurationproperties"> 0824 - @ConfigurationProperties</h2>
<h3 id="configurationproperties"> @ConfigurationProperties</h3>
<blockquote>
<p>ConfigurationProperties는 properties 파일에 설정한 property 값을 자바 object에 매핑하여 해당 값을 사용하기 편하게 해준다.</p>
</blockquote>
<div><pre><code><span>@Data</span> <span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span> <span>"test.sample"</span><span>)</span> <span>public</span> <span>class</span> <span>TestSampleProperties</span> <span>{</span> 
    <span>private</span> <span>String</span> testStr<span>;</span> 
    <span>private</span> <span>int</span> testInt<span>;</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>java class의 변수명은 camel case</li>
<li>properties는 -하이픈을 사용한 snake case</li>
</ul>
<div><pre><code><span>test.sample.test-str</span><span>=</span><span>테스트 문자열 값 test.sample.test-int=1234</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>@Configuration</span>
<span>@EnableConfigurationProperties</span><span>(</span><span>TestSampleProperties</span><span>.</span><span>class</span><span>)</span>
<span>@PropertySource</span><span>(</span><span>"classpath:TestSample.properties"</span><span>)</span>
<span>public</span> <span>class</span> <span>TestSampleConfiguration</span> <span>{</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>@EnableConfigurationProperties 선언은 해당 Properties class로 object를 생성.</li>
<li>@PropertySource는 properties 파일을 호출
<ul>
<li>여러개 선언 가능 prefix로 구분</li>
</ul>
</li>
</ul>
<div><pre><code><span>@Service</span> <span>public</span> <span>class</span> <span>TestSampleService</span> <span>{</span> 
    <span>@Autowired</span> 
    <span>private</span> <span>TestSampleProperties</span> testSampleProperties<span>;</span> 
    
    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span> 
        <span>String</span> testStr <span>=</span> testSampleProperties<span>.</span><span>getTestStr</span><span>(</span><span>)</span><span>;</span> <span>// 해당 값을 사용 </span>
    <span>}</span> 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="conditional"> @Conditional*</h3>
<h4 id="conditionalonclass"> @ConditionalOnClass</h4>
<div><pre><code><span>@ConditionalOnClass</span><span>(</span><span>{</span> <span>EnableAspectJAutoProxy</span><span>.</span><span>class</span><span>,</span> <span>Aspect</span><span>.</span><span>class</span><span>,</span> <span>Advice</span><span>.</span><span>class</span><span>,</span> <span>AnnotatedElement</span><span>.</span><span>class</span> <span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>해당 설정된 class가 있는지 여부를 확인. 참조된 jar강 있는지 파악</li>
</ul>
<div><pre><code><span>@ConditionalOnProperty</span><span>(</span>prefix <span>=</span> <span>"spring.aop"</span><span>,</span> name <span>=</span> <span>"auto"</span><span>,</span> havingValue <span>=</span> <span>"true"</span><span>,</span> matchIfMissing <span>=</span> <span>true</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>설정된 property값이 있는지 확인</li>
</ul>
<br>
<h2 id="_0825-git-hub-인증-관련-이슈"> 0825 - git hub 인증 관련 이슈</h2>
<h3 id="소스트리-계정정보-수동-삭제"> 소스트리 계정정보 수동 삭제</h3>
<ul>
<li>소스트리를 이용할 시 권한 오류로 실패</li>
</ul>
<div><pre><code>remote: HTTP Basic: Access denied fatal: Authentication failed for https://gitlab.com/{{project}}
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>설정 파일 제거</li>
</ul>
<div><pre><code>* Windows 
~\AppData\Local\Atlassian\SourceTree\userhost ~\AppData\Local\Atlassian\SourceTree\passwd 

* Mac OS 
~/Library/Application Support/SourceTree
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li><code>hostusernamemap</code>, <code>{계정}@STAuth-github.com</code> 파일 삭제</li>
</ul>
<h3 id="소스트리-토큰으로-인증하기"> 소스트리 토큰으로 인증하기</h3>
<blockquote>
<p>8월 13일 이후 github 인증 정책 변경</p>
</blockquote>
<div><pre><code>Github
Settings
Developer settings
Personal access tokens
Generate new token
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>토큰 발행</li>
</ul>
<div><pre><code>계정추가
깃허브 선택
베이직 선택
사용자 이름
암호 = Access token 
프로토콜 SSH
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>소스트리 계정추가</li>
</ul>
<br>
<h2 id="_0826-어노테이션"> 0826 - 어노테이션</h2>
<h3 id="어노테이션이란"> 어노테이션이란?</h3>
<blockquote>
<p>어노테이션이란 메타데이터라고 볼 수 있다. 프로그램 실행 관점에서 보면 프로그램이 처리할 메인 데이터가 아니라 실행과정에서 데이터를 어떻게 처리할 것인지 알려주는 서브데이터라고 볼 수 있다.</p>
</blockquote>
<h3 id="어노테이션의-기능"> 어노테이션의 기능</h3>
<ul>
<li>
<p>컴파일러에 코드 문법 에러를 체크하도록 정보 제공</p>
</li>
<li>
<p>개발 툴에서 빌드나 배치시 코드를 자동으로 생성할 수 있는지 정보 제공</p>
</li>
<li>
<p>실행 시 특정 기능을 실행하도록 정보 제공</p>
</li>
<li>
<p>사용이유?<br>
=&gt; 코드에 부가적인 설명의 역할. 반복적으로 처리해야하는 일들을 자동화</p>
</li>
</ul>
<h3 id="어노테이션-정의"> 어노테이션 정의</h3>
<div><pre><code><span>@Target</span><span>(</span><span>{</span><span>ElementType</span><span>.</span><span>[</span>적용대상<span>]</span><span>}</span><span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span><span>[</span>정보유지되는 대상<span>]</span><span>)</span>
<span>public</span> <span>@interface</span> <span>[</span>어노테이션명<span>]</span><span>{</span>
	<span>public</span> 타입 <span>elementName</span><span>(</span><span>)</span> <span>[</span><span>default</span> 값<span>]</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>
<p>@Target({ElementType.[적용대상]}) : 어떠한 값에 어노테이션을 적용할 것인지</p>
<ul>
<li>TYPE : 클래스, 인터페이스, 열거 타입</li>
<li>ANNOTATION_TYPE : 어노테이션</li>
<li>FIELD : 필드</li>
<li>CONSTRUCTOR : 생성자</li>
<li>METHOD : 메소드</li>
<li>LOCAL_VARIABLE : 로컬 변수</li>
<li>PACKAGE : 패키지</li>
</ul>
</li>
<li>
<p>@Retention(RetentionPolicy.[정보유지되는 대상]) : 어노테이션 값들은 언제까지 유지할 것인지 값을 입력. 대부분 어노테이션은 Runtime시에 사용</p>
<ul>
<li>SOURCE : 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할때만 의미가 있으며, 바이트 코드 파일에는 정보가 남지 않는다.</li>
<li>CLASS : 바이트 코드 파일까지 어노테이션 정보를 유지한다. 하지만 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.</li>
<li>RUNTIME : 바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임에 어노테이션 정보를 얻을 수 있다.</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0827-http-live-streaming-hls"> 0827 - HTTP Live Streaming (HLS)</h2>
<h3 id="hls란"> HLS란?</h3>
<blockquote>
<p>HTTP 기반 적응 비트레이트 스트리밍 통신 프로토콜.<br>
스트리밍 데이터를 MPEG-2 Transport Stream에 담아 시간 단위로 잘게 쪼개서 전송한다. 그리고 어떤 파일을 재생해야 하는 지에 대한 정보는 m3u8 파일을 이용하여 플레이어에 전달한다.</p>
</blockquote>
<h3 id="특징"> 특징</h3>
<ul>
<li>HTTP를 전송 채널로 사용. HTTP는 양방 방식이 아니기 때문에 라이브 스트리밍을 위해서는 단점을 극복할 별도의 방식이 필요하지만, 방화벽에서 HTTP 서버로의 요청만 통과시키기면 되기 때문에 방화벽의 설정이 단순.</li>
<li>요청과 응답이 1:1로 대응되므로 NAT 환경에서도 서버와 동신하는것이 쉽다.</li>
<li>웹 서비스를 위한 캐시 구조를 그대로 사용할 수 있고, 기존에 구축되어 있는 CDN(Content Delivery Network)도 특별히 변경하지 않고 그대로 이용.</li>
</ul>
<br>
<h2 id="_0829-백앤드-개발자-로드맵"> 0829 - 백앤드 개발자 로드맵</h2>
<h3 id="백앤드-개발자-로드맵-현재-시점-파악하기"> 백앤드 개발자 로드맵(현재 시점 파악하기)</h3>
<div><pre><code>학습과 적용, 응용에 대한 태도 -&gt; 
클린 코드, 좋은 설계를 이끄는 단위 테스트 -&gt; 
웹 기술과 웹 프로그래밍 -&gt; 
스프링 프레임워크 -&gt; 
데이터베이스 -&gt; 
ORM 프레임워크 -&gt; 
… -&gt; 
CI/CD를 위한 인프라스트럭처 -&gt; 
클린 아키텍처 -&gt; 
DDD -&gt; 
분산 시스템 -&gt; 
인프라스트럭처 -&gt; 
MSA -&gt; 
…
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0830 - 0905</title>
      <link>ahnjs/TIL/2021/0830/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0830/</guid>
      <source url="ahnjs/TIL/rss.xml">0830 - 0905</source>
      <pubDate>Thu, 02 Sep 2021 13:00:49 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0830-0905"> 0830 - 0905</h1>
<h2 id="_0831-spring-consumes와-produces의-차이"> 0831 - Spring : consumes와 produces의 차이</h2>
<p>Controller에서 Mapping을 할 때 주고 받는 데이터를 강제함으로써 오류상황을 줄인다.
이때 사용하는 것 중 하나가 Media Types이다.</p>
<h3 id="consumes"> consumes</h3>
<p>consumes는 들어오는 데이터 타입을 정의할 때 이용한다.</p>
<div><pre><code><span>@PostMapping</span><span>(</span>path <span>=</span> <span>"/pets"</span><span>,</span> consumes <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span> 
<span>public</span> <span>void</span> <span>addPet</span><span>(</span><span>@RequestBody</span> <span>Pet</span> pet<span>)</span> <span>{</span>
    <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>이렇게 처리를 하게되면 해당 uri를 호출하는 쪽에서는 헤더에 보내는 데이터가 json이라는 것을 명시해야 한다.</li>
</ul>
<div><pre><code>Content-Type:application/java
</code></pre>
<div><span>1</span><br></div></div><h3 id="produces"> produces</h3>
<p>produces는 반환하는 데이터 타입을 정의한다.</p>
<div><pre><code><span>@GetMapping</span><span>(</span>path <span>=</span> <span>"/pets/{petId}"</span><span>,</span> produces <span>=</span> <span>MediaType</span><span>.</span>APPLICATION_JSON_VALUE<span>)</span> 
<span>@ResponseBody</span>
<span>public</span> <span>Pet</span> <span>getPet</span><span>(</span><span>@PathVariable</span> <span>String</span> petId<span>)</span> <span>{</span>
    <span>// ...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>이럴 경우 반환 타입이 json으로 강제된다.</li>
</ul>
<div><pre><code>Accept:application/json
</code></pre>
<div><span>1</span><br></div></div><h3 id="요약"> 요약</h3>
<ul>
<li>consumes는 클라이언트가 서버에게 보내는 데이터 타입을 명시한다.</li>
<li>produces는 서버가 클라이언트에게 반환하는 데이터 타입을 명시한다.</li>
</ul>
<br>
<h2 id="_0901-배열-정렬"> 0901 - 배열 정렬</h2>
<h3 id="arrays-sort에-comparator사용-compare-메소드-구현"> Arrays.sort에 Comparator사용 compare 메소드 구현</h3>
<ul>
<li>Comparator는 기본적으로 객체를 비교할 수 있또록 해주는 인터페이스이다.</li>
<li>자바 기본자료형이 아닌 사용자 클래스의 비교나 특정 규칙에 의해 비교를 하고 싶은 경우에 구현한다.</li>
</ul>
<h4 id="arrays-sort의-형태"> Arrays.sort의 형태</h4>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>void</span> <span>sort</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>,</span> <span>Comparator</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span></span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>c <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>sort</span><span>(</span>a<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span><span>LegacyMergeSort</span><span>.</span>userRequested<span>)</span>
            <span>legacyMergeSort</span><span>(</span>a<span>,</span> c<span>)</span><span>;</span>
        <span>else</span>
            <span>TimSort</span><span>.</span><span>sort</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> a<span>.</span>length<span>,</span> c<span>,</span> <span>null</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>인자로 Comparator의 타입을 넣고 compare 메소드를 오버라이딩한다.</li>
</ul>
<h4 id="예제"> 예제</h4>
<div><pre><code><span>String</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>String</span><span>[</span><span>N</span><span>]</span><span>;</span>	<span>// 배열에 단어가 이미 초기화 되었다고 가정</span>
 
<span>Arrays</span><span>.</span><span>sort</span><span>(</span>arr<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span><span>)</span> <span>{</span>		
	<span>@Override</span>
	<span>public</span> <span>int</span> <span>compare</span><span>(</span><span>String</span> s1<span>,</span> <span>String</span> s2<span>)</span> <span>{</span>
		<span>// 단어 길이가 같을 경우</span>
		<span>if</span><span>(</span>s1<span>.</span><span>length</span><span>(</span><span>)</span> <span>==</span> s2<span>.</span><span>length</span><span>(</span><span>)</span><span>}</span> <span>{</span>
			<span>return</span> s1<span>.</span><span>compareTo</span><span>(</span>s2<span>)</span><span>;</span>	<span>// 사전 순 정렬</span>
		<span>}</span>
		<span>// 그 외의 경우</span>
		<span>else</span> <span>{</span>
			<span>return</span> s1<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> s2<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>
<li>compare 메소르 리턴 타입이 int인 이유는 <code>양의 정수</code>, <code>0</code>, <code>음의 정수</code>에 따라 위치를 변경한다.
<ul>
<li>양수 = 위치 변경</li>
<li>0 and 음수 = 그대로</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0902-자바-정규-표현식-pattern-matcher"> 0902 - 자바 정규 표현식 (Pattern, Matcher)</h2>
<h3 id="정규표현식"> 정규표현식</h3>
<blockquote>
<p>정규표현식(Regular Expression)이란 컴퓨터 과학의 정규언어로부터 유래한 것으로 특정한 규칙을 가진 문자열의 집합을 표현하기 위해 쓰이는 형식언어이다. 정해진 형식에 맞는지 검증해야할때 사용 할 수 있다.</p>
</blockquote>
<h3 id="자바에서의-정규표현식"> 자바에서의 정규표현식</h3>
<ul>
<li>정규 표현식을 작성하는 방법은 자바 API java.util.regex 패키지를 사용해야 한다.</li>
</ul>
<h3 id="pattern-클래스"> Pattern 클래스</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Pattern</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexExample</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>  <span>{</span>
    
            <span>String</span> pattern <span>=</span> <span>"^[0-9]*$"</span><span>;</span> <span>//숫자만</span>
            <span>String</span> val <span>=</span> <span>"123456789"</span><span>;</span> <span>//대상문자열</span>
        
            <span>boolean</span> regex <span>=</span> <span>Pattern</span><span>.</span><span>matches</span><span>(</span>pattern<span>,</span> val<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>regex<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>문자열 패턴 검증은, Pattern 클래스의 matches() 메소드를 활용.</li>
</ul>
<h4 id="pattern-클래스의-주요-메서드"> Pattern 클래스의 주요 메서드</h4>
<ul>
<li>compile(String regex) : 주어진 정규포현식으로부터 패턴을 생성</li>
<li>matcher(CharSequence input) : 대상 문자열이 패턴과 일치할 경우 true를 반환.</li>
<li>asPredicate() : 문자열을 일치시키는데 사용할 수 있는 술어를 작성.</li>
<li>pattern() : 컴파일된 정규표현식을 String 형태로 반환.</li>
<li>split(CharSequence input) : 문자열을 주어진 인자값 CharSequence 패턴데 따라 분리.</li>
</ul>
<h3 id="matcher-클래스"> Matcher 클래스</h3>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Matcher</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>regex<span>.</span></span><span>Pattern</span><span>;</span>

<span>public</span> <span>class</span> <span>RegexExample</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>  <span>{</span>
            <span>Pattern</span> pattern <span>=</span> <span>Pattern</span><span>.</span><span>compile</span><span>(</span><span>"^[a-zA-Z]*$"</span><span>)</span><span>;</span> <span>//영문자만</span>
            <span>String</span> val <span>=</span> <span>"abcdef"</span><span>;</span> <span>//대상문자열</span>
	
            <span>Matcher</span> matcher <span>=</span> pattern<span>.</span><span>matcher</span><span>(</span>val<span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>matcher<span>.</span><span>find</span><span>(</span><span>)</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ul>
<li>Matcher 클래스는 대상 문자열의 패턴을 해석하고 주어진 패턴과 일치하는지 판별할 때 주로 사용.</li>
</ul>
<h4 id="matcher-클래스-주요-메서드"> Matcher 클래스 주요 메서드</h4>
<ul>
<li>matches() : 대상 문자열과 패턴이 일치할 경우 true 반환.</li>
<li>find() : 대상 문자열과 패턴이 일치하는 경우 true를 반환하고, 그 위치로 이동.</li>
<li>find(int start) : start위치 이후부터 매칭검색을 수행.</li>
<li>start() : 매칭되는 문자열 시작위치 반환.</li>
<li>start(int group) : 지정된 그룹이 매칭되는 시작위치 반환.</li>
<li>end() : 매칭되는 문자열 끝 다음 문자위치 반환.</li>
<li>end(int group) : 지정되 그룹이 매칭되는 끝 다음 문자위치 반환.</li>
<li>group() : 매칭된 부분을 반환.</li>
<li>group(int group) : 매칭된 부분중 group번 그룹핑 매칭부분 반환.</li>
<li>groupCount() : 패턴내 그룹핑한(괄호지정) 전체 갯수를 반환.</li>
</ul>
<br>
<h2 id="_0903-bean-validation-데이터-유효성-검사-프레임워크-사용하기"> 0903 - Bean Validation 데이터 유효성 검사 프레임워크 사용하기.</h2>
<h3 id="설치"> 설치</h3>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-validation<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="제약-설정과-검사"> 제약 설정과 검사</h3>
<div><pre><code><span>public</span> <span>class</span> <span>CreateContact</span> <span>{</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>64</span><span>)</span> <span>// 최대 길이 64</span>
    <span>@NotBlank</span> <span>// 빈문자열은 안됨</span>
    <span>private</span> <span>String</span> uid<span>;</span>
    <span>@NotNull</span> <span>// null 안됨</span>
    <span>private</span> <span>ContactType</span> contactType<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>1_600</span><span>)</span> <span>// 최대 길이 1,600</span>
    <span>private</span> <span>String</span> contact<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>도메인 검증</li>
</ul>
<div><pre><code> <span>@BeforeClass</span>
    <span>public</span> <span>static</span> <span>void</span> <span>beforeClass</span><span>(</span><span>)</span> <span>{</span>
        <span>Locale</span><span>.</span><span>setDefault</span><span>(</span><span>Locale</span><span>.</span>US<span>)</span><span>;</span> <span>// locale 설정에 따라 에러 메시지가 달라진다.</span>
    <span>}</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>test_validate</span><span>(</span><span>)</span> <span>{</span>
        <span>// Given</span>
        <span>final</span> <span>Validator</span> validator <span>=</span> <span>Validation</span><span>.</span><span>buildDefaultValidatorFactory</span><span>(</span><span>)</span><span>.</span><span>getValidator</span><span>(</span><span>)</span><span>;</span>

        <span>final</span> <span>CreateContact</span> createContact <span>=</span> <span>CreateContact</span>
            <span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>.</span><span>uid</span><span>(</span><span>null</span><span>)</span> <span>// @NotBlank가 정의되어 있기때문에 null이 오면 안된다.</span>
            <span>.</span><span>contact</span><span>(</span><span>"000"</span><span>)</span>
            <span>.</span><span>contactType</span><span>(</span><span>ContactType</span><span>.</span>PHONE_NUMBER<span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>

        <span>// When</span>
        <span>final</span> <span>Collection</span><span><span>&lt;</span><span>ConstraintViolation</span><span>&lt;</span><span>CreateContact</span><span>></span><span>></span></span> constraintViolations <span>=</span> validator<span>.</span><span>validate</span><span>(</span>createContact<span>)</span><span>;</span>

        <span>// Then</span>
        <span>assertEquals</span><span>(</span><span>1</span><span>,</span> constraintViolations<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>;</span>  <span>// ConstraintViolation에 실패에 대한 정보가 담긴다.</span>
        <span>assertEquals</span><span>(</span><span>"must not be blank"</span><span>,</span> constraintViolations<span>.</span><span>iterator</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ul>
<li>유효성 검사 검증 코드</li>
</ul>
<h3 id="spring에서-사용하기"> Spring에서 사용하기</h3>
<ul>
<li>Service나 Bean에서 사용하기 위해서는 <code>@Validated</code>와 <code>@Valid</code>를 추가</li>
</ul>
<div><pre><code><span>@Validated</span> <span>// 여기에 추가</span>
<span>@Service</span>
<span>public</span> <span>class</span> <span>ContactService</span> <span>{</span>
    <span>public</span> <span>void</span> <span>createContact</span><span>(</span><span>@Valid</span> <span>CreateContact</span> createContact<span>)</span> <span>{</span> <span>// '@Valid'가 설정된 메서드가 호출될 때 유효성 검사를 진행한다.</span>
        <span>// Do Something</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>Controller에서는 <code>@Validated</code>가 필요 없다. 검사를 진행할 곳에 '@Valid'를 추가하면 된다.</li>
</ul>
<div><pre><code>    <span>@PostMapping</span><span>(</span><span>"/contacts"</span><span>)</span>
    <span>public</span> <span>Response</span> <span>createContact</span><span>(</span><span>@Valid</span> <span>CreateContact</span> createContact<span>)</span> <span>{</span> <span>// 메서드 호출 시 유효성 검사 진행</span>
        <span>return</span> <span>Response</span>
            <span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>.</span><span>header</span><span>(</span><span>Header</span>
                <span>.</span><span>builder</span><span>(</span><span>)</span>
                <span>.</span><span>isSuccessful</span><span>(</span><span>true</span><span>)</span>
                <span>.</span><span>resultCode</span><span>(</span><span>0</span><span>)</span>
                <span>.</span><span>resultMessage</span><span>(</span><span>"success"</span><span>)</span>
                <span>.</span><span>build</span><span>(</span><span>)</span><span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="컨테이너에서의-사용-컬렉션-맵"> 컨테이너에서의 사용(컬렉션, 맵, ...)</h3>
<div><pre><code><span>public</span> <span>class</span> <span>DeleteContacts</span> <span>{</span>
    <span>@Min</span><span>(</span><span>1</span><span>)</span>
    <span>private</span> <span>Collection</span><span>&lt;</span><span>@Length</span><span>(</span>max <span>=</span> <span>64</span><span>)</span> <span>@NotBlank</span> <span>String</span><span>></span> uids<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="사용자-정의-제약-custom-constraint"> 사용자 정의 제약(Custom Constraint)</h3>
<ul>
<li>임의의 제약(Constraint)과 검증자(Validator)를 구현</li>
</ul>
<div><pre><code><span>@Target</span><span>(</span><span>{</span>METHOD<span>,</span> FIELD<span>,</span> ANNOTATION_TYPE<span>,</span> CONSTRUCTOR<span>,</span> PARAMETER<span>,</span> TYPE_USE<span>}</span><span>)</span>
<span>@Retention</span><span>(</span>RUNTIME<span>)</span>
<span>@Constraint</span><span>(</span>validatedBy <span>=</span> <span>NoEmojiValidator</span><span>.</span><span>class</span><span>)</span>
<span>@Documented</span>
<span>public</span> <span>@interface</span> <span>NoEmoji</span><span>{</span>
    <span>String</span> <span>message</span><span>(</span><span>)</span> <span>default</span> <span>"Emoji is not allowed"</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>groups</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Payload</span><span>></span></span><span>[</span><span>]</span> <span>payload</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>@Target</span><span>(</span><span>{</span>METHOD<span>,</span> FIELD<span>,</span> ANNOTATION_TYPE<span>,</span> CONSTRUCTOR<span>,</span> PARAMETER<span>}</span><span>)</span>
    <span>@Retention</span><span>(</span>RUNTIME<span>)</span>
    <span>@Documented</span>
    <span>@interface</span> <span>List</span><span>{</span>
        <span>NoEmoji</span><span>[</span><span>]</span> <span>value</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>class</span> <span>NoEmojiValidator</span> <span>implements</span> <span>ConstraintValidator</span><span><span>&lt;</span><span>NoEmoji</span><span>,</span> <span>String</span><span>></span></span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>String</span> value<span>,</span> <span>ConstraintValidatorContext</span> context<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>StringUtils</span><span>.</span><span>isEmpty</span><span>(</span>value<span>)</span> <span>==</span> <span>true</span><span>)</span> <span>{</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>

        <span>return</span> <span>EmojiParser</span><span>.</span><span>parseToAliases</span><span>(</span>value<span>)</span><span>.</span><span>equals</span><span>(</span>value<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>CreateContact</span> <span>{</span>
    <span>@NoEmoji</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>64</span><span>)</span>
    <span>@NotBlank</span>
    <span>private</span> <span>String</span> uid<span>;</span>
    <span>@NotNull</span>
    <span>private</span> <span>ContactType</span> contactType<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>1_600</span><span>)</span>
    <span>private</span> <span>String</span> contact<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="제약-그룹-grouping"> 제약 그룹(Grouping)</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Message</span> <span>{</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>128</span><span>)</span>
    <span>@NotEmpty</span>
    <span>private</span> <span>String</span> title<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>1024</span><span>)</span>
    <span>@NotEmpty</span>
    <span>private</span> <span>String</span> body<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>32</span><span>,</span> groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>
    <span>@NotEmpty</span><span>(</span>groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>  <span>// 그룹을 지정할 수 있다. (기본 값은 javax.validation.groups.Default)</span>
    <span>private</span> <span>String</span> contact<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>64</span><span>,</span> groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>
    <span>@NotEmpty</span><span>(</span>groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>
    <span>private</span> <span>String</span> removeGuide<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>public</span> <span>interface</span> <span>Ad</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>'Ad.class'는 단순히 그룹을 지정하기 위한 마커 인터페이스(Marker Interface)다.</li>
</ul>
<div><pre><code><span>@Validated</span>
<span>@Service</span>
<span>public</span> <span>class</span> <span>MessageService</span> <span>{</span>
    <span>@Validated</span><span>(</span><span>Ad</span><span>.</span><span>class</span><span>)</span> <span>// 메서드 호출 시 Ad 그룹이 지정된 제약만 검사한다.</span>
    <span>public</span> <span>void</span> <span>sendAdMessage</span><span>(</span><span>@Valid</span> <span>Message</span> message<span>)</span> <span>{</span>
        <span>// Do Something</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>sendNormalMessage</span><span>(</span><span>@Valid</span> <span>Message</span> message<span>)</span> <span>{</span>
        <span>// Do Something</span>
    <span>}</span>

    <span>/**
     * 주의: 이렇게 호출하면 Spring AOP Proxy 구조상 @Valid를 설정한 메서드가 호출되어도 유효성 검사가 동작하지 않는다. 
     * Spring의 AOP Proxy 구조에 대한 설명은 다음 링크를 참고하자.
     * - https://docs.spring.io/spring/docs/5.2.3.RELEASE/spring-framework-reference/core.html#aop-understanding-aop-proxies
     */</span>
    <span>public</span> <span>void</span> <span>sendMessage</span><span>(</span><span>Message</span> message<span>,</span> <span>boolean</span> isAd<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>isAd<span>)</span> <span>{</span>
            <span>sendAdMessage</span><span>(</span>message<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>sendNormalMessage</span><span>(</span>message<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="클래스-단위-제약-class-level-constraint-과-조건부-검사-conditional-validation"> 클래스 단위 제약(Class Level Constraint)과 조건부 검사(Conditional Validation)</h3>
<ul>
<li>도메일 보델의 속성긔 값에 따라 데이터 유혀성 검사를 다르게 해야할 경우에 사용</li>
</ul>
<div><pre><code><span>@AdMessageConstraint</span> <span>// 이 커스텀 제약을 구현할 것이다.</span>
<span>public</span> <span>class</span> <span>Message</span> <span>{</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>128</span><span>)</span>
    <span>@NotEmpty</span>
    <span>private</span> <span>String</span> title<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>1024</span><span>)</span>
    <span>@NotEmpty</span>
    <span>private</span> <span>String</span> body<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>32</span><span>,</span> groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>
    <span>@NotEmpty</span><span>(</span>groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>
    <span>private</span> <span>String</span> contact<span>;</span>
    <span>@Length</span><span>(</span>max <span>=</span> <span>64</span><span>,</span> groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>
    <span>@NotEmpty</span><span>(</span>groups <span>=</span> <span>Ad</span><span>.</span><span>class</span><span>)</span>
    <span>private</span> <span>String</span> removeGuide<span>;</span>
    <span>private</span> <span>boolean</span> isAd<span>;</span> <span>// 광고 여부를 설정할 수 있는 속성</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><pre><code><span>@Target</span><span>(</span><span>{</span>TYPE<span>}</span><span>)</span>
<span>@Retention</span><span>(</span>RUNTIME<span>)</span>
<span>@Constraint</span><span>(</span>validatedBy <span>=</span> <span>AdMessageConstraintValidator</span><span>.</span><span>class</span><span>)</span>
<span>@Documented</span>
<span>public</span> <span>@interface</span> <span>AdMessageConstraint</span> <span>{</span>
    <span>String</span> <span>message</span><span>(</span><span>)</span> <span>default</span> <span>""</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> <span>groups</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>Class</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Payload</span><span>></span></span><span>[</span><span>]</span> <span>payload</span><span>(</span><span>)</span> <span>default</span> <span>{</span><span>}</span><span>;</span>

    <span>public</span> <span>class</span> <span>AdMessageConstraintValidator</span> <span>implements</span> <span>ConstraintValidator</span><span><span>&lt;</span><span>AdMessageConstraint</span><span>,</span> <span>Message</span><span>></span></span> <span>{</span>
        <span>private</span> <span>Validator</span> validator<span>;</span>

        <span>public</span> <span>AdMessageConstraintValidator</span><span>(</span><span>Validator</span> validator<span>)</span> <span>{</span>
            <span>this</span><span>.</span>validator <span>=</span> validator<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>boolean</span> <span>isValid</span><span>(</span><span>Message</span> value<span>,</span> <span>ConstraintValidatorContext</span> context<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>value<span>.</span><span>isAd</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                <span>final</span> <span>Set</span><span><span>&lt;</span><span>ConstraintViolation</span><span>&lt;</span><span>Object</span><span>></span><span>></span></span> constraintViolations <span>=</span> validator<span>.</span><span>validate</span><span>(</span>value<span>,</span> <span>Ad</span><span>.</span><span>class</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span><span>CollectionUtils</span><span>.</span><span>isNotEmpty</span><span>(</span>constraintViolations<span>)</span><span>)</span> <span>{</span>
                    context<span>.</span><span>disableDefaultConstraintViolation</span><span>(</span><span>)</span><span>;</span>
                    constraintViolations
                            <span>.</span><span>stream</span><span>(</span><span>)</span>
                            <span>.</span><span>forEach</span><span>(</span>constraintViolation <span>-></span> <span>{</span>
                                context<span>.</span><span>buildConstraintViolationWithTemplate</span><span>(</span>constraintViolation<span>.</span><span>getMessageTemplate</span><span>(</span><span>)</span><span>)</span>
                                        <span>.</span><span>addPropertyNode</span><span>(</span>constraintViolation<span>.</span><span>getPropertyPath</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span>
                                        <span>.</span><span>addConstraintViolation</span><span>(</span><span>)</span><span>;</span>
                            <span>}</span><span>)</span><span>;</span>
                    <span>return</span> <span>false</span><span>;</span>
                <span>}</span>
            <span>}</span>

            <span>return</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><div><pre><code><span>@Validated</span>
<span>@Service</span>
<span>public</span> <span>class</span> <span>MessageService</span> <span>{</span>
    <span>/**
     * message.isAd가 true이면 contcat, removeGuide 속성까지 검사한다.
     */</span>
    <span>public</span> <span>void</span> <span>sendMessage</span><span>(</span><span>@Valid</span> <span>Message</span> message<span>)</span> <span>{</span>
         <span>// Do Something</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="오류-처리-error-handling"> 오류 처리(Error Handling)</h3>
<ul>
<li>데이터 유효성 검사 시 실패가 발생하면 ConstraintViolationException 발생. 이를 @ControllerAdvice
구현 컨트롤러에서 @ExceptionHandler 핸들러 구현</li>
</ul>
<div><pre><code><span>@ControllerAdvice</span>
<span>public</span> <span>class</span> <span>GlobalExceptionHandler</span> <span>extends</span> <span>ResponseEntityExceptionHandler</span> <span>{</span>
    <span>@ExceptionHandler</span><span>(</span>value <span>=</span> <span>ConstraintViolationException</span><span>.</span><span>class</span><span>)</span> <span>// 유효성 검사 실패 시 발생하는 예외를 처리</span>
    <span>@ResponseBody</span>
    <span>protected</span> <span>Response</span> <span>handleException</span><span>(</span><span>ConstraintViolationException</span> exception<span>)</span> <span>{</span>
        <span>return</span> <span>Response</span>
            <span>.</span><span>builder</span><span>(</span><span>)</span>
            <span>.</span><span>header</span><span>(</span><span>Header</span>
                <span>.</span><span>builder</span><span>(</span><span>)</span>
                <span>.</span><span>isSuccessful</span><span>(</span><span>false</span><span>)</span>
                <span>.</span><span>resultCode</span><span>(</span><span>-</span><span>400</span><span>)</span>
                <span>.</span><span>resultMessage</span><span>(</span><span>getResultMessage</span><span>(</span>exception<span>.</span><span>getConstraintViolations</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>// 오류 응답을 생성</span>
                <span>.</span><span>build</span><span>(</span><span>)</span><span>)</span>
            <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>protected</span> <span>String</span> <span>getResultMessage</span><span>(</span><span>final</span> <span>Iterator</span><span><span>&lt;</span><span>ConstraintViolation</span><span>&lt;</span><span>?</span><span>></span><span>></span></span> violationIterator<span>)</span> <span>{</span>
        <span>final</span> <span>StringBuilder</span> resultMessageBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>violationIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span> <span>==</span> <span>true</span><span>)</span> <span>{</span>
            <span>final</span> <span>ConstraintViolation</span><span><span>&lt;</span><span>?</span><span>></span></span> constraintViolation <span>=</span> violationIterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
            resultMessageBuilder
                <span>.</span><span>append</span><span>(</span><span>"['"</span><span>)</span>
                <span>.</span><span>append</span><span>(</span><span>getPopertyName</span><span>(</span>constraintViolation<span>.</span><span>getPropertyPath</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>// 유효성 검사가 실패한 속성</span>
                <span>.</span><span>append</span><span>(</span><span>"' is '"</span><span>)</span>
                <span>.</span><span>append</span><span>(</span>constraintViolation<span>.</span><span>getInvalidValue</span><span>(</span><span>)</span><span>)</span> <span>// 유효하지 않은 값</span>
                <span>.</span><span>append</span><span>(</span><span>"'. "</span><span>)</span>
                <span>.</span><span>append</span><span>(</span>constraintViolation<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span> <span>// 유효성 검사 실패 시 메시지</span>
                <span>.</span><span>append</span><span>(</span><span>"]"</span><span>)</span><span>;</span>

            <span>if</span> <span>(</span>violationIterator<span>.</span><span>hasNext</span><span>(</span><span>)</span> <span>==</span> <span>true</span><span>)</span> <span>{</span>
                resultMessageBuilder<span>.</span><span>append</span><span>(</span><span>", "</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> resultMessageBuilder<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>protected</span> <span>String</span> <span>getPopertyName</span><span>(</span><span>String</span> propertyPath<span>)</span> <span>{</span>
        <span>return</span> propertyPath<span>.</span><span>substring</span><span>(</span>propertyPath<span>.</span><span>lastIndexOf</span><span>(</span><span>'.'</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// 전체 속성 경로에서 속성 이름만 가져온다.</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id="동적-메시지-생성-message-interpolation"> 동적 메시지 생성(Message Interpolation)</h3>
<div><pre><code><span>.</span><span>.</span><span>.</span>
<span>public</span> <span>@interface</span> <span>NoEmoji</span><span>{</span>
    <span>String</span> <span>message</span><span>(</span><span>)</span> <span>default</span> <span>"Emoji is not allowed"</span><span>;</span>

    <span>.</span><span>.</span><span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>매개 변수를 사용할 수 있다.
<ol>
<li>'{}'또는 '${}'로 둘러싼다.</li>
<li>{,},,$는 문자로 취급.</li>
<li>'{'는 매개변수의 시작, '}'는 매개변수의 끝, \는 확장문자, '$'는 표현식 시작으로 취급.</li>
</ol>
</li>
</ul>
<h3 id="참고"> 참고</h3>
<p>https://meetup.toast.com/posts/223</p>
]]></content:encoded>
    </item>
    <item>
      <title>0301 - 0307</title>
      <link>ahnjs/TIL/2021/0301/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0301/</guid>
      <source url="ahnjs/TIL/rss.xml">0301 - 0307</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0301-0307"> 0301 - 0307</h1>
<h2 id="_0301-spring-boot-mybatis"> 0301 - Spring boot &amp; Mybatis</h2>
<h4 id="mapperscan"> @MapperScan</h4>
<div><pre><code>@MapperScan(basePackages = &quot;co.worker.sponge_scheduler.repository&quot;)
</code></pre>
<div><span>1</span><br></div></div><h4 id="mybatis-properties"> mybatis properties</h4>
<div><pre><code><span>mybatis.type-aliases-package</span><span>=</span><span>co.worker.sponge_scheduler.model</span>
<span>mybatis.mapper-locations</span><span>=</span><span>mybatis-mapper/**/*.xml</span>
<span>#mybatis.type-handlers-package=com.example.typehandler</span>
<span>mybatis.configuration.map-underscore-to-camel-case</span><span>=</span><span>true</span>
<span>#mybatis.configuration.default-fetch-size=100</span>
<span>#mybatis.configuration.default-statement-timeout=30</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="mapper"> @Mapper</h4>
<h4 id="mapper-xml"> mapper.xml</h4>
<ul>
<li>namespace</li>
</ul>
<br>
<hr>
<h2 id="_0302-quartz-scheduler"> 0302 - quartz-scheduler</h2>
<h4 id="구조"> 구조</h4>
<h5 id="job"> Job</h5>
<p>Quartz API에서 단 하나의 메서드 execute(JobExecutionContext context)를 가진 Job 인터페이스를 제공한다. Quartz를 사용하는 개발자는 수행해야 하는 실제 작업을 이 메서드에서 구현하면 된다.</p>
<h5 id="jobdetail"> JobDetail</h5>
<p>Job을 실행시키기 위한 정보를 담고 있는 객체이다. Job의 이름, 그룹, JobDataMap 속성 등을 지정할 수 있다.
Trigger가 Job을 수행할 때 이정보를 기반으로 스케줄링을 한다.</p>
<h5 id="jobdatamap"> JobDataMap</h5>
<p>JobDataMap은 Job 인스턴스가 execute 실행할 때 사용할 수 있게 원하는 정보를 담을 수 있는 객체이다.
JobDetail을 생성할 때 JobDataMap도 같이 세팅해주면 된다.</p>
<h5 id="trigger"> Trigger</h5>
<p>Trigger는 Job을 실행시킬 스케줄링 조건(ex. 반복 횟수, 시작시간) 등을 담고 있고 Scheduler는 이 정보를 기반으로 Job을 수행시킨다.
N Trigger = 1 Job
반드시 하나의 Trigger는 반드시 하나의 Job을 지정할 수 있다.
SimpleTrigger - 특정시간에 Job을 수행할 때 사용되며 반복 횟수와 실행 간격등을 지정할 수 있다 CronTrigger - CronTrigger는 cron 표현식으로 Trigger를 정의 하는 방식이다.</p>
<br>
<hr>
<h2 id="_0303-arrow-function-expression"> 0303 - arrow function expression</h2>
<h4 id="일반-함수와-차이점"> 일반 함수와 차이점</h4>
<ul>
<li>this를 가지지 않는다.</li>
<li>arguments를 지원하지 않는다.</li>
<li>new와 함께 호출할 수 없다.</li>
<li>super를 지원하지 않는다.</li>
</ul>
<br>
<hr>
<h2 id="_0304-cookie-vs-webstorage"> 0304 - Cookie vs WebStorage</h2>
<h4 id="cookie"> Cookie</h4>
<ul>
<li>특징
<ul>
<li>웹 요청은 쿠키 정보를 포함하여 서버에 전송</li>
<li>개수와 용량에 제한</li>
<li>유효기간</li>
</ul>
</li>
<li>장점
<ul>
<li>장점 : 대부분의 브라우저 지원</li>
<li>단점 : api가 한번 더 호출 - 서버에 부담</li>
</ul>
</li>
</ul>
<h4 id="webstorage"> WebStorage</h4>
<ul>
<li>특징
<ul>
<li>저장 데이터가 클라이언트에만 존재 - 서버로 전송하지 않는다.</li>
<li>용량의 제한이 없다</li>
<li>저장한 데이터는 영구적으로 존재</li>
<li>도메인을 기준</li>
<li>HTML4만 지원되는 브라우저에는 지원이 안됨</li>
</ul>
</li>
<li>LocalStorage
<ul>
<li>브라우저를 종료해도 데이터는 보관</li>
</ul>
</li>
</ul>
<div><pre><code>localStorage<span>.</span><span>setItem</span><span>(</span><span>"key"</span><span>,</span> <span>"value"</span><span>)</span><span>;</span>
localStorage<span>.</span><span>getItem</span><span>(</span><span>"key"</span><span>)</span><span>;</span>
localStorage<span>.</span><span>removeItem</span><span>(</span><span>"key"</span><span>)</span><span>;</span>
localStorage<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>SessionStorage
<ul>
<li>세션종료시 정보 삭제(브라우저를 닫을경우)</li>
</ul>
</li>
</ul>
<div><pre><code>sessionStorage<span>.</span><span>setItem</span><span>(</span><span>"key"</span><span>,</span> <span>"value"</span><span>)</span><span>;</span>
sessionStorage<span>.</span><span>getItem</span><span>(</span><span>"key"</span><span>)</span><span>;</span>
sessionStorage<span>.</span><span>removeItem</span><span>(</span><span>"key"</span><span>)</span><span>;</span>
sessionStorage<span>.</span><span>clear</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><br>
<hr>
<h2 id="_0305-os별-포트-프로세스-확인"> 0305 - OS별 포트. 프로세스 확인</h2>
<h4 id="mac"> mac</h4>
<ul>
<li>포트 확인<br>
<code>lsof -i : {port}</code></li>
<li>프로세스 확인<br>
<code>ps -ef | grep</code></li>
<li>프로세스 종료<br>
<code>kill -9 {PID}</code></li>
</ul>
<h4 id="window"> window</h4>
<ul>
<li>포트 확인<br>
<code>netstat -ano | findstr {port}</code></li>
<li>프로세스 종료<br>
<code>taskkill /f /pid {PID}</code></li>
</ul>
<h4 id="linux"> linux</h4>
<ul>
<li>포트 확인<br>
<code>netstat -tnlp | grep {port}</code></li>
<li>프로세스 확인<br>
<code>ps -ef | grep</code></li>
<li>프로세스 종료<br>
<code>kill -9 {PID}</code></li>
</ul>
<br>
<hr>
<h2 id="_0306-enum"> 0306 - enum</h2>
<h4 id="사용목적"> 사용목적</h4>
<ol>
<li>상수를 표현하기에 코드가 단순해지며 가독성이 좋다.</li>
<li>인스턴스 생성과 상속을 방지.</li>
<li>키워드 enum을 사용하기 때문에 구현의 의도가 열거임을 분명하게 나타낼 수 있음.</li>
</ol>
<h4 id="enum-특징"> enum 특징</h4>
<ul>
<li>enum의 경우 디폴트 생성자의 접근 제어자가 private, 컴파일타임에 모든 값을 알고 있어야 하며 동적으로 값을 할당 해서 안됨.</li>
</ul>
<h4 id="메소드"> 메소드</h4>
<ul>
<li>values()	모든 상수 반환</li>
<li>ordinal()	상수 인덱스 반환</li>
<li>valueOf()	상수 문자 값 반환</li>
</ul>
<h4 id="예제"> 예제</h4>
<div><pre><code>    <span>public</span> <span>enum</span>  <span>Winner</span> <span>{</span>
    	<span>WINNER</span><span>(</span><span>"승리"</span><span>,</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"kyle"</span><span>,</span><span>"pobi"</span><span>,</span><span>"hello"</span><span>,</span><span>"world"</span><span>)</span><span>)</span><span>,</span>
    	<span>LOSER</span><span>(</span><span>"패배"</span><span>,</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>"hodol"</span><span>,</span><span>"dunddoung"</span><span>,</span><span>"rutgo"</span><span>)</span><span>;</span>
    
    	<span>private</span> <span>final</span> <span>String</span> winner<span>;</span>
    	<span>private</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list<span>;</span>
    
    	<span>Winner</span><span>(</span><span>String</span> winner<span>,</span> <span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list<span>)</span> <span>{</span>
    		<span>this</span><span>.</span>winner <span>=</span> winner<span>;</span>
    		<span>this</span><span>.</span>list <span>=</span> list<span>;</span>
    	<span>}</span>
    <span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code>    <span>public</span> <span>enum</span> <span>Statistic</span> <span>{</span>
    	<span>THREE</span><span>(</span><span>3</span><span>,</span> <span>5000</span><span>)</span><span>,</span>
    	<span>FOUR</span><span>(</span><span>4</span><span>,</span> <span>50_000</span><span>)</span><span>,</span>
    	<span>FIVE</span><span>(</span><span>5</span><span>,</span> <span>1_500_000</span><span>)</span><span>,</span>
    	<span>BONUS</span><span>(</span><span>5</span><span>,</span> <span>3_000_000</span><span>)</span><span>,</span>
    	<span>SIX</span><span>(</span><span>6</span><span>,</span> <span>2_000_000_000</span><span>)</span><span>;</span>
    
    	<span>private</span> <span>final</span> <span>int</span> matchingNumbers<span>;</span>
    	<span>private</span> <span>final</span> <span>int</span> prize<span>;</span>
    
    	<span>Statistic</span><span>(</span><span>int</span> matchingNumbers<span>,</span> <span>int</span> prize<span>)</span> <span>{</span>
    		<span>this</span><span>.</span>matchingNumbers <span>=</span> matchingNumbers<span>;</span>
    		<span>this</span><span>.</span>prize <span>=</span> prize<span>;</span>
    	<span>}</span>
    
    <span>public</span> <span>static</span> <span>Statistic</span> <span>getRank</span><span>(</span><span>int</span> numberOfMatch<span>)</span> <span>{</span>
    		<span>return</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span><span>values</span><span>(</span><span>)</span><span>)</span>
    			<span>.</span><span>filter</span><span>(</span>statistic <span>-></span> statistic<span>.</span>matchingNumbers <span>==</span> numberOfMatch<span>)</span>
    			<span>.</span><span>findFirst</span><span>(</span><span>)</span>
    			<span>.</span><span>orElseThrow</span><span>(</span><span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"일치하는 번호가 3미만입니다."</span><span>)</span><span>)</span>
    	<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code>    <span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>BiFunction</span><span>;</span>
    
    <span>public</span> <span>enum</span> <span>Operator</span> <span>{</span>
    	<span>PLUS</span><span>(</span><span>"더하기"</span><span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>(</span>a <span>+</span> b<span>)</span><span>)</span><span>,</span>
    	<span>MINUS</span><span>(</span><span>"빼기"</span><span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>(</span>a <span>-</span> b<span>)</span><span>)</span><span>,</span>
    	<span>MULTIPLY</span><span>(</span><span>"곱하기"</span><span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>(</span>a <span>*</span> b<span>)</span><span>)</span><span>,</span>
    	<span>DIVIDE</span><span>(</span><span>"나누기"</span><span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>(</span>a <span>/</span> b<span>)</span><span>)</span><span>;</span>
    
    	<span>private</span> <span>final</span> <span>String</span> name<span>;</span>
    	<span>private</span> <span>final</span> <span>BiFunction</span><span><span>&lt;</span><span>Double</span><span>,</span> <span>Double</span><span>,</span> <span>Double</span><span>></span></span> biFunction<span>;</span>
    
    	<span>Operator</span><span>(</span><span>String</span> name<span>,</span> <span>BiFunction</span><span><span>&lt;</span><span>Double</span><span>,</span> <span>Double</span><span>,</span> <span>Double</span><span>></span></span> biFunction<span>)</span> <span>{</span>
    		<span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    		<span>this</span><span>.</span>biFunction <span>=</span> biFunction<span>;</span>
    	<span>}</span>
    
    	<span>public</span> <span>Double</span> <span>calculate</span><span>(</span><span>double</span> a<span>,</span> <span>double</span> b<span>)</span> <span>{</span>
    		<span>return</span> <span>this</span><span>.</span>biFunction<span>.</span><span>apply</span><span>(</span>a<span>,</span>b<span>)</span><span>;</span>
    	<span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><a href="https://woowabros.github.io/tools/2017/07/10/java-enum-uses.html" target="_blank" rel="noopener noreferrer">고급<i>Content not supported</i></a></p>
<br>
<hr>
<h2 id="_0307-builder"> 0307 - Builder</h2>
<blockquote>
<p>객체를 생성할때 사용하는 패턴중 하나</p>
</blockquote>
<h4 id="객체-생성-패턴"> 객체 생성 패턴</h4>
<ul>
<li>점층적 생성자 패턴 &gt; 가독성 및 인자의 수만큼 생성자 숫자가 많아짐</li>
<li>자바빈 패턴 &gt; setter 메소드 사용으로 객체 일관성이 불확실</li>
<li>빌더 패턴</li>
</ul>
<h4 id="예제-2"> 예제</h4>
<div><pre><code><span>// Effective Java의 Builder Pattern</span>
<span>public</span> <span>class</span> <span>NutritionFacts</span> <span>{</span>
    <span>private</span> <span>final</span> <span>int</span> servingSize<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> servings<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> calories<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> fat<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> sodium<span>;</span>
    <span>private</span> <span>final</span> <span>int</span> carbohydrate<span>;</span>

    <span>public</span> <span>static</span> <span>class</span> <span>Builder</span> <span>{</span>
        <span>// Required parameters(필수 인자)</span>
        <span>private</span> <span>final</span> <span>int</span> servingSize<span>;</span>
        <span>private</span> <span>final</span> <span>int</span> servings<span>;</span>

        <span>// Optional parameters - initialized to default values(선택적 인자는 기본값으로 초기화)</span>
        <span>private</span> <span>int</span> calories      <span>=</span> <span>0</span><span>;</span>
        <span>private</span> <span>int</span> fat           <span>=</span> <span>0</span><span>;</span>
        <span>private</span> <span>int</span> carbohydrate  <span>=</span> <span>0</span><span>;</span>
        <span>private</span> <span>int</span> sodium        <span>=</span> <span>0</span><span>;</span>

        <span>public</span> <span>Builder</span><span>(</span><span>int</span> servingSize<span>,</span> <span>int</span> servings<span>)</span> <span>{</span>
            <span>this</span><span>.</span>servingSize <span>=</span> servingSize<span>;</span>
            <span>this</span><span>.</span>servings    <span>=</span> servings<span>;</span>
        <span>}</span>

        <span>public</span> <span>Builder</span> <span>calories</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
            calories <span>=</span> val<span>;</span>
            <span>return</span> <span>this</span><span>;</span>    <span>// 이렇게 하면 . 으로 체인을 이어갈 수 있다.</span>
        <span>}</span>
        <span>public</span> <span>Builder</span> <span>fat</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
            fat <span>=</span> val<span>;</span>
            <span>return</span> <span>this</span><span>;</span>
        <span>}</span>
        <span>public</span> <span>Builder</span> <span>carbohydrate</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
            carbohydrate <span>=</span> val<span>;</span>
            <span>return</span> <span>this</span><span>;</span>
        <span>}</span>
        <span>public</span> <span>Builder</span> <span>sodium</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
            sodium <span>=</span> val<span>;</span>
            <span>return</span> <span>this</span><span>;</span>
        <span>}</span>
        <span>public</span> <span>NutritionFacts</span> <span>build</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>new</span> <span>NutritionFacts</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>private</span> <span>NutritionFacts</span><span>(</span><span>Builder</span> builder<span>)</span> <span>{</span>
        servingSize  <span>=</span> builder<span>.</span>servingSize<span>;</span>
        servings     <span>=</span> builder<span>.</span>servings<span>;</span>
        calories     <span>=</span> builder<span>.</span>calories<span>;</span>
        fat          <span>=</span> builder<span>.</span>fat<span>;</span>
        sodium       <span>=</span> builder<span>.</span>sodium<span>;</span>
        carbohydrate <span>=</span> builder<span>.</span>carbohydrate<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><div><pre><code><span>NutritionFacts</span> facts <span>=</span> <span>NutritionFacts</span><span>.</span><span>builder</span><span>(</span><span>)</span>
    <span>.</span><span>calories</span><span>(</span><span>230</span><span>)</span>
    <span>.</span><span>fat</span><span>(</span><span>10</span><span>)</span>
    <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="lombok-사용"> lombok 사용</h4>
<ul>
<li>@Builder
<ul>
<li>클래스 위 선언보다는 사용하고자하는 생성자 위에 선언</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0217 - 0221</title>
      <link>ahnjs/TIL/2021/0217/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0217/</guid>
      <source url="ahnjs/TIL/rss.xml">0217 - 0221</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0217-0221"> 0217 - 0221</h1>
<h2 id="_0217-jpa-fetch-type"> 0217 - JPA fetch type</h2>
<blockquote>
<p>두가지 로딩기법이 존재<br>
즉시로딩, 지연로딩</p>
</blockquote>
<h3 id="즉시로딩-eager"> 즉시로딩(Eager)</h3>
<ul>
<li>조회시 연관 관계에 있는 엔티티를 모두 조회</li>
</ul>
<h3 id="지연로딩-lazy"> 지연로딩(Lazy)</h3>
<ul>
<li>연관 관계에 있는 엔티티를 가져오지않고, 프록시로 관리</li>
</ul>
<br>
<h2 id="_0218-네트워크란"> 0218 - 네트워크란?</h2>
<blockquote>
<p>무언가와 무언가가 무언가에 의해 연결되어서 무언가를 주고 받는것</p>
</blockquote>
<h4 id="컴퓨터-네트워크는-컴퓨터와-통신-매체-데이터로-이루어진다"> 컴퓨터 네트워크는 컴퓨터와 통신 매체, 데이터로 이루어진다.</h4>
<h4 id="리소르를-공유하는-것이-네트워크의-사용-목적"> 리소르를 공유하는 것이 네트워크의 사용 목적</h4>
<ul>
<li>데이터를 주고받음으로써 리소스를 공유</li>
</ul>
<br>
<h2 id="_0219-spring-scheduler-vs-spring-quartz"> 0219 - Spring Scheduler vs Spring Quartz</h2>
<blockquote>
<p>둘다 spring에서 제공하는 작업 스케줄링 라이브러리</p>
</blockquote>
<p>단순한 스케줄링 작업이 필요하다면 <code>Spring Scheduler</code><br>
스케줄링의 세밀한 제어가 필요할때는 <code>Spring Quartz</code></p>
<br>
<h2 id="_0220-spring-boot-관련"> 0220 - Spring boot 관련</h2>
<h3 id="애플리케이션-실행-방법-3가지"> 애플리케이션 실행 방법 3가지</h3>
<ol>
<li>mvn spring-boot:run</li>
</ol>
<ul>
<li>스프링 부트 메이픈 플러그인 사용</li>
<li>메이븐을 사용해서 실행</li>
<li>mvn 미설치시 mvnw 스크립트로 실행가능</li>
</ul>
<ol start="2">
<li>main 클래스 실행</li>
</ol>
<ul>
<li>가장 평범한 자바 어플리케이션 실행방법</li>
<li>ide 사용</li>
</ul>
<ol start="3">
<li>jar 패키징 &amp; java -jar</li>
</ol>
<ul>
<li>스프링 부트 플러그인을 사용해 jar파일 패키징</li>
<li>서버에 배포하는 용도로 주로 사용</li>
</ul>
<h3 id="자동-설정"> 자동 설정</h3>
<blockquote>
<p>Convention over Configuration</p>
</blockquote>
<ol>
<li>애플리케이션에서 설정한 빈 등록</li>
</ol>
<ul>
<li>@ComponentScan</li>
<li>@Component, @Service, @Controller, @Repository
<ul>
<li>@Service, @Controller, @Repository 는 컴포넌트 어노테이션의 확장</li>
</ul>
</li>
<li>@Configuration</li>
<li>@Bean</li>
</ul>
<ol start="2">
<li>자동 설정으로 제공하는 빈 등록</li>
</ol>
<ul>
<li>META-INF/spring.factories</li>
<li>EnableAutoConfiguration</li>
<li>@Configuration &amp;&amp; @ConditionalOnXxx</li>
</ul>
<h3 id="actuator"> Actuator</h3>
<blockquote>
<p>애플리케이션 관련 데이터 및 모니터링 정보 제공<br>
REST API - HETEOS 제공</p>
</blockquote>
<ul>
<li>웹(JSON)과 JMX 지원</li>
<li>여러 엔드포인트 제공</li>
<li>Spring-Boot-Starter-Actuator</li>
</ul>
<h3 id="스프링-부트-어드민"> 스프링 부트 어드민</h3>
<blockquote>
<p>스프링 부트 Actuaor 기반 UI 라이브러리</p>
</blockquote>
<ul>
<li>https://github.com/codecentric/spring-boot-admin</li>
</ul>
<br>
<h2 id="_0221-valid-vs-validated-그리고-asserttrue"> 0221 - @Valid vs @Validated 그리고 @AssertTrue</h2>
<h3 id="valid-vs-validated"> @Valid vs @Validated</h3>
<ul>
<li>Valid
<ul>
<li>Java에서 제공</li>
<li>그룹 검증 기능이 없다.</li>
</ul>
</li>
<li>Validated
<ul>
<li>Spring에서 제공</li>
<li>그룹 검증 기능이 있다.</li>
</ul>
</li>
</ul>
<h3 id="asserttrue"> @AssertTrue</h3>
<ul>
<li>원하는 validation을 반환 가능</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0308 - 0314</title>
      <link>ahnjs/TIL/2021/0308/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0308/</guid>
      <source url="ahnjs/TIL/rss.xml">0308 - 0314</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0308-0314"> 0308 - 0314</h1>
<h2 id="_0308-pull-request"> 0308 - pull request</h2>
<ol>
<li>Fork</li>
<li>clone, remote</li>
<li>branch</li>
<li>add, commit, push</li>
<li>pull request</li>
<li>merge pull request</li>
</ol>
<br>
<hr>
<h2 id="_0309-markdown-활용-readme-md-git-profile"> 0309 - markdown 활용 - readme.md / git profile</h2>
<h4 id="마크다운-웹에디터"> 마크다운 웹에디터</h4>
<ul>
<li>https://dillinger.io/</li>
</ul>
<h4 id="hits"> HITS</h4>
<ul>
<li>https://hits.seeyoufarm.com/</li>
</ul>
<h4 id="badge"> Badge</h4>
<ul>
<li>https://shields.io/</li>
<li>https://simpleicons.org/</li>
</ul>
<h4 id="table-generator"> Table Generator</h4>
<ul>
<li>https://www.tablesgenerator.com/markdown_tables</li>
</ul>
<h4 id="git-hub-stats"> Git-Hub Stats</h4>
<ul>
<li>https://github.com/anuraghazra/github-readme-stats</li>
</ul>
<h4 id="emoji"> Emoji</h4>
<ul>
<li>https://www.webfx.com/tools/emoji-cheat-sheet/</li>
</ul>
<br>
<hr>
<h2 id="_0310-mockmvc"> 0310 - mockMvc</h2>
<blockquote>
<p>실제 객체와 비슷하지만 테스트에 필요한 기능만 가지는 가짜 객체를 만들어서 어플리케이션 서버에 배포하지 않고도 스프링 MVC 동작을 재현할 수 있는 클래스를 의미합니다.</p>
</blockquote>
<ol>
<li>Controller에 대한 Test클래스 생성</li>
<li>테스트 메소드 실행전 셋업 메소드</li>
</ol>
<div><pre><code>	<span>private</span> <span>MockMvc</span> mockMvc<span>;</span>

    <span>@Autowired</span>
    <span>private</span> <span>WebApplicationContext</span> ctx<span>;</span>

	<span>@BeforeEach</span>
	<span>public</span> <span>void</span> <span>setup</span><span>(</span><span>)</span><span>{</span>
		<span>this</span><span>.</span>mockMvc <span>=</span> <span>MockMvcBuilders</span><span>.</span><span>webAppContextSetup</span><span>(</span>ctx<span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
    <span>// 필터 추가 또는 alwayDo 옵션 추가</span>
    <span>// this.mockMvc = MockMvcBuilders.webAppContextSetup(ctx)</span>
    <span>//             .addFilters(new CharacterEncodingFilter("UTF-8", true))</span>
    <span>//             .alwaysDo(print())</span>
    <span>//             .build();</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ol start="3">
<li>MockMvc 메소드 확인
<ul>
<li>.perform()
<ul>
<li>get(),post()</li>
<li>header</li>
<li>param()</li>
<li>accept()</li>
<li>contentType()</li>
</ul>
</li>
<li>ResultActions
<ul>
<li>andExpert : 예상값 검증</li>
<li>andDo : 요청에 대한 처리</li>
<li>andReturn : 테스트한 결과 객체를 받을 때</li>
</ul>
</li>
</ul>
</li>
</ol>
<div><pre><code><span>@Test</span>
    <span>public</span> <span>void</span> <span>getStudyTest</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        mockMvc<span>.</span><span>perform</span><span>(</span><span>get</span><span>(</span>BASE_URL<span>+</span><span>"/{seq}"</span><span>,</span> <span>1L</span><span>)</span>
                <span>.</span><span>header</span><span>(</span><span>"Authorization"</span><span>,</span> <span>"Bearer "</span> <span>+</span> loginedToken<span>)</span>
                <span>.</span><span>accept</span><span>(</span><span>MediaTypes</span><span>.</span>HAL_JSON_VALUE<span>)</span>
                <span>.</span><span>contentType</span><span>(</span><span>MediaTypes</span><span>.</span>HAL_JSON_VALUE<span>)</span><span>)</span>
                <span>.</span><span>andDo</span><span>(</span><span>print</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>andExpect</span><span>(</span><span>status</span><span>(</span><span>)</span><span>.</span><span>isOk</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>andDo</span><span>(</span><span>)</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><br>
<hr>
<h2 id="_0311-spring-rest-docs"> 0311 - Spring REST Docs</h2>
<blockquote>
<p>API문서 작성 자동화 도구<br>
대표적으로 Swagger, Spring Rest Docs</p>
</blockquote>
<h4 id="asciidocor"> Asciidocor</h4>
<blockquote>
<p>Adoc 파일을 활용하여 html 문서를 만들어주는 도구</p>
</blockquote>
<ul>
<li>의존성 및 플러그인 추가</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>plugin</span><span>></span></span>
                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.asciidoctor<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                <span><span><span>&lt;</span>artifactId</span><span>></span></span>asciidoctor-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                <span><span><span>&lt;</span>version</span><span>></span></span>1.5.8<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span><span><span>&lt;</span>executions</span><span>></span></span>
                    <span><span><span>&lt;</span>execution</span><span>></span></span>
                        <span><span><span>&lt;</span>id</span><span>></span></span>generate-docs<span><span><span>&lt;/</span>id</span><span>></span></span>
                        <span><span><span>&lt;</span>phase</span><span>></span></span>prepare-package<span><span><span>&lt;/</span>phase</span><span>></span></span>
                        <span><span><span>&lt;</span>goals</span><span>></span></span>
                            <span><span><span>&lt;</span>goal</span><span>></span></span>process-asciidoc<span><span><span>&lt;/</span>goal</span><span>></span></span>
                        <span><span><span>&lt;/</span>goals</span><span>></span></span>
                        <span><span><span>&lt;</span>configuration</span><span>></span></span>
                            <span><span><span>&lt;</span>backend</span><span>></span></span>html<span><span><span>&lt;/</span>backend</span><span>></span></span>
                            <span><span><span>&lt;</span>doctype</span><span>></span></span>book<span><span><span>&lt;/</span>doctype</span><span>></span></span>
                        <span><span><span>&lt;/</span>configuration</span><span>></span></span>
                    <span><span><span>&lt;/</span>execution</span><span>></span></span>
                <span><span><span>&lt;/</span>executions</span><span>></span></span>
                <span><span><span>&lt;</span>dependencies</span><span>></span></span>
                    <span><span><span>&lt;</span>dependency</span><span>></span></span>
                        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.restdocs<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-restdocs-asciidoctor<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                        <span><span><span>&lt;</span>version</span><span>></span></span>${spring-restdocs.version}<span><span><span>&lt;/</span>version</span><span>></span></span>
                    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
                <span><span><span>&lt;/</span>dependencies</span><span>></span></span>
            <span><span><span>&lt;/</span>plugin</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h4 id="예제"> 예제</h4>
<ul>
<li>테스트 코드</li>
</ul>
<div><pre><code><span>@WebMvcTest</span><span>(</span><span>PostController</span><span>.</span><span>class</span><span>)</span>
<span>class</span> <span>PostControllerTest</span> <span>{</span>

    <span>@Autowired</span>
    <span>private</span> <span>MockMvc</span> mvc<span>;</span>

    <span>@MockBean</span>
    <span>private</span> <span>PostService</span> postService<span>;</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>create</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>final</span> <span>PostResponse</span> post <span>=</span> <span>PostResponse</span><span>.</span><span>builder</span><span>(</span><span>)</span>
                <span>.</span><span>id</span><span>(</span><span>1L</span><span>)</span>
                <span>.</span><span>title</span><span>(</span><span>"first_post"</span><span>)</span>
                <span>.</span><span>content</span><span>(</span><span>"hello_my_world"</span><span>)</span>
                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
        <span>given</span><span>(</span>postService<span>.</span><span>createPost</span><span>(</span><span>any</span><span>(</span><span>)</span><span>)</span><span>)</span><span>.</span><span>willReturn</span><span>(</span>post<span>)</span><span>;</span>

        mvc<span>.</span><span>perform</span><span>(</span><span>post</span><span>(</span><span>"/posts"</span><span>)</span>
                <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
                <span>.</span><span>contentType</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
                <span>.</span><span>content</span><span>(</span><span>"{\"title\":\"first_post\",\"content\":\"hello_my_world\"}"</span><span>)</span><span>)</span>
                <span>.</span><span>andExpect</span><span>(</span><span>status</span><span>(</span><span>)</span><span>.</span><span>isCreated</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>andExpect</span><span>(</span><span>header</span><span>(</span><span>)</span><span>.</span><span>stringValues</span><span>(</span><span>"location"</span><span>,</span> <span>"/posts/"</span> <span>+</span> <span>1L</span><span>)</span><span>)</span>
                <span>.</span><span>andDo</span><span>(</span><span>print</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><ul>
<li>Documentation 작업
<ul>
<li>테스트 모듈안에 별도의 패키지 생성하고 Documentation을 작( 테스트 코드에 이어 작성해도 되지만, 따로 작성하여 관리)</li>
</ul>
</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>PostDocumentation</span> <span>{</span>
    <span>public</span> <span>static</span> <span>RestDocumentationResultHandler</span> <span>createPost</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>document</span><span>(</span><span>"posts/create"</span><span>,</span>
                <span>requestFields</span><span>(</span>
                        <span>fieldWithPath</span><span>(</span><span>"title"</span><span>)</span><span>.</span><span>type</span><span>(</span><span>JsonFieldType</span><span>.</span>STRING<span>)</span><span>.</span><span>description</span><span>(</span><span>"This is post title."</span><span>)</span><span>,</span>
                        <span>fieldWithPath</span><span>(</span><span>"content"</span><span>)</span><span>.</span><span>type</span><span>(</span><span>JsonFieldType</span><span>.</span>STRING<span>)</span><span>.</span><span>description</span><span>(</span><span>"This is post content"</span><span>)</span>
                <span>)</span>
        <span>)</span><span>;</span>
    <span>}</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>mockMvc에 Documentation 사용 필터 추가</li>
</ul>
<div><pre><code>    <span>@BeforeEach</span>
    <span>public</span> <span>void</span> <span>setUp</span><span>(</span><span>WebApplicationContext</span> webApplicationContext<span>,</span> <span>RestDocumentationContextProvider</span> restDocumentation<span>)</span> <span>{</span>
        mvc <span>=</span> <span>MockMvcBuilders</span><span>.</span><span>webAppContextSetup</span><span>(</span>webApplicationContext<span>)</span>
                <span>.</span><span>addFilter</span><span>(</span><span>new</span> <span>ShallowEtagHeaderFilter</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>apply</span><span>(</span><span>documentationConfiguration</span><span>(</span>restDocumentation<span>)</span><span>)</span>
                <span>.</span><span>build</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 각 테스트 마지막에 다음과 같이 .andDo(PostDocumentation.xx)를 호출해준다.</span>
    <span>@Test</span>
    <span>public</span> <span>void</span> <span>create</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>.</span><span>.</span><span>.</span>
        mvc<span>.</span><span>perform</span><span>(</span><span>post</span><span>(</span><span>"/posts"</span><span>)</span>
                <span>.</span><span>accept</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
                <span>.</span><span>contentType</span><span>(</span><span>MediaType</span><span>.</span>APPLICATION_JSON<span>)</span>
                <span>.</span><span>content</span><span>(</span><span>"{\"title\":\"first_post\",\"content\":\"hello_my_world\"}"</span><span>)</span><span>)</span>
                <span>.</span><span>andExpect</span><span>(</span><span>status</span><span>(</span><span>)</span><span>.</span><span>isCreated</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>andExpect</span><span>(</span><span>header</span><span>(</span><span>)</span><span>.</span><span>stringValues</span><span>(</span><span>"location"</span><span>,</span> <span>"/posts/"</span> <span>+</span> <span>1L</span><span>)</span><span>)</span>
                <span>.</span><span>andDo</span><span>(</span><span>print</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>andDo</span><span>(</span><span>PostDocumentation</span><span>.</span><span>createPost</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 추가</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ul>
<li>문서 스펙 정의를 api-guide.adoc 파일을 추가
<ul>
<li>src 폴더 아래에 <code>documentation</code>&gt;<code>asccidoc</code>&gt;<code>api-guide.adoc</code> 파일 추가</li>
<li>api-guide.adoc 양식</li>
</ul>
</li>
</ul>
<div><pre><code>  ifndef::snippets[]
:snippets: ../../../build/generated-snippets
endif::[]
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 2
:sectlinks:
:operation-http-request-title: Example Request
:operation-http-response-title: Example Response

[[resources]]
= Resources

[[resources-posts]]
== Post

[[resources-posts-create]]
=== 포스트 추가
operation::posts/create[snippets=&#39;http-request,http-response,request-fields,request-body&#39;]

[[resources-posts-getAll]]
=== 포스트 전체 조회
operation::posts/getAll[snippets=&#39;http-request,http-response,response-body&#39;]

[[resources-posts-get]]
=== 포스트 조회
operation::posts/get[snippets=&#39;http-request,http-response,response-body&#39;]

[[resources-posts-update]]
=== 포스트 수정
operation::posts/update[snippets=&#39;http-request,http-response,request-fields,request-body&#39;]

[[resources-posts-delete]]
=== 포스트 삭제
operation::posts/delete[snippets=&#39;http-request,http-response&#39;]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><ul>
<li>build test</li>
</ul>
<br>
<h2 id="_0312-spring-hateoas"> 0312 - Spring HATEOAS</h2>
<blockquote>
<p>Hypermedia As The Engine Of Application State<br>
RESTful API를 사용하는 클라이언트가 전적으로 서버와 동적인 상호작용이 가능하도록 하는 것<br>
클라이언트가 서버로부터 어떠한 요청을 할 때, 요청에 필요한(의존되는) URI를 응답에 포함시켜 반환</p>
</blockquote>
<h4 id="content-type"> Content Type</h4>
<ul>
<li>ContentType을 application/hal+json으로 전달하면 클라이언트에서는 _links 필드에 링크 정보가 있다고 예상할 수 있다.</li>
</ul>
<h4 id="예제-2"> 예제</h4>
<div><pre><code><span>@PostMapping</span><span>(</span><span>"/employees"</span><span>)</span>
<span>ResponseEntity</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>newEmployee</span><span>(</span><span>@RequestBody</span> <span>Employee</span> newEmployee<span>)</span> <span>{</span>

  <span>EntityModel</span><span><span>&lt;</span><span>Employee</span><span>></span></span> entityModel <span>=</span> assembler<span>.</span><span>toModel</span><span>(</span>repository<span>.</span><span>save</span><span>(</span>newEmployee<span>)</span><span>)</span><span>;</span>

  <span>return</span> <span>ResponseEntity</span> <span>//</span>
      <span>.</span><span>created</span><span>(</span>entityModel<span>.</span><span>getRequiredLink</span><span>(</span><span>IanaLinkRelations</span><span>.</span>SELF<span>)</span><span>.</span><span>toUri</span><span>(</span><span>)</span><span>)</span> <span>//</span>
      <span>.</span><span>body</span><span>(</span>entityModel<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>https://spring.io/guides/tutorials/rest/</p>
<br>
<h2 id="_0313-reverse-proxy"> 0313 - Reverse Proxy</h2>
<blockquote>
<p>컴퓨터 네트워크에서 리버스 프록시란 하나 이상의 서버로 부터 클라이언트를 대신해서 리소스를 검색하는 프록시 서버, 서버가 클라이언트에게 접촉하는것을 중개</p>
</blockquote>
<ol>
<li>Load Balancing</li>
<li>Web acceleration</li>
<li>Security and anonymity</li>
</ol>
<br>
<h2 id="_0314-api-명세서-자동-생성"> 0314 - API 명세서 자동 생성</h2>
<blockquote>
<p>Spring Rest Docs</p>
</blockquote>
<ol>
<li>테스트 케이스 작성</li>
<li>테스트 실행</li>
<li>생성된 snippets 문서 확인</li>
</ol>
<div><pre><code>curl-request.adoc : 호출에 대한 curl 명령을 포함 하는 문서
httpie-request.adoc : 호출에 대한 http 명령을 포함 하는 문서
http-request.adoc : http 요청 정보 문서
http-response.adoc : http 응답 정보 문서
request-body.adoc : 전송된 http 요청 본문 문서
response-body.adoc : 반환된 http 응답 본문 문서
request-parameters.adoc : 호출에 parameter 에 대한 문서
path-parameters.adoc : http 요청시 url 에 포함되는 path parameter 에 대한 문서
request-fields.adoc : http 요청 object 에 대한 문서
response-fields.adoc : http 응답 object 에 대한 문서
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ol start="4">
<li>API 명세서 작성</li>
</ol>
<ul>
<li>스니펫 문서 경로 지정</li>
</ul>
<div><pre><code><span><span>ifndef</span><span>::</span>snippets<span><span>[</span><span>]</span></span></span>
<span>:snippets: ../../../target/generated-snippets</span>
<span><span>endif</span><span>::</span><span><span>[</span><span>]</span></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>원하는 스니펫 추가</li>
</ul>
<div><pre><code><span><span>include</span><span>::</span>{snippets}/user-controller-test/get-list/curl-request.adoc<span><span>[</span><span>]</span></span></span>
</code></pre>
<div><span>1</span><br></div></div><ol start="5">
<li>maven install</li>
</ol>
<ul>
<li>html로 반환 / api 명세서 복사 설정</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>project</span> <span>xmlns</span><span><span>=</span><span>"</span>http://maven.apache.org/POM/4.0.0<span>"</span></span> <span><span>xmlns:</span>xsi</span><span><span>=</span><span>"</span>http://www.w3.org/2001/XMLSchema-instance<span>"</span></span>
         <span><span>xsi:</span>schemaLocation</span><span><span>=</span><span>"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span>"</span></span><span>></span></span>
    ...
    <span><span><span>&lt;</span>build</span><span>></span></span>
        <span><span><span>&lt;</span>plugins</span><span>></span></span>
            ...
            <span>&lt;!-- 1. API 명세서를 html로 변환 --></span>
            <span><span><span>&lt;</span>plugin</span><span>></span></span>
                <span><span><span>&lt;</span>groupId</span><span>></span></span>org.asciidoctor<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                <span><span><span>&lt;</span>artifactId</span><span>></span></span>asciidoctor-maven-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                <span><span><span>&lt;</span>version</span><span>></span></span>1.5.3<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span><span><span>&lt;</span>executions</span><span>></span></span>
                    <span><span><span>&lt;</span>execution</span><span>></span></span>
                        <span><span><span>&lt;</span>id</span><span>></span></span>generate-docs<span><span><span>&lt;/</span>id</span><span>></span></span>
                        <span><span><span>&lt;</span>phase</span><span>></span></span>prepare-package<span><span><span>&lt;/</span>phase</span><span>></span></span>
                        <span><span><span>&lt;</span>goals</span><span>></span></span>
                            <span><span><span>&lt;</span>goal</span><span>></span></span>process-asciidoc<span><span><span>&lt;/</span>goal</span><span>></span></span>
                        <span><span><span>&lt;/</span>goals</span><span>></span></span>
                        <span><span><span>&lt;</span>configuration</span><span>></span></span>
                            <span><span><span>&lt;</span>backend</span><span>></span></span>html<span><span><span>&lt;/</span>backend</span><span>></span></span>
                            <span><span><span>&lt;</span>doctype</span><span>></span></span>book<span><span><span>&lt;/</span>doctype</span><span>></span></span>
                        <span><span><span>&lt;/</span>configuration</span><span>></span></span>
                    <span><span><span>&lt;/</span>execution</span><span>></span></span>
                <span><span><span>&lt;/</span>executions</span><span>></span></span>
                <span><span><span>&lt;</span>dependencies</span><span>></span></span>
                    <span><span><span>&lt;</span>dependency</span><span>></span></span>
                        <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.restdocs<span><span><span>&lt;/</span>groupId</span><span>></span></span>
                        <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-restdocs-asciidoctor<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                        <span><span><span>&lt;</span>version</span><span>></span></span>2.0.2.RELEASE<span><span><span>&lt;/</span>version</span><span>></span></span>
                    <span><span><span>&lt;/</span>dependency</span><span>></span></span>
                <span><span><span>&lt;/</span>dependencies</span><span>></span></span>
            <span><span><span>&lt;/</span>plugin</span><span>></span></span>

            <span>&lt;!-- 2. html 로 변환된 API 명세서를 static 영역으로 복사 --></span>
            <span><span><span>&lt;</span>plugin</span><span>></span></span>
                <span><span><span>&lt;</span>artifactId</span><span>></span></span>maven-resources-plugin<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
                <span><span><span>&lt;</span>version</span><span>></span></span>3.0.1<span><span><span>&lt;/</span>version</span><span>></span></span>
                <span><span><span>&lt;</span>executions</span><span>></span></span>
                    <span><span><span>&lt;</span>execution</span><span>></span></span>
                        <span><span><span>&lt;</span>id</span><span>></span></span>copy-resources<span><span><span>&lt;/</span>id</span><span>></span></span>
                        <span><span><span>&lt;</span>phase</span><span>></span></span>prepare-package<span><span><span>&lt;/</span>phase</span><span>></span></span>
                        <span><span><span>&lt;</span>goals</span><span>></span></span>
                            <span><span><span>&lt;</span>goal</span><span>></span></span>copy-resources<span><span><span>&lt;/</span>goal</span><span>></span></span>
                        <span><span><span>&lt;/</span>goals</span><span>></span></span>
                        <span><span><span>&lt;</span>configuration</span><span>></span></span>
                            <span><span><span>&lt;</span>outputDirectory</span><span>></span></span>
                                ${project.build.outputDirectory}/static/docs
                            <span><span><span>&lt;/</span>outputDirectory</span><span>></span></span>
                            <span><span><span>&lt;</span>resources</span><span>></span></span>
                                <span><span><span>&lt;</span>resource</span><span>></span></span>
                                    <span><span><span>&lt;</span>directory</span><span>></span></span>
                                        ${project.build.directory}/generated-docs
                                    <span><span><span>&lt;/</span>directory</span><span>></span></span>
                                <span><span><span>&lt;/</span>resource</span><span>></span></span>
                            <span><span><span>&lt;/</span>resources</span><span>></span></span>
                        <span><span><span>&lt;/</span>configuration</span><span>></span></span>
                    <span><span><span>&lt;/</span>execution</span><span>></span></span>
                <span><span><span>&lt;/</span>executions</span><span>></span></span>
            <span><span><span>&lt;/</span>plugin</span><span>></span></span>
            ...
        <span><span><span>&lt;/</span>plugins</span><span>></span></span>
    <span><span><span>&lt;/</span>build</span><span>></span></span>
    ...
<span><span><span>&lt;/</span>project</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br></div></div><ol start="6">
<li>html 문서 확인</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>0315 - 0321</title>
      <link>ahnjs/TIL/2021/0315/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0315/</guid>
      <source url="ahnjs/TIL/rss.xml">0315 - 0321</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0315-0321"> 0315 - 0321</h1>
<h2 id="_0315-java-stream"> 0315 - Java Stream</h2>
<blockquote>
<p>자바 컬렉션이나 배열의 원소를 간결하고 깔끔하게 가공하기 위해 사용.</p>
</blockquote>
<h4 id="선언"> 선언</h4>
<blockquote>
<p>배열, 컬렉션(list, set, map) 등을 스트림 형태로 만들기</p>
</blockquote>
<div><pre><code><span>Stream</span><span><span>&lt;</span>dataType<span>></span></span> streamName <span>=</span> <span>Arrays</span><span>.</span><span>stream</span><span>(</span>arrName<span>)</span><span>;</span>
<span>Stream</span><span><span>&lt;</span>dataType<span>></span></span> streamName <span>=</span> arrName<span>.</span><span>stream</span><span>(</span><span>)</span><span>;</span>
<span>Stream</span><span><span>&lt;</span>dataType<span>></span></span> streamName <span>=</span> <span>Stream</span><span>.</span><span>of</span><span>(</span><span>'data'</span><span>,</span> <span>'data'</span> <span>.</span><span>.</span><span>.</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h4 id="가공"> 가공</h4>
<blockquote>
<p>스트림을 필요한 형태로 가공하기</p>
</blockquote>
<ul>
<li>.boxed()</li>
<li>.count()</li>
<li>.sorted() *(Comparator.reverseOrder())</li>
<li>.findFirst()</li>
<li>.skip(arrLength - 1).findFirst()</li>
<li>.skip(idx)</li>
<li>.limit(idx)</li>
<li>.distinct()</li>
<li>.max(dataType::compare)</li>
<li>.min(dataType::compare)</li>
<li>.average()</li>
<li>.sum()</li>
<li>.map((param) -&gt; {code})</li>
<li>.forEach((param) -&gt; {code})</li>
<li>.anyMatch((param) -&gt; {code})</li>
<li>.noneMatch((param) -&gt; {code})</li>
<li>.allMatch((param) -&gt; {code})</li>
<li>.filter((param) -&gt; {code})</li>
<li>.reduce(값, 데이터타입::sum)</li>
</ul>
<h4 id="반환"> 반환</h4>
<blockquote>
<p>가공한 값을 원하는 형태로 가져오기</p>
</blockquote>
<ul>
<li>.toArray();</li>
<li>.collect(Collectors.toList());</li>
<li>.collect(Collectors.counting());</li>
<li>.collect(Collectors.joining(&quot;|&quot;));</li>
</ul>
<br>
<h2 id="_0316-java-startswith-endswith"> 0316 - Java startsWith(), endsWith()</h2>
<h4 id="startswith-string-prefix"> startsWith(String prefix)</h4>
<ul>
<li>str.startsWith(&quot;checkStr&quot;);</li>
</ul>
<h4 id="endswith-string-suffix"> endsWith(String suffix);</h4>
<ul>
<li>str.endsWith(&quot;checkStr&quot;);</li>
</ul>
<br>
<h2 id="_0317-cors"> 0317 - CORS</h2>
<blockquote>
<p>교차 출처 리소스 공유(Cross-Origin Resource Sharing)</p>
</blockquote>
<h4 id="simple-request"> Simple Request</h4>
<p>-&gt; 응답 헤더에 <code>Access-Control-Allow-Rogin</code>값만 세팅 해주면 된다</p>
<h4 id="preflight-request"> Preflight Request</h4>
<blockquote>
<p>OPTIONS 방식으로 먼저 요청을 날리고, 그 이후에 실제 요청을 함.</p>
</blockquote>
<ul>
<li>응답 헤더에 <code>Access-Control-Allow-Methods</code>에 <code>OPTIONS</code> 값 설정</li>
<li>응답 헤더에 <code>Access-Control-Allow-Headers</code>에 <code>content-type</code> 값 설정</li>
<li>추가 적으로 CORS의 성능 효율을 위해서 <code>Access-Control-Max-Age</code> 값을 설정 할 수 있다</li>
</ul>
<h4 id="sptring-boot-java-config"> Sptring boot Java Config</h4>
<ul>
<li>WebMvcConfigurer를 통해 적용 방식</li>
</ul>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>MvcConfig</span> <span>implements</span> <span>WebMvcConfigurer</span> <span>{</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>addCorsMappings</span><span>(</span><span>CorsRegistry</span> registry<span>)</span> <span>{</span>
        registry<span>.</span><span>addMapping</span><span>(</span><span>"/**"</span><span>)</span>
                <span>.</span><span>allowedOrigins</span><span>(</span><span>"*"</span><span>)</span>
                <span>.</span><span>allowedMethods</span><span>(</span><span>"*"</span><span>)</span>
                <span>.</span><span>maxAge</span><span>(</span><span>3600L</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>@CrossOrigin 어노테이션을 통해 적용하는 방식</li>
</ul>
<div><pre><code><span>@SpringBootApplication</span>
<span>//해당 컨트롤러의 모든 요청에 대한 접근 허용(아래 도메인 두개에 대해서만..)</span>
<span>@CrossOrigin</span><span>(</span>origins <span>=</span> <span>{</span><span>"http://localhost:18080"</span><span>,</span> <span>"http://localhost:8180"</span> <span>}</span><span>)</span> 
<span>@RestController</span>
<span>public</span> <span>class</span> <span>CorssampleApplication</span> <span>{</span>
 
	<span>//아래와 같이 특정 메소드에만 적용할수도 있다.</span>
    <span>//@CrossOrigin(origins = {"http://localhost:18080", "http://localhost:8180" })</span>
    <span>@GetMapping</span><span>(</span><span>"/hello"</span><span>)</span>
    <span>public</span> <span>String</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"hello"</span><span>;</span>
    <span>}</span>
	
	<span>@GetMapping</span><span>(</span><span>"/my"</span><span>)</span>
    <span>public</span> <span>String</span> <span>my</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>"my"</span><span>;</span>
    <span>}</span>
	
 
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SpringApplication</span><span>.</span><span>run</span><span>(</span><span>CorssampleApplication</span><span>.</span><span>class</span><span>,</span> args<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><br>
<h2 id="_0318-filter와-interceptor의-차이"> 0318 - Filter와 Interceptor의 차이</h2>
<blockquote>
<p>Filter와 Interceptor는 실행되는 시점이 다르다.<br>
Filter는 Web Application에 등록을 하고, Interceptor는 Spring의 Context에 등록을 한다.</p>
</blockquote>
<h4 id="interface"> Interface</h4>
<ul>
<li>Filter</li>
</ul>
<div><pre><code><span>public</span> <span>interface</span> <span>Filter</span> <span>{</span>
  <span>void</span> <span>doFilter</span><span>(</span><span>ServletRequest</span> request<span>,</span> <span>ServletResponse</span> response<span>,</span> <span>FilterChain</span> chain<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>HandlerInterceptor</li>
</ul>
<div><pre><code><span>public</span> <span>interface</span> <span>HandlerInterceptor</span> <span>{</span>
  <span>boolean</span> <span>preHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>)</span><span>;</span>
  <span>void</span> <span>postHandle</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServletResponse</span> response<span>,</span> <span>Object</span> handler<span>,</span> <span>ModelAndView</span> mav<span>)</span><span>;</span>
  <span>void</span> <span>afterCompletion</span><span>(</span><span>HttpServletRequest</span> request<span>,</span> <span>HttpServeletResponse</span> response<span>,</span> <span>Object</span> handler<span>,</span> <span>Exception</span> ex<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>Filter는 Servlert에서 처리하기 전후를 다룰 수 있다.<br>
Interceptor는 Handler를 실행하기전, 실행한 후, view를 렌더링한 후 등, Servlert내에서도 메서드에 따라 실행 시점을 다르게 가져간다.</p>
</blockquote>
<ul>
<li>Interceptor에서만 할 수 있는것
<ul>
<li>AOP 흉내를 낼 수 있다. <code>@RequestMapping</code> 선언으로 요청에 대한 <code>HandlerMethod(@Controller의 메서드)</code>가 정해졌다면, handler라는 이름으로 <code>HandlerMethod</code>가 들어온다
<code>HandlerMethod</code>로 메서드 시그니처 등 추가적인 정보를 파악해서 로직 실행 여부를 판단할 수 있다</li>
<li>View를 렌더링하기 전에 추가 작업을 할 수 있다</li>
</ul>
</li>
<li>Filter에서만 할 수 있는 것
<code>ServletRequest</code> 혹은 <code>ServletResponse</code>를 교체할 수 있다. 아래와 같은 일이 가능하다</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> <span>SomeFilter</span> <span>implements</span> <span>Filter</span> <span>{</span>
  <span>//...</span>
  
  <span>public</span> <span>void</span> <span>doFilter</span><span>(</span><span>ServletRequest</span> request<span>,</span> <span>ServletResponse</span> response<span>,</span> <span>FilterChain</span> chain<span>)</span> <span>{</span>
    chain<span>.</span><span>doFilter</span><span>(</span><span>new</span> <span>CustomServletRequest</span><span>(</span><span>)</span><span>,</span> <span>new</span> <span>CustomResponse</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>-&gt; 커스터마이징 된 ServletRequest를 사용할 때</p>
<br>
<h2 id="_0319-git-merge와-rebase-차이점"> 0319 - Git Merge와 Rebase 차이점</h2>
<blockquote>
<p>Merger는 branch를 통합하는 것이고, Rebase는 branch의 base를 옮긴다는 개념의 차이</p>
</blockquote>
<img src = "https://blog.kakaocdn.net/dn/cofZo0/btqBkOJybm6/RshCv0OqsydpuNCRPcIxu1/img.png" width="300px">
<h4 id="rebase"> Rebase</h4>
<ul>
<li>해당 branch의 base를 재설정하고 커밋을 새롭게 정렬</li>
<li>commit tree가 달라진다 즉 git history를 정리 할 수 있다</li>
</ul>
<br>
<h2 id="_0321-call-by-value와-call-by-reference"> 0321 - Call by value와 Call by reference</h2>
<h4 id="call-by-value"> call by value</h4>
<blockquote>
<p>값에 의한 호출</p>
</blockquote>
<p>함수가 호출될때, 메모리 공간 안에서는 함수를 위한 별도의 임시공간이 생성됨(종료 시 삭제)<br>
call by value 호출 방식은 함수 호출 시 전달되는 변수 값을 복사해서 함수 인자로 전달함<br>
이때 복사된 인자는 함수 안에서 지역적으로 사용되기 때문에 local value 속성을 가짐<br>
<code>따라서, 함수 안에서 인자 값이 변경되더라도, 외부 변수 값은 변경 안됨</code></p>
<h4 id="call-by-reference"> call by reference</h4>
<blockquote>
<p>참조에 의한 호출</p>
</blockquote>
<p>call by reference 호출 방식은 함수 호출 시 인자로 전달되는 변수의 레퍼런스를 전달함<br>
따라서 함수 안에서 인자 값이 변경되면, 아규먼트로 전달된 객체의 값도 변경됨</p>
<h3 id="java-call-by-reference"> Java call by reference</h3>
<p>사실 자바는 Call by value이냐, Call by reference이냐 로 의견이 분분
더 알아봐야겠다</p>
]]></content:encoded>
    </item>
    <item>
      <title>0222 - 0229</title>
      <link>ahnjs/TIL/2021/0222/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0222/</guid>
      <source url="ahnjs/TIL/rss.xml">0222 - 0229</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0222-0229"> 0222 - 0229</h1>
<h2 id="_0222-data-속성"> 0222 - DATA 속성</h2>
<h4 id="html-태그-내에서-data를-다룸"> html 태그 내에서 data를 다룸</h4>
<ul>
<li>data-{name} 로시작</li>
<li>하이픈으로 구분, 접근시 대시들은 camelCase로 변환</li>
</ul>
<ol>
<li>자바스크립트에서 접근
<ul>
<li>document.getElementById('selector').dataset.{name}</li>
<li>쓰는 경우는 = 로 값 대입</li>
</ul>
</li>
<li>제이쿼리에서 접근
<ul>
<li>$('selector').data(key, value);</li>
<li>$('selector').data(key);</li>
<li>$('selector').removeData('key');</li>
</ul>
</li>
<li>css에서 접근
<ul>
<li>
<p>'selector'[data-{name=값}] {</p>
<p>}</p>
</li>
</ul>
</li>
</ol>
<br>
<hr>
<h2 id="_0223-html-이메일-템플릿-만들기"> 0223 - HTML 이메일 템플릿 만들기</h2>
<p>1. 기본 html틀 생성</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span> <span>PUBLIC</span> <span>"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span>"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>xmlns</span><span><span>=</span><span>"</span>http://www.w3.org/1999/xhtml<span>"</span></span><span>></span></span>
 <span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>Content-Type<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>text/html; charset=UTF-8<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>title</span><span>></span></span>Demystifying Email Design<span><span><span>&lt;/</span>title</span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>/></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>2. 대부분의 메일에서 body와 div를 지원 하지 않기 떄문에 table태그를 생성</p>
<div><pre><code><span><span><span>&lt;</span>body</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>margin</span><span>:</span> 0<span>;</span> <span>padding</span><span>:</span> 0<span>;</span></span><span>"</span></span></span><span>></span></span>
 <span><span><span>&lt;</span>table</span> <span>border</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>cellpadding</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>cellspacing</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
   <span><span><span>&lt;</span>td</span><span>></span></span>
    Hello!
   <span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
 <span><span><span>&lt;/</span>table</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>3. html 태그에서 지원하는 속성을 우선 적으로 사용</p>
<div><pre><code><span><span><span>&lt;</span>table</span> <span>align</span><span><span>=</span><span>"</span>center<span>"</span></span> <span>border</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>cellpadding</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>cellspacing</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>600<span>"</span></span><span>></span></span>
 <span><span><span>&lt;</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>td</span> <span>bgcolor</span><span><span>=</span><span>"</span>#70bbd9<span>"</span></span><span>></span></span>
   Row 1
  <span><span><span>&lt;/</span>td</span><span>></span></span>
 <span><span><span>&lt;/</span>tr</span><span>></span></span>
 <span><span><span>&lt;</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>td</span> <span>bgcolor</span><span><span>=</span><span>"</span>#ffffff<span>"</span></span><span>></span></span>
   Row 2
  <span><span><span>&lt;/</span>td</span><span>></span></span>
 <span><span><span>&lt;/</span>tr</span><span>></span></span>
 <span><span><span>&lt;</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>td</span> <span>bgcolor</span><span><span>=</span><span>"</span>#ee4c50<span>"</span></span><span>></span></span>
   Row 3
  <span><span><span>&lt;/</span>td</span><span>></span></span>
 <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>4. 이미지 태그 사용시</p>
<div><pre><code><span><span><span>&lt;</span>td</span> <span>align</span><span><span>=</span><span>"</span>center<span>"</span></span> <span>bgcolor</span><span><span>=</span><span>"</span>#70bbd9<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>padding</span><span>:</span> 40px 0 30px 0<span>;</span></span><span>"</span></span></span><span>></span></span>
 <span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>images/h1.gif<span>"</span></span> <span>alt</span><span><span>=</span><span>"</span>Creating Email Magic<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>300<span>"</span></span> <span>height</span><span><span>=</span><span>"</span>230<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>display</span><span>:</span> block<span>;</span></span><span>"</span></span></span> <span>/></span></span>
<span><span><span>&lt;/</span>td</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>5. 영역을 또 나눌때</p>
<div><pre><code><span><span><span>&lt;</span>td</span> <span>bgcolor</span><span><span>=</span><span>"</span>#ffffff<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>padding</span><span>:</span> 40px 30px 40px 30px<span>;</span></span><span>"</span></span></span><span>></span></span>
 <span><span><span>&lt;</span>table</span> <span>border</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>cellpadding</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>cellspacing</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
   <span><span><span>&lt;</span>td</span><span>></span></span>
    Row 1
   <span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
   <span><span><span>&lt;</span>td</span><span>></span></span>
    Row 2
   <span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
   <span><span><span>&lt;</span>td</span><span>></span></span>
    Row 3
   <span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
 <span><span><span>&lt;/</span>table</span><span>></span></span>
<span><span><span>&lt;/</span>td</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>6. style은 inline 스타일로</p>
<div><pre><code><span><span><span>&lt;</span>table</span> <span>border</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>cellpadding</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>cellspacing</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span><span>></span></span>
 <span><span><span>&lt;</span>tr</span><span>></span></span>
  <span><span><span>&lt;</span>td</span> <span>width</span><span><span>=</span><span>"</span>260<span>"</span></span> <span>valign</span><span><span>=</span><span>"</span>top<span>"</span></span><span>></span></span>
   Column 1
  <span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;</span>td</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>font-size</span><span>:</span> 0<span>;</span> <span>line-height</span><span>:</span> 0<span>;</span></span><span>"</span></span></span> <span>width</span><span><span>=</span><span>"</span>20<span>"</span></span><span>></span></span>
   <span title="&nbsp;">&amp;nbsp;</span>
  <span><span><span>&lt;/</span>td</span><span>></span></span>
  <span><span><span>&lt;</span>td</span> <span>width</span><span><span>=</span><span>"</span>260<span>"</span></span> <span>valign</span><span><span>=</span><span>"</span>top<span>"</span></span><span>></span></span>
   Column 2
  <span><span><span>&lt;/</span>td</span><span>></span></span>
 <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><br>
<hr>
<h2 id="_0224-c동적-할당"> 0224 - C동적 할당</h2>
<h4 id="void-malloc-size-t-size"> void *malloc(size t size)</h4>
<ul>
<li>런타임 환경에서 동적으로 메모리를 할당</li>
<li>동적으로 메모리를 할당 할때는 Heap영역에 할당</li>
<li>성공 하면 할당한 메모리의 첫번째 주소 리턴</li>
<li>실패하면 NULL을 리턴</li>
</ul>
<h4 id="void-free-해제할-메모리-주소값"> void free(해제할 메모리 주소값)</h4>
<ul>
<li>malloc으로 생성된 메모리 영역을 제거함.</li>
</ul>
<br>
<hr>
<h2 id="_0225-javascript-each-foreach-some-map"> 0225 - JavaScript - $.each / forEach / some / map</h2>
<h4 id="each"> $.each()</h4>
<ul>
<li>$.each(Array, callback function(index, value){
});
<ul>
<li>반환값 해당 배열</li>
</ul>
</li>
</ul>
<h4 id="foreach"> forEach</h4>
<ul>
<li>Array.forEach(callback function (value, index, array) {
});
<ul>
<li>반환값 없음</li>
</ul>
</li>
</ul>
<h4 id="some"> some</h4>
<ul>
<li>Array.some(callback function (value, index, array) {
});
<ul>
<li>찾는 값과 비교하여 return true 시 반복문 종료</li>
</ul>
</li>
</ul>
<h4 id="map"> map</h4>
<ul>
<li>Array.map(callback(currentValue[, index[, array]])[, thisArg]);
<ul>
<li>return시 배열의 각 요소에 대해 callback을 실행하고 실행결과를 모은 새 배열을 리턴함</li>
</ul>
</li>
</ul>
<br>
<hr>
<h2 id="_0226-spring-aop"> 0226 - Spring AOP</h2>
<blockquote>
<p>관점 지향 프로그래밍으로 &quot;기능을 핵심 비지니스 기능과 공통 기능으로 구분하고, 공통기능을 개발자의 코드 밖에서 필요한 시점에 적용하는 프로그래밍 방법&quot;이다.</p>
</blockquote>
<h4 id="advice-pointcut-joinpoint"> advice / pointcut / joinpoint</h4>
<h4 id="aspect-구성"> aspect 구성</h4>
<ol>
<li>@Aspect을 등록</li>
<li>advice 메소드를 생성</li>
<li>advice에 joinpoint를 등록</li>
<li>joinpoint에 pointcut을 지정</li>
</ol>
<br>
<hr>
<h2 id="_0227-lombok"> 0227 - lombok</h2>
<h4 id="주의사항"> 주의사항</h4>
<ul>
<li>@Data 지양하기</li>
<li>무분별한 @Setter 지양하기</li>
<li>@ToString 양방향 순환 참조 문제 피하기</li>
<li>@EqualsAndHashCode 남발 지양하기
<ul>
<li>성능 이슈 발생할 수 있음 (Set 자료구조)</li>
</ul>
</li>
<li>클래스 상단의 @Builder는 지양하기
<ul>
<li>클래스 위에 @Builder 사용 시 @AllArgsConstructor 효과 발생</li>
<li>생성자 위 @Builder에 적절한 권한 부여</li>
</ul>
</li>
<li>생성자의 접근 지시자는 최소한
<ul>
<li>@NoArgsConstructor(access = AccessLevel.PRIVATE)</li>
</ul>
</li>
</ul>
<br>
<hr>
<h2 id="_0228-의존성-주입-방법"> 0228 - 의존성 주입 방법</h2>
<h4 id="생성자-주입-constructor-injection"> 생성자 주입(Constructor Injection)</h4>
<blockquote>
<p>생성자를 통해 의존 관계를 주입</p>
</blockquote>
<ol>
<li>생성자의 호출 시점에 1회 호출 되는것이 보장</li>
<li>주입받은 객체가 변하지 않거나, 반드시 객체의 주입이 필요한 경우에 강제하기 위해 사용</li>
<li>생성자가 1개만 있을경우 @Autowired를 생략해도 주입가능</li>
</ol>
<h4 id="수정자-주입-setter-주입-setter-injection"> 수정자 주입(Setter 주입, Setter Injection)</h4>
<blockquote>
<p>주입받는 객체가 변경될 가능성이 있는 경우 사용</p>
</blockquote>
<h4 id="필드-주입-field-injection"> 필드 주입(Field Injection)</h4>
<blockquote>
<p>필드에 바로 의존 관계 주입</p>
</blockquote>
<ol>
<li>외부에서 변경이 불가능</li>
<li>필드 주입은 반드시 DI 프레임워크가 존재해야함 따라서 지양해야함</li>
</ol>
<h4 id="일반-메소드-주입"> 일반 메소드 주입</h4>
<h3 id="생성자-주입을-사용해야-하는-이유"> 생성자 주입을 사용해야 하는 이유</h3>
<blockquote>
<p>Spring을 포함한 DI 프레임워크의 대부분이 생성자 주입을 권장</p>
</blockquote>
<ol>
<li>객체의 불변성 확보</li>
</ol>
<ul>
<li>의존관계 주입의 변경이 필요한 상황은 거의 없다.
생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장</li>
</ul>
<ol start="2">
<li>테스트 코드의 작성</li>
</ol>
<ul>
<li>필드 주입으로 작성된 경우에는 순수한 자바 코드로 단위 테스트를 작성하는 것이 불가능</li>
</ul>
<ol start="3">
<li>final 키워드 작성 및 Lombok과의 결합</li>
</ol>
<ul>
<li>컴파일 시적에 누락된 의존성을 확인 할 수 있음</li>
<li>생성자 주입을 제외한 다른 주입 방법들은 객체의 생성 이후에 호출 되므로 final 키워드를 사용 할 수 없다.</li>
<li>final키워드를 붙일 수 있음으로 Lombok과 결합, 코드를 간결하게 작성 할 수 있다.</li>
</ul>
<ol start="4">
<li>순환 참조 에러 방지</li>
</ol>
<ul>
<li>애플리케이션 구동 시점(객체의 생성 시점)에 순환 참조 에러를 방지</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0329 - 0404</title>
      <link>ahnjs/TIL/2021/0329/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0329/</guid>
      <source url="ahnjs/TIL/rss.xml">0329 - 0404</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0329-0404"> 0329 - 0404</h1>
<h2 id="_0329-log"> 0329 - log</h2>
<h4 id="slf4j"> SLF4J</h4>
<blockquote>
<p>Simple Logging Facade for Java 의 약자로 logging framework들을 추상화 해 놓은 것. Facade Pattern을 적용한 logging framework이다.</p>
</blockquote>
<h4 id="logback"> Logback</h4>
<ul>
<li>
<p>Spring Boot는 logback이 기본으로 설정, 별도로 라이브러리를 추가 하지 않아도 된다.</p>
<ul>
<li>spring-boot-starter-web 안에 spring-boot-starter-logging 구현체 존재.</li>
</ul>
</li>
<li>
<p>logback-spring.xml</p>
</li>
</ul>
<div><pre><code><span>&lt;?xmlversion="1.0"encoding="UTF-8"?></span>
<span><span><span>&lt;</span>configuration</span><span>></span></span>

<span>&lt;!--프로퍼티--></span>
<span>&lt;!--&lt;propertyname="LOGS_PATH"value="./logs"/>--></span>

&lt;appendername="CONSOLE"class="ch.qos.logback.core.ConsoleAppender">
&lt;layoutclass="ch.qos.logback.classic.PatternLayout">
<span><span><span>&lt;</span>pattern</span><span>></span></span>%highlight(%-5p):[%d{yyyy-MM-ddHH:mm:ss:mmm}]%cyan(%c)-%m%n{2,CALLER_DISPLAY_EVAL}<span><span><span>&lt;/</span>pattern</span><span>></span></span>
<span><span><span>&lt;/</span>layout</span><span>></span></span>
<span><span><span>&lt;/</span>appender</span><span>></span></span>

&lt;appendername="SAMPLE"class="ch.qos.logback.core.ConsoleAppender">
<span><span><span>&lt;</span>encoder</span><span>></span></span>
<span><span><span>&lt;</span>pattern</span><span>></span></span>[%d{yyyy-MM-ddHH:mm:ss}:%-3relative][%thread]%-5level%logger{35}-%msg%n<span><span><span>&lt;/</span>pattern</span><span>></span></span>
<span><span><span>&lt;/</span>encoder</span><span>></span></span>
<span><span><span>&lt;/</span>appender</span><span>></span></span>

&lt;appendername="COM_FILE"class="ch.qos.logback.core.rolling.RollingFileAppender">
&lt;filterclass="ch.qos.logback.classic.filter.ThresholdFilter">
<span><span><span>&lt;</span>level</span><span>></span></span>INFO<span><span><span>&lt;/</span>level</span><span>></span></span>
<span><span><span>&lt;/</span>filter</span><span>></span></span>
<span><span><span>&lt;</span>prudent</span><span>></span></span>true<span><span><span>&lt;/</span>prudent</span><span>></span></span>
&lt;rollingPolicyclass="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
<span><span><span>&lt;</span>fileNamePattern</span><span>></span></span>${ROUTER_HOME}/log/router_log.%d{yyyy-MM-dd}.log<span><span><span>&lt;/</span>fileNamePattern</span><span>></span></span>
<span><span><span>&lt;</span>maxHistory</span><span>></span></span>30<span><span><span>&lt;/</span>maxHistory</span><span>></span></span>
<span><span><span>&lt;/</span>rollingPolicy</span><span>></span></span>
<span><span><span>&lt;</span>encoder</span><span>></span></span>
<span><span><span>&lt;</span>pattern</span><span>></span></span>%-5p:[%d{yyyy-MM-ddHH:mm:ss:mmm}]%c-%m%n<span><span><span>&lt;/</span>pattern</span><span>></span></span>
<span><span><span>&lt;/</span>encoder</span><span>></span></span>
<span><span><span>&lt;/</span>appender</span><span>></span></span>

&lt;loggername="com.ese"additivity="false"level="INFO">
&lt;appender-refref="CONSOLE"/>
&lt;appender-refref="COM_FILE"/>
<span><span><span>&lt;/</span>logger</span><span>></span></span>

<span>&lt;!--RootLogger--></span>
&lt;rootlevel="INFO">
&lt;appender-refref="CONSOLE"/>
<span><span><span>&lt;/</span>root</span><span>></span></span>
<span><span><span>&lt;/</span>configuration</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><ul>
<li>appender : log의 형태를 설정</li>
<li>logger : 설정한 appender를 참조하여 package와 level을 설정</li>
<li>property : 프로퍼티를 설정</li>
</ul>
<br>
<h2 id="_0330-maven-wrapper"> 0330 - Maven Wrapper</h2>
<h4 id="구성"> 구성</h4>
<ul>
<li>
<p>https://github.com/takari/takari-maven-plugin<br>
Maven wrapper plugin 사용</p>
</li>
<li>
<p>intellij 기준 [ ctrl + ctrl ]<br>
<code>mvn (모듈명) -N io.takari:maven:wrapper 실행</code><br>
=&gt; .mvn mvnw, mvnw.cmd 생성</p>
</li>
</ul>
<h4 id="mvnw-mvwn-cmd"> mvnw / mvwn,cmd</h4>
<ul>
<li>mvnw : Maven 대신에 사용되는 실행 가능한 unix shell script.</li>
<li>mvwn.cmd : mvnw 의 윈도우 배치 버전 shell script.</li>
</ul>
<h4 id="mvn"> .mvn</h4>
<ul>
<li>MavenWrapperDownloader.java : 자바클래스 파일인 이파일을 컴파일링하여 메이븐 다운로드</li>
<li>maven-wrapper.jar : wrappper shell scripts 로 부터 maven 을 실행하고, 다운로드 하는데 사용</li>
<li>maven-wrapper.properties : Maven 이 존재하지 않는 경우 다운로드하기 위한 URL 을 명시하기 위해서 사용</li>
</ul>
<h4 id="maven-wrapper-실행하기"> Maven Wrapper 실행하기</h4>
<ul>
<li>Maven/target Clean 및 build
<ul>
<li>./mvnw clean package</li>
</ul>
</li>
<li>Maven 으로 Spring boot 를 백그라운드로 실행
<ul>
<li>./mvnw spring-boot:run &amp;</li>
</ul>
</li>
<li>mvnw 로 설치된 maven 배포 경로
<ul>
<li>~/.m2/wrapper/dists</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0331-github-저장소-repository-미러링"> 0331 - GitHub 저장소(repository) 미러링</h2>
<blockquote>
<p>미러링이란 commit log를 유지하며 clone</p>
</blockquote>
<h4 id="저장소-미러링"> 저장소 미러링</h4>
<ol>
<li>복사하고자하는 저장소의 bare clone 생성</li>
</ol>
<div><pre><code><span>git</span> clone --bare <span>{</span>복사하고자하는 저장소의 <span>git</span> 주소<span>}</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>새로운 저장소로 mirror-push</li>
</ol>
<div><pre><code><span>cd</span> <span>{</span>복사하고자하는 저장소의 <span>git</span> 주소<span>}</span>
<span>git</span> push --mirror <span>{</span>붙여놓을저장소의 <span>git</span> 주소<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="3">
<li>1번에서 생성된 저장소 삭제</li>
</ol>
<h4 id="_100mb를-넘어가는-파일을-가진-저장소-미러링"> 100MB를 넘어가는 파일을 가진 저장소 미러링</h4>
<ol>
<li>git lfs와 BFG Repo Cleaner 설치</li>
<li>복사하고자 하는 저장소의 bare clone 생성</li>
</ol>
<div><pre><code><span>git</span> clone --mirror <span>{</span>복사하고자하는저장소의 <span>git</span> 주소<span>}</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>commit history에서 large file을 찾아 트랙킹</li>
</ol>
<div><pre><code><span>git</span> filter-branch --tree-filter <span>'git lfs track "*.{zip,jar}"'</span> -- --all
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>BFG를 이용하여 해당 파일들을 git lfs로 변경</li>
</ol>
<div><pre><code>java -jar ~/usr/bfg-repo-cleaner/bfg-1.13.0.jar --convert-to-git-lfs <span>'*.zip'</span>
java -jar ~/usr/bfg-repo-cleaner/bfg-1.13.0.jar --convert-to-git-lfs <span>'*.jar'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="5">
<li>새로운 저장소로 mirror-push</li>
</ol>
<div><pre><code>cd {복사하고자하는저장소의 git 주소}
git push --mirror {붙여놓을저장소의 git wnth}
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="6">
<li>1번에서 생성된 저장소 삭제</li>
</ol>
<br>
<h2 id="_0401-웹-애플리케이션-정리"> 0401 - 웹 애플리케이션 정리</h2>
<blockquote>
<p>웹 애플리케이션이란 HTTP 요청을 받고 HTTP 응답을 만드는 코드를 작성한다는것<br>
이점을 인지하고 개발하는게 중요 =&gt; 웹 기술 빠르게 파악가능</p>
</blockquote>
<h4 id="http-요청"> HTTP 요청</h4>
<ul>
<li>URI</li>
<li>METHOD</li>
<li>HEADER</li>
<li>BODY</li>
</ul>
<p>스프링은 HTTP 요청을 통해 두가지 작업을 한다.</p>
<ol>
<li>요청을 처리할 컨트롤러를 찾는 작업 - Mapping</li>
<li>컨트롤러 메소드에 요청 정보를 어떤 식으로 전달할까를 결정하는 작업</li>
</ol>
<div><pre><code><span>@RequestMapping</span><span>(</span><span>"/hello"</span><span>)</span>
<span>=</span><span>></span> HTTP 요청중 URI 부분으로 매핑  
<span>=</span><span>></span> 보통 BODY는 매핑에 사용되지않고<span>,</span> 나머지 구성요소로함<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>매핑에서 컨트롤러 메소드까지 결정하면 그 다음은 파라미터에 어떻게 HTTP 요청을 가공해서 넘겨줄 것인가를 정하는 것.<br>
(바인딩하는 방법은 관례적으로 30가지가 존재)</p>
<h4 id="http-응답"> HTTP 응답</h4>
<blockquote>
<p>HTTP 응답은 크게</p>
</blockquote>
<ul>
<li>상태 코드</li>
<li>헤더</li>
<li>바디</li>
</ul>
<p>가장먼저 상태코드를 넣고 헤더 요소 중 <code>content type</code>에 따라 바디에 html을 넣을지, json을 넣을지, binary를 인코딩해서 넣을지 등등을 결정.</p>
<p>*** 결론은 웹 개발에서 가장 중요시 해야하는 것은 '요청과 응답이 어떻게 다뤄지고 만들어지는가' 이다.</p>
<hr>
<p>정리
<img width="725" alt="웹 개발" src="https://user-images.githubusercontent.com/49400801/113293733-1a5e4b80-9331-11eb-805d-319744129028.png"></p>
<br>
<h2 id="_0402-데드락-deadlock"> 0402 - 데드락(DeadLock)</h2>
<blockquote>
<p>프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태<br>
'교착 상태'라고도 부름<br>
시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생</p>
</blockquote>
<h4 id="데드락이-일어나는-경우"> 데드락이 일어나는 경우</h4>

<p>프로세스 1과 2가 자원1,2를 모두 얻어야 한다고 가정했을때</p>
<div><pre><code>t1 : 프로세스 1이 자원1을 얻음 / 프로세스2가 자원 2를 얻음
t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐<br>
-&gt; 이게 DeadLock</p>
<h4 id="주로-발생하는-경우"> [주로 발생하는 경우]</h4>
<ul>
<li>멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생</li>
<li>한 프로세스가 자원을 요쳥했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이때 프로세스는 대기 상태로 들어감</li>
<li>대기상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 '교착 상태' 발생</li>
</ul>
<h4 id="데드락-발생-조건"> 데드락 발생 조건</h4>
<blockquote>
<p>4가지 모두 성립해야 데드락 발생(하나라도 성립하지 않으면 데드락 문제 해결 가능)</p>
</blockquote>
<ol>
<li>상호 배제(Mutual exclusion)</li>
</ol>
<ul>
<li>자원은 한 프로세스만 사용할 수 있음</li>
</ul>
<ol start="2">
<li>점유 대기(Hold and wait)</li>
</ol>
<ul>
<li>최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함</li>
</ul>
<ol start="3">
<li>비선점(No preemption)</li>
</ol>
<ul>
<li>다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음</li>
</ul>
<ol start="4">
<li>순환 대기(Circular wait)</li>
</ol>
<ul>
<li>프로세스 집합에서 순환 형태로 자원을 대기하고 있어야 함</li>
</ul>
<h4 id="데드락-처리"> 데드락 처리</h4>
<ul>
<li>교착 상태를 예방 &amp; 회피</li>
</ul>
<ol>
<li>예방(prevention)<br>
교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
<ul>
<li>상호배제 부정 : 여러 프로세스가 공유 자원 사용</li>
<li>점유대기 부정 : 프로세스 실행전 모든 자원을 할당</li>
<li>비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납</li>
<li>순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구</li>
</ul>
</li>
<li>회피(avoidance)<br>
교착 상태 발생 시 피해나가는 방법<br>
은행원 알고리즘(Banker's Algorithm)
<ul>
<li>은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함</li>
<li>프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착상태 회피</li>
<li>안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기</li>
</ul>
</li>
</ol>
<ul>
<li>교착 상태를 탐지 &amp; 회복<br>
교착 상태가 되도록 허용한 다음 회복시키는 방법</li>
</ul>
<ol>
<li>탐지(Detection)<br>
자원 할당 그래프를 통해 교착 상태를 탐지함<br>
자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함</li>
<li>회복(Recovery)<br>
교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
<ul>
<li>프로세스 종료 방법
<ul>
<li>교착 상태의 프로세스를 모두 중지</li>
<li>교착 상태가 제거될 때까지 하나씩 프로세스 중지</li>
</ul>
</li>
<li>자원 선점 방법
<ul>
<li>교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)</li>
<li>우선 순위가 낮은 프로세스나 수행 횟수가 적은 프로세스 위주로 프로세스 자원 선점</li>
</ul>
</li>
</ul>
</li>
</ol>
<br>
<h2 id="_0403-object-클래스-wait-notify-notifyall"> 0403 - Object 클래스 wait, notify, notifyAll</h2>
<blockquote>
<p>Java 최상위 클래스 = Object 클래스</p>
</blockquote>
<h4 id="object-class가-갖고-있는-메서드"> Object Class가 갖고 있는 메서드</h4>
<ul>
<li>toString()</li>
<li>hashCode()</li>
<li>wait()<br>
갖고 있던 고유 lock 해제, Thread를 잠들게 함</li>
<li>notify()<br>
잠들던 Thread 중 임의의 하나를 깨움.</li>
<li>notifyAll()
잠들어 있던 Thread를 모두 깨움.</li>
</ul>
<p><code>wait, notify, notifyAll : 호출하는 스레드가 반드시 고유 락을 갖고 있어야함.</code></p>
<ul>
<li>Synchronized 블록 내에서 실행되어야 함.</li>
<li>그 블록 안에서 호출하는 경우 IllegalMonitorStateException 발생.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0322 - 0328</title>
      <link>ahnjs/TIL/2021/0322/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0322/</guid>
      <source url="ahnjs/TIL/rss.xml">0322 - 0328</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0322-0328"> 0322 - 0328</h1>
<h2 id="_0322-git-fetch"> 0322 - git fetch</h2>
<blockquote>
<p>원격 저장소의 내용을 확인만하고 로컬 데이터와 병합은 하고싶지 않은 경우에 fetch 명령어를 사용</p>
</blockquote>
<ul>
<li>fetch를 실행하면, 커밋이력이 이름 없는 브랜치로 로컬에 가져옴</li>
<li>fetch 후 merge 수행시 pull과 동일<br>
=&gt; pull = fetch + merge</li>
</ul>
<br>
<h2 id="_0323-oauth"> 0323 - OAuth</h2>
<blockquote>
<p>Open Authentification</p>
</blockquote>
<p>인터넷 사용자들이 비밀번호를 제공하지 않고, 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 개방형 표준 방법</p>
<p>이러한 매커니즘은 구글, 페이스북, 트위터 등이 사용하고 있으며 타사 애플리케이션 및 웹사이트의 계정에 대한 정보를 공유할 수 있도록 허용해준다.</p>
<h4 id="사용언어"> 사용언어</h4>
<ul>
<li>사용자 : 계정을 가지고있는 개인</li>
<li>소비자 : OAuth를 사용해 서비스 제공자에게 접근하는 웹사이트 or 애플리케이션</li>
<li>서비스 제공자 : OAuth를 통해 접근을 지원하는 웹 애플리케이션</li>
<li>소비자 비밀번호 : 서비스 제공자에서 소비자가 자신임을 인증하기 위한 키</li>
<li>요청 토큰 : 소비자가 사용자에게 접근권한을 인증받기 위해 필요한 정보가 담겨있음</li>
<li>접근 토큰 : 인증 후에 사용자가 서비스 제공자가 아닌 소비자를 통해 보호 자원에 접근하기 위한 키 값</li>
</ul>
<p>토큰 종류로는 Access Token과 Refresh Token이 있다.<br>
Access Token은 만료시간이 있고 끝나면 다시 요청해야 한다. Refresh Token은 만료되면 아예 처음부터 진행해야 한다.</p>
<h4 id="인증과정"> 인증과정</h4>
<blockquote>
<p>소비자 &lt;-&gt; 서비스 제공자</p>
</blockquote>
<ol>
<li>소비자가 서비스 제공자에게 요청토큰을 요청한다.</li>
<li>서비스 제공자가 소비자에게 요청토큰을 발급한다.</li>
<li>소비자가 사용자를 서비스제공자로 이동시킨다. 여기서 사용자 인증이 수행된다.</li>
<li>서비스 제공자가 사용자를 소비자로 이동시킨다.</li>
<li>소비자가 접근토큰을 요청한다.</li>
<li>서비스제공자가 접근토큰을 발급한다.</li>
<li>발급된 접근토큰을 이용해서 소비자의 사용자 정보에 접근한다.</li>
</ol>
<br>
<h2 id="_0324-vo-dto-entity"> 0324 - VO, DTO, Entity</h2>
<h4 id="entity"> Entity</h4>
<blockquote>
<p>DB의 테이블내에 존재하는 컬럼만을 속성(필드)으로 가지는 클래스를 말함.</p>
</blockquote>
<ul>
<li>Id(PK)를 통해 구분, 비즈니스 로직을 가질 수 있다.</li>
</ul>
<h4 id="dto-data-transfer-object"> DTO(Data Transfer Object)</h4>
<blockquote>
<p>레이어 간에 데이터를 전달하는 객체</p>
</blockquote>
<ul>
<li>Setter, Getter를 가지며 별도의 비지니스 로직을 가지지는 않음.</li>
<li>비슷한 특성을 가진 값을 하나의 객체로 묶어 레이어간 전달에 유용하도록 만든 자료 구조라고 정리할 수 있다.</li>
</ul>
<h4 id="vo"> VO</h4>
<blockquote>
<p>DTO와 동일하게 레이어와 레이어간에 데이터를 전달하는 객체</p>
</blockquote>
<ul>
<li>immutable(불변성)을 가짐.</li>
<li>Object의 equals, hashcode를 오버라이딩 했을때 동일 여보를 확인 할 수 있다.</li>
<li>로직 포함 가능</li>
</ul>
<br>
<h2 id="_0325-web-server와-was"> 0325 - Web Server와 WAS</h2>
<h4 id="web-server"> Web Server</h4>
<blockquote>
<p>클라이언트가 요청하는 HTML 문서나 각종 리소스를 전달하는 소프트웨어 위에서 말한 소프트웨어 외에도 해당 소프트웨어를 실행시키는 하드웨어 또한 웹 서버라고 할한다.<br>
<code>아파치 HTTP 서버, Nginx, WebtoB</code></p>
</blockquote>
<h4 id="was-web-application-server"> WAS (Web Application Server)</h4>
<blockquote>
<p>동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버로써 웹 프로그램을 실행할 수 있는 환경을 제공한다.<br>
<code>Tomcat, Jeus, WebLogic, WebSphere</code></p>
</blockquote>
<h4 id="웹-서버와-was의-차이"> 웹 서버와 WAS의 차이</h4>
<ul>
<li>웹서버는 정적인 컨텐츠를 제공하고, WAS는 동적인 컨텐츠를 제공함</li>
<li>WAS는 동적인 컨텐츠 뿐만 아니라 정적인 컨텐츠도 제공가능</li>
</ul>
<h4 id="웹서버와-was를-분리하는-이유"> 웹서버와 WAS를 분리하는 이유</h4>
<ol>
<li>기능을 분리하여 서버 부하를 방지</li>
<li>물리적으로 분리하여 보안을 강화</li>
<li>WEB서버에 여러 대의 WAS 연결 가능</li>
<li>여러 Web Application을 서비스 할 수 있다</li>
</ol>
<p>-&gt; 가장 큰 이유는 <code>로드밸런싱</code></p>
<br>
<h2 id="_0326-express-라우트-객체"> 0326 - Express 라우트 객체</h2>
<blockquote>
<p>node.js express 라우트 요청, 응답 객체</p>
</blockquote>
<h4 id="request"> Request</h4>
<ul>
<li>Methods
<ul>
<li>req.params</li>
<li>req.query</li>
<li>req.body</li>
<li>req.headers</li>
</ul>
</li>
</ul>
<h4 id="response"> Response</h4>
<ul>
<li>Methods
<ul>
<li>res.status(code)</li>
<li>res.send(body), res.send(status,body)</li>
<li>res.json(json)</li>
<li>res.render(vidw, [locals], callback)</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0327-tibero-관련-정리"> 0327 - Tibero 관련 정리</h2>
<h4 id="세션수-관리"> 세션수 관리</h4>
<p><code>$TB_HOM\config\$TB_SID</code></p>
<div><pre><code>#--------------------------------------------------
# Tibero Initialization Parameters
#--------------------------------------------------
#Thu Feb 20 11:31:40 KST 2020
CONTROL_FILES=&quot;C\:\\TmaxData\\tibero6\\database\\tibero\\c1.ctl&quot;
DB_NAME=tibero
LISTENER_PORT=8629
MAX_SESSION_COUNT=100
MEMORY_TARGET=3G
TOTAL_SHM_SIZE=2G
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="강제-재시작"> 강제 재시작</h4>
<div><pre><code># tbdown clean
# tbboot (or 서비스 재시작)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>%TB_HOME%/instance/%TB_SID%/proc.list 파일 삭제</code></p>
<br>
<h2 id="_0328-os-관련"> 0328 - OS 관련</h2>
<h4 id="window"> window</h4>
<ul>
<li>애플리케이션 실행 bat파일<br>
<code>파일명.bat</code></li>
</ul>
<div><pre><code>title 타이틀
SET 환경 변수명=C:\위치
java -jar 파일명.war -Dfile.encoding=UTF-8
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>부팅시 bat파일 실행</p>
<ul>
<li>실행 - shell:startup</li>
<li>바로가기 등록</li>
</ul>
</li>
<li>
<p>레지스트리 변경</p>
<ul>
<li>실행 - regedit</li>
<li>[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce] 해당 값 추가 (파일명+경로)</li>
</ul>
</li>
<li>
<p>명령 프롬프트</p>
<ul>
<li>PID 확인<br>
<code>netstat -nao | findstr PORT</code></li>
<li>프로세스 종료<br>
<code>taskkill /pid PID /f</code></li>
<li>패킷 경로 확인<br>
<code>tracert -d IP</code></li>
</ul>
</li>
</ul>
<h4 id="linux"> linux</h4>
<ul>
<li>
<p>Cent OS firewall-cmd<br>
<code>firewall-cmd --list all</code><br>
<code>firewall-cmd --permanent --add-port=IP/tcp</code><br>
<code>firewall-cmd --reload</code><br>
<code>firewall-cmd systectl start/stop/restart firewalld</code></p>
</li>
<li>
<p>애플리케이션 실행 sh 파일<br>
<code>파일명.sh</code></p>
</li>
</ul>
<div><pre><code>export 환경변수명=/위치
nohup java -jar 파일명.war &amp;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>명령어</li>
</ul>
<div><pre><code>netstat -nap | grep {port}
lsof -i TCP:{port}
fuser -k -n tcp {pid}
kill -9 {pid}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0419 - 0425</title>
      <link>ahnjs/TIL/2021/0419/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0419/</guid>
      <source url="ahnjs/TIL/rss.xml">0419 - 0425</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0419-0425"> 0419 - 0425</h1>
<h2 id="_0420-rest-resource-naming-guide"> 0420 - REST Resource Naming Guide</h2>
<ol>
<li>
<p>A resource can be a singleton or a collection.<br>
하나의 리소스는 싱글턴 또는 컬랙션이 될 수 있다.</p>
</li>
<li>
<p>A resource may contain sub-collection resources also<br>
리소스는 sub-collection 리소스를 포함할 수 있다.<br>
<code>/customers/{Id}/accounts</code></p>
</li>
</ol>
<h4 id="rest-resource-네이밍"> REST Resource 네이밍</h4>
<p>Use nouns to represent resources. (리소스를 표한하기 위해서 명사를 사용)<br>
RESTful URI는 반드시 리소스 그 자체를 언급해야 하며, 리소스의 행동을 언급해서는 안된다.<br>
예를 들면, 아래와 같은 리소스들이 있을 때 URI는 다음과 같이 디자인 될 수 있다.</p>
<ul>
<li>Users of the system</li>
<li>User Accounts</li>
<li>Network Devices etc</li>
</ul>
<div><pre><code>http://api.example.com/device-management/managed-devices 
http://api.example.com/device-management/managed-devices/{device-id} 
http://api.example.com/user-management/users/
http://api.example.com/user-management/users/{id}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol>
<li>document 리소스
문서의 유형을 나타날 때는 '단수'를 사용.</li>
</ol>
<div><pre><code>http://api.example.com/device-management/managed-devices/{device-id}
http://api.example.com/user-management/users/{id}
http://api.example.com/user-management/users/admin
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>collection 리소스
Collection 단위의 리소스를 표시할 때는 '복수'를 사용</li>
</ol>
<div><pre><code>http://api.example.com/device-management/managed-devices
http://api.example.com/user-management/users
http://api.example.com/user-management/users/{id}/accounts
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="3">
<li>store 리소스
저장에 관한 요청은 클라이언트가 관리하는 리소스 저장소이다. 따라서 '복수'를 사용한다</li>
</ol>
<div><pre><code>http://api.example.com/song-management/users/{id}/playlists
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>controller 리소스
컨트롤러 리소스는 실행 가능한 기능과 함께 파라미터 혹은 리턴 값으로 이름 짓는다.<br>
이 때는 '동사'를 사용한다.</li>
</ol>
<div><pre><code>http://api.example.com/cart-management/users/{id}/cart/checkout
http://api.example.com/song-management/users/{id}/playlist/play
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="uri의-일관성"> URI의 일관성</h4>
<ol>
<li>계층 구조를 표현하기 위해서 '/'를 사용한다.</li>
</ol>
<div><pre><code>http://api.example.com/device-management
http://api.example.com/device-management/managed-devices
http://api.example.com/device-management/managed-devices/{id}
http://api.example.com/device-management/managed-devices/{id}/scripts
http://api.example.com/device-management/managed-devices/{id}/scripts/{id}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ol start="2">
<li>
<p>끝에 '/'가 붙지 않도록 한다.</p>
</li>
<li>
<p>언더바 사용은 피하며 '-'을 사용한다.</p>
</li>
<li>
<p>편리함 + 컨벤션을 시키지 위해서 소문자를 사용한다.</p>
</li>
<li>
<p>파일 확장자를 포함 하지 않는다.</p>
</li>
<li>
<p>URI를 사용해서 CRUD 기능의 수행되었음을 표시해서는 안된다.<br>
URI는 자원에 대ㅑ한 어떠한 행동을 나타내면 안되고, 자원을 독립적으로 식별하는 방식으로 사용되어야 한다. 어떤 기능이 수행되는지 표시하기 위해서는 HTTP 요청 방법을 사용한다.</p>
</li>
</ol>
<div><pre><code>HTTP GET http://api.example.com/device-management/managed-devices  //Get all devices
HTTP POST http://api.example.com/device-management/managed-devices  //Create new Device

HTTP GET http://api.example.com/device-management/managed-devices/{id}  //Get device for given Id
HTTP PUT http://api.example.com/device-management/managed-devices/{id}  //Update device for given Id
HTTP DELETE http://api.example.com/device-management/managed-devices/{id}  //Delete device for given Id
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="7">
<li>쿼리스트링을 이용하는 것을 고려해라<br>
특정 리소스의 속성을 기준으로 정렬, 필터링을 자주하게 될 수 있다.
이를 위해서 새로운 API를 만들기보단, 입력 매개변수를 쿼리스트링에 전달하도록 한다.</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>0426 - 0502</title>
      <link>ahnjs/TIL/2021/0426/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0426/</guid>
      <source url="ahnjs/TIL/rss.xml">0426 - 0502</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0426-0502"> 0426 - 0502</h1>
<h2 id="_0426-value"> 0426 - @Value</h2>
<blockquote>
<p>properties 등록 값을 읽는데 사용가능하다.</p>
</blockquote>
<h4 id="기본-사용법"> 기본 사용법</h4>
<ul>
<li>사용/주입</li>
</ul>
<div><pre><code><span>@Value</span><span>(</span><span>" ${test.value} "</span><span>)</span>
<span>private</span> <span>String</span> testValue<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>디폴트 값 설정</li>
</ul>
<div><pre><code><span>@Value</span><span>(</span><span>" ${test.value:defaultValue} "</span><span>)</span>
<span>private</span> <span>String</span> testValue<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>properties 파일 지정</li>
</ul>
<div><pre><code><span>@RestController</span>
<span>@PropertySource</span><span>(</span><span>"classpath:test.properties"</span><span>)</span> 
<span>public</span> <span>class</span> <span>TestController</span> <span>{</span>
    <span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>여러 properties 파일</li>
</ul>
<div><pre><code><span>@Configuration</span>
<span>@PropertySource</span><span>(</span><span>"classpath:foo.properties"</span><span>)</span>
<span>@PropertySource</span><span>(</span><span>"classpath:bar.properties"</span><span>)</span>
<span>public</span> <span>class</span> <span>PropertiesWithJavaConfig</span> <span>{</span>
    <span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="주의사항"> 주의사항</h4>
<p>@Value를 사용하는 객체를 반드시 Bean으로 등록해줘야한다.</p>
<div><pre><code>Spring이 자동으로 값을 넣어주거나 의존성을 주입해주는것을 DI라고 한다. 의존성 주입을 위해서는 애플리케이션 소스 코드가 아닌 독립된 컨테이너가 객체의 생성, 사용, 소멸에 대한 제어권을 받아서 처리하도록 하여햐 한다.
이를 제어의 역전(IoC)이라고 하며, 해당 컨테이너를 IoC 컨테이너라고 한다.  

IoC 컨테이너 내부에 객체를 등록하기 위해서는 Bean이라는 객체로 만들어 줘야 하기때문에
stereotype이라고 불리는 어노테이션을 객체 위에 명시 해줘야 한다.

// 예
@Component, @Controller, @Service, @Repository, @Bean, @Configuration ...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><br>
<h2 id="_0427-cron-crontab"> 0427 - cron &amp; crontab</h2>
<blockquote>
<p>유닉스/리눅스 계열에서 특정 시간에 특정작업을 하는 데몬은 Cron(크론)<br>
Cron이 언제 무슨 일을 하도록 설정해 특정 파일에 저장하는 Crontab(크론탭)이라고 한다.</p>
</blockquote>
<h4 id="crontab-설정-방법"> Crontab 설정 방법</h4>
<ol>
<li>/etc/crontab 변경</li>
<li>crontab -e
<ul>
<li>옵션</li>
</ul>
<div><pre><code>crontab -e : 명령을 등록, 편집
crontab -d : 등록된 명령을 삭제
crontab -l : 현재 등록된 리스트 출력
crontab -l -u otheruser : otheruser 사용자가 등록한 crontab 리스트 출력
crontab -r : 현재 사용자가 등록한 crontab 전체 삭제
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ol>
<h4 id="형식"> 형식</h4>
<div><pre><code>* * * * *  수행할 명령어
┬ ┬ ┬ ┬ ┬
│ │ │ │ │
│ │ │ │ │
│ │ │ │ └───────── 요일 (0 - 6) (0:일요일, 1:월요일, 2:화요일, …, 6:토요일)
│ │ │ └───────── 월 (1 - 12)
│ │ └───────── 일 (1 - 31)
│ └───────── 시 (0 - 23)
└───────── 분 (0 - 59)
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h4 id="서비스"> 서비스</h4>
<div><pre><code>service cron status
service cron start
service cron stop
service cron restart
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><br>
<h2 id="_0428-알고리즘-관련"> 0428 - 알고리즘 관련</h2>
<h4 id="자료구조의-종류"> 자료구조의 종류</h4>
<img width="725" alt="웹 개발" src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmC1GI%2Fbtqt8nmjpQc%2FknDauTotHKOkjLo8CdWMak%2Fimg.png">
<h4 id="정렬"> 정렬</h4>
<div><pre><code>버블 정렬 - 가장 쉽지만, 시간 복잡도가 높아 효율적이지는 않다.
선택 정렬 - 버블 정렬과 알고리즘이 유사하다. 가장 큰 수를 찾아 배열의 마지막 위치과 교환한다.
삽입 정렬 - 인덱스를 설정하여 현재 위치의 값을 아래쪽으로 순회하며 알맞은 곳에 넣어준다.
병합 정렬 - 정렬한 리스트를 반으로 쪼개며 좌우 리스트를 분할해 정렬 후 병합한다. 가장 많이 쓰이는 정렬중 하나이다.
힙 정렬 - 힙이라는 자료구조를 통해 내림차순으로 숫자를 넣은후, 역순으로 꺼내어 정렬한다.
퀵 정렬 - pivot기준으로 좌측과 우측의 작은 값과 큰 값을 재배치하고 분할하여 정렬한다.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>참고 사이트
<ul>
<li><a href="https://medium.com/@fiv3star/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-sorting-algorithm-%EC%A0%95%EB%A6%AC-8ca307269dc7" target="_blank" rel="noopener noreferrer">TonyMedium - 정렬 알고리즘<i>Content not supported</i></a></li>
<li><a href="https://namu.wiki/w/%EC%A0%95%EB%A0%AC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98" target="_blank" rel="noopener noreferrer">나무위키 - 정렬 알고리즘<i>Content not supported</i></a></li>
</ul>
</li>
</ul>
<h4 id="알고리즘-문제-사이트"> 알고리즘 문제 사이트</h4>
<ul>
<li>
<p>국내 사이트</p>
<ul>
<li>백준(BOJ)</li>
<li>프로그래머스</li>
<li>알고스팟</li>
<li>코딩도장</li>
</ul>
</li>
<li>
<p>해외 사이트</p>
<ul>
<li>Hackerearth</li>
<li>Hackerrank</li>
<li>Codeforces</li>
</ul>
</li>
</ul>
<br>
<h2 id="_0430-99콘-이력서후기"> 0430 - 99콘 이력서후기</h2>
<blockquote>
<p>앞으로 나의 이력을 어떻게 관리하고 어떤 방향으로 좋은 개발자가 되기 위해 노력할지!</p>
</blockquote>
<h4 id="앞으로-해야할일"> 앞으로 해야할일</h4>
<ul>
<li>레퍼런스를 쌓을 수 있는 일을 많이 할 것</li>
<li>깃허브 관리와 블로그 관리하기</li>
<li>토이 프로젝트 꾸준히 진행하기</li>
<li>글쓰기에 노력을 투자하기</li>
</ul>
<h4 id="지향해야-할-점과-지양해야-할-점"> 지향해야 할 점과 지양해야 할 점</h4>
<ul>
<li>긍정
<ul>
<li>경험의 폭이 좁아도 생각의 폭은 넓히자</li>
<li>항상 탐구하고 깊이 파고들자</li>
<li>유연한 사고와 팀원을 배려하자</li>
<li>똑똑한 지원자</li>
<li>호기심이 많은 지원자</li>
<li>많이, 빠르게 학습하려 노력하기</li>
<li>포기하지 않고 끝까지 생각해보고 이야기하기</li>
<li>빈 곳을 주도적으로 채우기</li>
<li>글쓰기, 문서화를 위해 노력하기</li>
</ul>
</li>
<li>부정
<ul>
<li>자신이 한 일을 잘 설명 못하는 사람</li>
<li>나의 기여도를 부풀리는 경우</li>
</ul>
</li>
</ul>
<p><a href="https://baek.dev/post/2/" target="_blank" rel="noopener noreferrer">개발자 이력서 작성 방법 - 99콘 이력서 후기<i>Content not supported</i></a></p>
]]></content:encoded>
    </item>
    <item>
      <title>0405 - 0411</title>
      <link>ahnjs/TIL/2021/0405/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0405/</guid>
      <source url="ahnjs/TIL/rss.xml">0405 - 0411</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0405-0411"> 0405 - 0411</h1>
<h2 id="_0405-jpa-auditing"> 0405 - JPA Auditing</h2>
<blockquote>
<p>생성시간/수정시간 자동화</p>
</blockquote>
<h4 id="enablejpaauditing"> @EnableJpaAuditing</h4>
<ul>
<li>JPA Auditing 활성화</li>
</ul>
<div><pre><code><span>@EnableJpaAuditing</span>
<span>@SpringBootApplication</span>
<span>public</span> <span>class</span> <span>Application</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="mappedsuperclass"> @MappedSuperclass</h4>
<ul>
<li>JPA Entity 클래스들이 해당 추상 클래스를 상속할 경우 상위 컬럼들을 인식</li>
</ul>
<h4 id="entitylisteners-auditingentitylistener-class"> @EntityListeners(AuditingEntityListener.class)</h4>
<ul>
<li>해당 클래스에 Auditing 기능을 포함</li>
</ul>
<div><pre><code><span>@Getter</span>
<span>@EntityListeners</span><span>(</span><span>AuditingEntityListener</span><span>.</span><span>class</span><span>)</span>
<span>@MappedSuperclass</span>
<span>public</span> <span>abstract</span> <span>class</span> <span>BaseEntity</span> <span>{</span>
    <span>@JsonFormat</span><span>(</span>pattern <span>=</span> <span>"yyyy-MM-dd hh:mm:ss"</span><span>)</span>
    <span>@CreatedDate</span>
    <span>@Column</span><span>(</span>name <span>=</span> <span>"created_at"</span><span>,</span> columnDefinition <span>=</span> <span>"timestamp with time zone"</span><span>,</span> updatable <span>=</span> <span>false</span><span>)</span>
    <span>private</span> <span>LocalDateTime</span> createdAt<span>;</span>

    <span>@JsonFormat</span><span>(</span>pattern <span>=</span> <span>"yyyy-MM-dd hh:mm:ss"</span><span>)</span>
    <span>@LastModifiedDate</span>
    <span>@Column</span><span>(</span>name <span>=</span> <span>"updated_at"</span><span>,</span> columnDefinition <span>=</span> <span>"timestamp with time zone"</span><span>)</span>
    <span>private</span> <span>LocalDateTime</span> updatedAt<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="createddate"> @CreatedDate</h4>
<ul>
<li>Entity 생성 저장시 시간 자동저장</li>
</ul>
<h4 id="lastmodifieddate"> @LastModifiedDate</h4>
<ul>
<li>Entity의 값 변경시 시간 자동저장</li>
</ul>
<br>
<h2 id="_0406-restcontroller-exceptionhandler"> 0406 - @RestController &amp; @ExceptionHandler</h2>
<h4 id="exceptonhandler"> @ExceptonHandler</h4>
<blockquote></blockquote>
<div><pre><code>
    <span>@ExceptionHandler</span><span>(</span><span>NullPointerException</span><span>.</span><span>class</span><span>)</span>
    <span>public</span> <span>String</span> <span>nullex</span><span>(</span><span>Exception</span> e<span>)</span> <span>{</span> 
        <span>return</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>ExceptionHandler의 매치 범위를 결정 할 수 있다.<br>
<code>@ExceptionHandler(NullPointerException.class)</code></li>
</ul>
<h4 id="controlleradvice"> @ControllerAdvice</h4>
<blockquote>
<p>@ExceptionHandler, @ModelAttribute, @InitBinder 가 적용된 메서드들을 AOP를 적요해 컨트롤러 단에 적용하기 위해 고안된 애너테이션</p>
</blockquote>
<h4 id="restcontrolleradvice"> @RestControllerAdvice</h4>
<blockquote>
<p>@ResponseBody + @ControllerAdvice : @RestControllerAdvice</p>
</blockquote>
<ul>
<li>@RestControllerAdvice와 @ExceptonHandler를 사용해 컨트롤러 전역으로 예외처리가 가능하다.</li>
</ul>
<br>
<h2 id="_0407-rc-local-service"> 0407 - rc-local.service</h2>
<blockquote>
<p>Centos 7 부팅시 명령어 자동실행</p>
</blockquote>
<h4 id="rc-local-파일"> rc.local 파일</h4>
<ul>
<li><code>/etc/rc.d/rc.local</code></li>
<li>rc.local 실행 권한 허용<br>
<code>chmod +x /etc/rc.d/rc.local</code></li>
</ul>
<h4 id="실행-스크립트-추가"> 실행 스크립트 추가</h4>
<ul>
<li><code>vi /etc/rc.d/rc.local</code></li>
</ul>
<div><pre><code><span>#!/bin/sh</span>

<span>touch</span> /var/lock/subsys/local
<span>su</span> - user -c /home/app/run.sh
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="서비스설정"> 서비스설정</h4>
<ul>
<li>
<p>상태확인<br>
<code>systemctl status rc-local.service</code></p>
</li>
<li>
<p>실행<br>
<code>systemctl start rc-local.service</code></p>
</li>
<li>
<p>서비스 enable 처리<br>
<code>vi /usr/lib/systemd/system/rc-local.service</code></p>
</li>
<li>
<p>스크립트 추가</p>
</li>
</ul>
<div><pre><code><span>[</span>Install<span>]</span>
<span>WantedBy</span><span>=</span>multi-user.target
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="확인"> 확인</h3>
<p><code>systemctl enable rc-local.service</code><br>
<code>systemctl status rc-local.service</code><br>
<code>systemctl list-unit-files | grep rc-local</code></p>
<br>
<h2 id="_0408-yaml"> 0408 - Yaml</h2>
<blockquote>
<p>Yaml Ain't Markup Language</p>
</blockquote>
<h4 id="vs-properties"> vs Properties</h4>
<ul>
<li>Properties</li>
</ul>
<div><pre><code><span>example.jdbc.url</span><span>=</span><span>127.0.0.1 </span>
<span>example.jdbc.port</span><span>=</span><span>3306 </span>
<span>example.jdbc.user</span><span>=</span><span>user </span>
<span>example.jdbc.password</span><span>=</span><span>password</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>yaml</li>
</ul>
<div><pre><code><span>example</span><span>:</span> 
  <span>jdbc</span><span>:</span> 
    <span>url</span><span>:</span> 127.0.0.1 
    <span>port</span><span>:</span> <span>3306</span> 
    <span>user</span><span>:</span> user 
    <span>password</span><span>:</span> password
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>=&gt; 계층 구조를 잘 나타냄</p>
<h4 id="vs-json"> vs JSON</h4>
<ul>
<li>JSON</li>
</ul>
<div><pre><code><span>{</span>
  <span>"json"</span><span>:</span> <span>[</span>
    <span>"rigid"</span><span>,</span>
    <span>"better for data interchange"</span>
  <span>]</span><span>,</span>
  <span>"yaml"</span><span>:</span> <span>[</span>
    <span>"slim and flexible"</span><span>,</span>
    <span>"better for configuration"</span>
  <span>]</span><span>,</span>
  <span>"object"</span><span>:</span> <span>{</span>
    <span>"key"</span><span>:</span> <span>"value"</span><span>,</span>
    <span>"array"</span><span>:</span> <span>[</span>
      <span>{</span>
        <span>"null_value"</span><span>:</span> <span>null</span>
      <span>}</span><span>,</span>
      <span>{</span>
        <span>"boolean"</span><span>:</span> <span>true</span>
      <span>}</span><span>,</span>
      <span>{</span>
        <span>"integer"</span><span>:</span> <span>1</span>
      <span>}</span>
    <span>]</span>
  <span>}</span><span>,</span>
  <span>"paragraph"</span><span>:</span> <span>"Blank lines denote\nparagraph breaks\n"</span><span>,</span>
  <span>"content"</span><span>:</span> <span>"Or we\ncan auto\nconvert line breaks\nto save space"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><ul>
<li>yaml</li>
</ul>
<div><pre><code><span>---</span> 
<span># &lt;- yaml supports comments, json does not </span>
<span># did you know you can embed json in yaml? </span>
<span># try uncommenting the next line </span>
<span># { foo: 'bar' } </span>
<span>json</span><span>:</span> 
  <span>-</span> rigid 
  <span>-</span> better for data interchange 
<span>yaml</span><span>:</span> 
  <span>-</span> slim and flexible 
  <span>-</span> better for configuration 
<span>object</span><span>:</span> 
  <span>key</span><span>:</span> value 
  <span>array</span><span>:</span> 
    <span>-</span> <span>null_value</span><span>:</span> 
    <span>-</span> <span>boolean</span><span>:</span> <span>true</span> 
    <span>-</span> <span>integer</span><span>:</span> <span>1</span> 
<span>paragraph</span><span>:</span> <span>></span><span> 
  Blank lines denote </span>
  
  
  paragraph breaks
<span>content</span><span>:</span> <span>|</span><span>-</span> 
  Or we 
  can auto 
  convert line breaks 
  to save space
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="etc"> etc</h3>
<div><pre><code><span>servers</span><span>:</span>
  <span>-</span> www.abc.test.com
  <span>-</span> www.xyz.test.com

<span>external</span><span>:</span> <span>[</span>www.abc.test.com<span>,</span> www.xyz.test.com<span>]</span> 
<span>boolean_flag</span><span>:</span> <span>true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>warrent</span><span>:</span>
  <span>ment</span><span>:</span> <span>></span><span>
  johnber is
  very important</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>=&gt; | 줄바꿈, &gt; 줄바꿈 무시</p>
<br>
<h2 id="_0409-개발자의-평생공부"> 0409 - 개발자의 평생공부</h2>
<ol>
<li>지금 다니고 있는 회사에서 하는 일을 잘하기 위해서 노력하는 것이 가장 좋은 공부다.</li>
<li>회사에서 하는 일과 개인적으로 공부하는 내용을 최대한 근접시키기 위해서 노력하라.</li>
<li>새로운 기술을 익히는 최선의 방법은 스스로 문제를 정의한 다음, 새로운 기술을 이용해서 그 문제를 풀어 보는 것이다. 책을 읽거나 동영상을 보는 것은 그보다 하위수준의 방법이다.</li>
<li>신기술을 쫒는 메뚜기가 되지 말라.</li>
<li>모든 것을 알아야 한다는 강박을 버려라. 미리 획득하는 지식의 99%는 무용지물이다. 필요할 때 필요한 기술을 익힐 수 있는 것이 능력이다. 그 능력을 키워라.</li>
<li>이상한 나라의 엘리스에 나오는 토끼굴을 피해라. 카테고리이론을 알아야 함수형 언어를 쓸 수 있는게 아니고, 선형대수학을 공부해야 머신렁닝을 할 수 있는게 아니다. 토끼굴에 빠져서 한없이 들어가다보면 비본질적인 공부에 시간을 허비하게 된다.</li>
<li>겉만 핥는 것은 경박하지만 토끼굴에 빠지는 것은 우매하다. 둘 사이의 적당한 지점에서 균형을 잡는 것이 개발자의 능력이다.</li>
<li>머리에 들어오지 않는 어려운 개념이나 용어는 자투리 시간을 이용해서 반복적으로 일고 암기하라. 나중에 큰 그림을 공부할 때 도움이 된다.</li>
<li>항상 겸손해야 하지만 동시에 자긍심을 가져라. 그대가 지금 작성한 코드, 지금 읽은 책, 지금 공부한 내용을 그대보다 잘 아는 사람은 지구상에 없다. 모든걸 알고 있는 것처럼 보이는 다른 사람들도 그대와 마찬가지로 불안해하고, 위축되고, 두려워하면서 살아가고 있다. 자긍심이란 그런 타인을 돕고자 하는 마음가짐의 다른 이름이다.</li>
</ol>
<p><a href="https://zdnet.co.kr/view/?no=20170616090644" target="_blank" rel="noopener noreferrer">원글:개발자의 평생공부<i>Content not supported</i></a></p>
<br>
<h2 id="_0410-내-포트-폴리오가-서류탈락인-이유"> 0410 - 내 포트 폴리오가 서류탈락인 이유</h2>
<h4 id="프로젝트-자가진단"> 프로젝트 자가진단</h4>
<blockquote>
<p>앞으로 방향성에 대한 진단</p>
</blockquote>
<ul>
<li>실제 서비스를 공개적으로 배포하고 운영해보는 경험</li>
<li>유저의 피드백에 따라 성능/사용성을 개선하고 신규 기능을 추가</li>
<li>발견되는 버그와 개선사항을 정리하고 쌓인 이슈들을 체계적으로 관리</li>
<li>코드를 지속적으로 리펙토링하고 디자인패턴을 적용하기</li>
<li>위의 시도에서 더 좋은 설계와 더 빠른 개발 사이의 트레이드오프를 고민해보기</li>
<li>반복되는 수정과 배포에 수반되는 작업들을 자동화해보기</li>
<li>언어나 프레임워크의 기능만으로 구현 할 수 없는 것들을 직접 구현해보기</li>
<li>내가 사용한 라이브러리나 프레임워크의 문제점이나 한계를 개선해보기</li>
<li>코드나 제품의 퀄리티를 유지하기 위한 분석툴이나 테스트툴을 도입해보기</li>
<li>타인과의</li>
</ul>
<h4 id="결론"> 결론</h4>
<p>여러 언어와 프레임워크를 급하게 익혀서 이거저거 토이프로젝트를 찍어내는 것도 좋지만, 프로젝트를 실제로 운영해보고 고도화 하고 확장해나가는 경험도 중요하다. 이를 위해 수반되어야 할 작업들을 직접 알아가며 도입해보는 경험도 필요하다.</p>
<p><a href="https://cafe.naver.com/pseudodev/25" target="_blank" rel="noopener noreferrer">원글:내 포트폴리오가 서류탈락인 이유 - 프로젝트 이렇게 해보세요<i>Content not supported</i></a></p>
]]></content:encoded>
    </item>
    <item>
      <title>0412 - 0418</title>
      <link>ahnjs/TIL/2021/0412/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0412/</guid>
      <source url="ahnjs/TIL/rss.xml">0412 - 0418</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0412-0418"> 0412 - 0418</h1>
<h2 id="_0412-프로그래밍-에러-종류"> 0412 - 프로그래밍 에러 종류</h2>
<h4 id="_1-컴파일-에러-compillation-error"> 1. 컴파일 에러(Compillation Error)</h4>
<p>문법 오류로 인해 컴파일러가 이해할 수 없는 코드가 있을 때 발생하는 오류</p>
<ul>
<li>컴파일러가 발견</li>
<li>컴파일 작업 시 발견</li>
<li>컴파일러가 에러 메시지 출력</li>
<li>난이도 낮음. 수정 쉬움</li>
<li>문법 틀림</li>
</ul>
<h4 id="_2-런타임-에러-runtime-error"> 2. 런타임 에러(Runtime Error)</h4>
<p>설계 미숙이나 기계적 결함으로 인해 실행 중 수행할 수 없는 작업을 시도할 때 발생하는 오류</p>
<ul>
<li>프로그램 실행중</li>
<li>문법적으로 에러가 아님</li>
<li>예외</li>
<li>발생빈도 높음</li>
<li>발견 어렵다. 수정 어려움</li>
<li>JRE(VM) : 에러 메시지 출력</li>
<li>베타테스트를 통해서 잡는 경우</li>
</ul>
<h4 id="_3-논리-에러-logic-error"> 3. 논리 에러(Logic Error)</h4>
<p>컴파일 및 실행은 되지만, 결과가 예상과 달라 사용자가 의도한 작업을 수행하지 못하는 오류 알고리즘이 틀린 것이므로 에러 메세지가 나오지 않아 해결이 어려움</p>
<ul>
<li>발견 가장 어렵다</li>
<li>에러 메시지가 없다</li>
</ul>
<br>
<h2 id="_0413-val-let-const-차이점"> 0413 - val, let, const 차이점</h2>
<blockquote>
<p>Javascript 변수 선언 방식</p>
</blockquote>
<h4 id="변수-선언-방식"> 변수 선언 방식</h4>
<ul>
<li>var : 변수 재선언 가능</li>
<li>let : 변수 재선언 불가능</li>
<li>const : 변수 재선언, 변수 재할당 모두 불가능</li>
</ul>
<h4 id="호이스팅"> 호이스팅</h4>
<blockquote>
<p>호이스팅(Hoisting)이란, var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성</p>
</blockquote>
<ul>
<li>변수의 생성<br>
<code>선언 단계</code> &gt; <code>초기화 단계</code> &gt; <code>할당 단계</code>
<ul>
<li>var : 선언 단계 + 초기화 단계</li>
<li>let : 선언 단계 &gt; 초기화 단계</li>
</ul>
</li>
</ul>
<h4 id="결과"> 결과</h4>
<p><img src="https://user-images.githubusercontent.com/49400801/114558716-ede9ee00-9ca5-11eb-915b-fc91d3d5dc1a.png" alt="표"></p>
<br>
<h2 id="_0414-시간복잡도-vs-공간-복잡도"> 0414 - 시간복잡도 vs 공간 복잡도</h2>
<h4 id="시간-복잡도와-공간-복잡도"> 시간 복잡도와 공간 복잡도</h4>
<blockquote>
<p>알고리즘을 평가하는데 있어 수행시간과 메모리 사용량을 평가 기준으로 두는데 수행시간에 해당하는 것이 시간 복잡도, 메모리 사용량에 해당하는 것이 공간 복잡도이다.</p>
</blockquote>
<ul>
<li>시간 복잡도(Time Complexity) : 알고리즘의 수행시간 분석결과</li>
<li>공간 복잡도(Space Complexity) : 알고리즘 메모리 사용량에 대한 분석결과</li>
</ul>
<p><strong>간단하게 말하면 알고리즘 성능평가는 시간복잡도와 공간 복잡도를 계산하고 점근적 표기법으로 나타내면 된다.</strong></p>
<h4 id="빅오-표기법"> 빅오 표기법</h4>
<p><code>O(1) &lt; O(log n) &lt; O(n) &lt; O(nlog n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!)</code></p>
<ul>
<li>보통 O(n^2)이상의 복잡도를 가지는 알고리즘은 좋지 않다.</li>
</ul>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=http%3A%2F%2Fcfile28.uf.tistory.com%2Fimage%2F260F4850559AB6672C45F1" alt="빅오"></p>
<br>
<h2 id="_0416-okky-미니세미나-비전공-학원출신-si개발자-유명스타트업-들어간-ssul"> 0416 - OKKY 미니세미나 &lt;비전공 학원출신 SI개발자, 유명스타트업 들어간.ssul&gt;</h2>
<blockquote>
<p>배우고 싶은점이나 실천하고 싶은 행동들을 옮겨 적는다.</p>
</blockquote>
<h4 id="개선하기-위한-노력"> 개선하기 위한 노력</h4>
<ul>
<li>효율적인 시간 활용관리
<ol>
<li>규칙적인 생활 (취침시간 10시 30분)</li>
<li>밥먹을때는 동영상 강의를 봄</li>
</ol>
</li>
<li>공부 방향
<ol>
<li>일을 하면서 모르거나, 더 알고 싶은 KEYWORD를 정리하고 반드 시 찾아봄</li>
<li>독서를 매우 중요시 함</li>
</ol>
<ul>
<li>독서방법
하루에 3가지 종류의 책을 조금씩 읽고, 요약
<ul>
<li>집에서 : 각 잡고 읽을만한 것</li>
<li>지하철에서 : 재미있으며 얇은 책</li>
<li>학원/회사에서 틈틈이 : 회사업무에 도움이 될것 같은 표지이면서 나에게 도움이 되는책</li>
</ul>
</li>
</ul>
</li>
<li>기타
<ol>
<li>개발자는 마인드가 중요하다. 불법 소프트웨어 절대 사용금지</li>
<li>운동을 꾸준히하자</li>
<li>항상 플랜 B를 계획하자</li>
<li>일상 생활에서도 최적화를 고민한다.</li>
<li>모든일의 마무리는 요약하고 정리하는 것.</li>
</ol>
</li>
</ul>
<p><a href="https://jojoldu.tistory.com/247" target="_blank" rel="noopener noreferrer">원글:OKKY 미니세미나<i>Content not supported</i></a></p>
<br>
<h2 id="_0417-localdate-localdatetime-localdatetime"> 0417 - LocalDate, LocalDateTime, LocalDateTime</h2>
<p><strong>Java version 8이상</strong></p>
<h4 id="java-시간-api-시대-흐름순"> Java 시간 API 시대 흐름순</h4>
<p><code>java.util.Date &gt; java.util.Calendar &gt; java.time(org.joda.time)</code></p>
<h4 id="localdate-localtime"> LocalDate, LocalTime</h4>
<blockquote>
<p>LocalDate : 날짜정보<br>
locaTime : 시간 정보</p>
</blockquote>
<h4 id="localdatetime"> LocalDateTime</h4>
<blockquote>
<p>날짜와 시간 정보 둘다</p>
</blockquote>
<ul>
<li>문법</li>
</ul>
<div><pre><code><span>LocalDateTime</span> now <span>=</span> <span>LocalDateTime</span><span>(</span><span>)</span><span>;</span>
<span>// 결과 : 2021-04-17T16:34:30.388</span>
<span>LocalDateTime</span> target <span>=</span> <span>LocalDateTime</span><span>.</span><span>of</span><span>(</span><span>2021</span><span>,</span> <span>4</span><span>,</span> <span>17</span><span>,</span> <span>12</span><span>,</span> <span>32</span><span>,</span><span>22</span><span>,</span><span>3333</span><span>)</span><span>;</span>
<span>// 결과 : 2021-04-17T12:32:22.000003333</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>변환 예제</li>
</ul>
<div><pre><code><span>// LocalDateTime to String</span>
<span>LocalDateTime</span><span>.</span><span>now</span><span>(</span><span>)</span><span>.</span><span>format</span><span>(</span><span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>)</span><span>;</span>

<span>// String to LocalDateTime</span>
<span>LocalDateTime</span><span>.</span><span>parse</span><span>(</span><span>"2021-04-17 12:33:00"</span><span>,</span> <span>DateTimeFormatter</span><span>.</span><span>ofPattern</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><br>
<h2 id="_0418-스프링부트-mvc-정적-리소스"> 0418 - 스프링부트/MVC 정적 리소스</h2>
<h4 id="정적-리소스-설정-커스터마이징-webconfigurer"> 정적 리소스 설정 커스터마이징 WebConfigurer</h4>
<blockquote>
<p>WebMvcConfigurer를 구현하는 클래스에서 addResourceHandlers를 override하여 정적 리소스 핸들러를 커스터마이징 할 수 있다.<br>
이 방법을 사용하면 스프링 부트가 제공하는 정적 리소스 핸들러는 그대로 사용하면서 커스텀 핸들러가 추가된다.</p>
</blockquote>
<div><pre><code><span>@Configuration</span>
<span>public</span> <span>class</span> <span>WebConfig</span> <span>implements</span> <span>WebMvcConfigurer</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>void</span> <span>addResourceHandlers</span><span>(</span><span>ResourceHandlerRegistry</span> registry<span>)</span> <span>{</span>
        registry<span>.</span><span>addResourceHandler</span><span>(</span><span>"/경로/**"</span><span>)</span>
                <span>.</span><span>addResourceLocations</span><span>(</span><span>"classpath:/경로/"</span><span>)</span>
                <span>// 캐싱 전략 설정(초 단위)</span>
                <span>.</span><span>setCachePeriod</span><span>(</span><span>20</span><span>)</span>
                <span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>]]></content:encoded>
      <enclosure url="https://user-images.githubusercontent.com/49400801/114558716-ede9ee00-9ca5-11eb-915b-fc91d3d5dc1a.png" type="image/png"/>
    </item>
    <item>
      <title>0503 - 0509</title>
      <link>ahnjs/TIL/2021/0503/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0503/</guid>
      <source url="ahnjs/TIL/rss.xml">0503 - 0509</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0503-0509"> 0503 - 0509</h1>
<h2 id="_0503-git-자가점검"> 0503 - git 자가점검</h2>
<h3 id="git-자가점검"> git 자가점검</h3>
<h4 id="버전-관리하기"> 버전 관리하기</h4>
<div><pre><code>✅ 사용자의 아이디/이메일을 설정할 수 있는가?
    git config user.name 아이디
    git config user.email 이메일주소
    -local, -global
✅ 사용자의 아이디/이메일을 삭제할 수 있는가?
✅ 해당 디렉토리를 깃 저장소로 만들 수 있는가? 
    git init
✅ 해당 디렉토리의 상태를 확인할 수 있는가?
    git status
✅ 로그를 확인할 수 있는가?
    git log
✅ 스테이징을 할 수 있는가?
    git add 파일이름.확장자
✅ 커밋을 할 수 있는가? 
    git commit -m &quot;message&quot;
✅ 스테이징과 커밋을 한 번에 할 수 있는가?
    git commit -am &quot;message&quot;
✅ 커밋/스테이징을 취소할 수 있는가?
    git reset HEAD^
✅ 작업 트리에서의 수정 내역도 삭제할 수 있는가? 
    git restore 파일이름.확장자
    git checkout 파일이름.확장자
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h4 id="branch"> branch</h4>
<div><pre><code>✅ (해당 저장소 내에서) 브랜치를 확인할 수 있는가? 
    git branch
✅ 브랜치를 생성할 수 있는가?
    git branch 브런치
✅ 커밋 내역을 확인할 수 있는가? 
    git log --oneline
✅ 브랜치 로그 그래프를 확인할 수 있는가?
    git log --oneline --branches --graph
✅ 브랜치를 이동할 수 있는가?
    git checkout 해당브런치
✅ master 브랜치에 브랜치를 병합할 수 있는가?
    git merge 병합 대상 브런치
✅ 충돌을 해결할 수 있는가?
    직접 충돌 해결, 파일 수정 후 커밋
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="remote-저장소"> remote 저장소</h4>
<div><pre><code>✅ 깃과 깃허브의 차이점을 아는가?
    git : 분산 버전 관리 시스템
    github : git을 지원하는 플랫폼
✅ 로컬 저장소와 원격 저장소를 연결할 수 있는가?
    git remote add origin 원격주소
✅ 원격 저장소와 연결된 것을 확인할 수 있는가?
    git remote -v
✅ 로컬 저장소에서 원격 저장소로 push할 수 있는가?
    git push origin 브런치
✅ 원격 저장소에서 로컬 저장소로 pull할 수 있는가?
    git pull origin master
    git pull
✅ 로컬 저장소에서 만든 브랜치를 원격 저장소에 반영할 수 있는가?
✅ 원격 저장소의 브랜치를 로컬 저장소로 가져올 수 있는가?
    git pull
    git checkout -b 변경대상 브런치 원래 브런치
    git checkout -t 원래 원격 브런치
✅ pull과 fetch와 merge의 차이점을 아는가? 
    pull == fetch + merge
    =&gt; git fetch =&gt; git checkout FETCH_HEAD =&gt; git merge FETCH_HEAD
✅ pull-request를 할 수 있는가?
    github
✅ 원격 저장소를 복제해 로컬 저장소로 가져올 수 있는가?
    git clone 주소
✅ fork에 대해 이해했는가? 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><br>
<h2 id="_0504-jpa로-인덱스-사용"> 0504 - JPA로 인덱스 사용</h2>
<h3 id="jpa로-인덱스-사용"> JPA로 인덱스 사용</h3>
<blockquote>
<p>데이터베이스 조건문 조회시, 테이블 전체를 full scan, 비효율적
인덱스 테이블 활용(B-Tree 자료구조)<br>
O(n) =&gt; O(logn) 시간복잡도</p>
</blockquote>
<div><pre><code><span>@NoArgsConstructor</span><span>(</span>access <span>=</span> PROTECTED<span>)</span>
<span>@AllArgsConstructor</span>
<span>@Getter</span>
<span>@ToString</span>
<span>@EqualsAndHashCode</span><span>(</span>of <span>=</span> <span>"userSeq"</span><span>)</span>
<span>@DynamicUpdate</span>
<span>@Entity</span>
<span>@Table</span><span>(</span>name <span>=</span> <span>"users"</span><span>,</span>
        <span>// 인덱스 설정</span>
       indexes <span>=</span> <span>{</span>
               <span>@Index</span><span>(</span>name <span>=</span> <span>"users_email_idx"</span><span>,</span> unique <span>=</span> <span>true</span><span>,</span> columnList <span>=</span> <span>"email"</span><span>)</span><span>,</span>
               <span>@Index</span><span>(</span>name <span>=</span> <span>"users_nickname_idx"</span><span>,</span> unique <span>=</span> <span>true</span><span>,</span> columnList <span>=</span> <span>"nickname"</span><span>)</span><span>,</span>
               <span>@Index</span><span>(</span>name <span>=</span> <span>"users_user_type_idx"</span><span>,</span> columnList <span>=</span> <span>"user_type"</span><span>)</span><span>,</span>
               <span>@Index</span><span>(</span>name <span>=</span> <span>"user_deleted_active_idx"</span><span>,</span> columnList <span>=</span> <span>"deleted,active"</span><span>)</span>
       <span>}</span>
<span>)</span>
<span>public</span> <span>class</span> <span>Users</span> <span>extends</span> <span>BaseEntity</span> <span>{</span>

    <span>@Id</span>
    <span>@GeneratedValue</span><span>(</span>strategy <span>=</span> IDENTITY<span>)</span>
    <span>@Column</span><span>(</span>name <span>=</span> <span>"user_seq"</span><span>,</span> updatable <span>=</span> <span>false</span><span>,</span> nullable <span>=</span> <span>false</span><span>)</span>
    <span>private</span> <span>Long</span> userSeq<span>;</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>결론
데이터 조회시 속도에 영향을 미치지만<br>
인덱스를 과도하게 설정시 자체만으로 메모리 공간을 많이 차지하고, 테이블이 변경될 때마다 인덱스 정렬 순서도 매번 수정이 되어야하므로 비효율을 낳는다.</p>
<p>복합인덱스 사용시 갯수는 3~4개가 적당하면 인덱스를 고를때에는 카디널리티가 높은 순서대로 고르는게 효율적이다.</p>
<p>B-Tree는 LIKE 검색으로 중간일치, 후방일치 검색을 할 수 없기 때문에 전방탐색(full-text)이 아니라면, 엘라스틱서치나 다른 방식으로 검색의 효율을 높이는게 좋다.</p>
<br>
<h2 id="_0505-jpa-특정-type-정의"> 0505 - JPA 특정 type 정의</h2>
<h3 id="jpa-특정-type-정의"> JPA 특정 type 정의</h3>
<h4 id="spring-data-jpa-기반이-되는-hibernate의-type을-추가하기-위하여-vladmihalcea의-hibernate-types를-추가"> Spring Data JPA 기반이 되는 Hibernate의 type을 추가하기 위하여 <code>vladmihalcea의 hibernate-types</code>를 추가</h4>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
    <span><span><span>&lt;</span>groupId</span><span>></span></span>com.vladmihalcea<span><span><span>&lt;/</span>groupId</span><span>></span></span>
    <span><span><span>&lt;</span>artifactId</span><span>></span></span>hibernate-types-52<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
    <span><span><span>&lt;</span>version</span><span>></span></span>2.10.1<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="typedef-추가"> TypeDef 추가</h4>
<ul>
<li>jsonb</li>
</ul>
<div><pre><code><span>package</span> <span>me<span>.</span>oofbird<span>.</span>jpa</span>

<span>import</span> <span>org<span>.</span>hibernate<span>.</span>annotations<span>.</span></span><span>TypeDef</span><span>;</span> 
<span>import</span> <span>com<span>.</span>vladmihalcea<span>.</span>hibernate<span>.</span>type<span>.</span>json<span>.</span></span><span>JsonBinaryType</span><span>;</span> 

<span>import</span> <span>javax<span>.</span>persistence<span>.</span></span><span>*</span><span>;</span> 

<span>@Entity</span> 
<span>@Table</span><span>(</span>name <span>=</span> <span>"TB_TEST"</span><span>)</span> 
<span>@TypeDef</span><span>(</span>
    name <span>=</span> <span>"jsonb"</span><span>,</span> 
    typeClass <span>=</span> <span>JsonBinaryType</span><span>.</span><span>class</span><span>)</span> 
<span>public</span> <span>class</span> <span>TestTable</span> <span>{</span> 
    <span>.</span><span>.</span><span>.</span>
    <span>@Type</span><span>(</span>type <span>=</span> <span>"jsonb"</span><span>)</span> 
    <span>@Column</span><span>(</span>name <span>=</span> <span>"JSON_TEXT"</span><span>,</span> columnDefinition <span>=</span> <span>"jsonb"</span><span>)</span> 
    <span>private</span> <span>JsonPOJOObject</span> jsonText<span>;</span> 
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><ul>
<li>list-array</li>
</ul>
<div><pre><code><span>@Entity</span>
<span>@Table</span><span>(</span>name <span>=</span> <span>"TB_TEST"</span><span>)</span> 
<span>@TypeDef</span><span>(</span>
    name <span>=</span> <span>"list-array"</span><span>,</span>
    typeClass <span>=</span> <span>ListArrayType</span><span>.</span><span>class</span>
<span>)</span>
<span>public</span> <span>class</span> <span>TestTable</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>@Type</span><span>(</span>type <span>=</span> <span>"list-array"</span><span>)</span>
    <span>@Column</span><span>(</span>name <span>=</span> <span>"LIST-ARRAY"</span><span>,</span> columnDefinition <span>=</span> <span>"int[]"</span><span>)</span>
    <span>private</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> listText <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><br>
<h2 id="_0506-파일속-문자열-찾기"> 0506 - 파일속 문자열 찾기</h2>
<blockquote>
<p><code>grep [option] pattern [file]</code></p>
</blockquote>
<h3 id="옵션"> 옵션</h3>
<ul>
<li>-c : 매칭된 검색 결과를 출력하지 않고 매칭된 행의 총 라인 수를 출력한다.</li>
<li>-i : 매칭에 사용하는 문자의 대소문자를 구분하지 않는다.</li>
<li>-l : 패턴에 매칭된 라인이 하나라도 있는 파일의 이름만을 출력한다.</li>
<li>-n : 파일 내에서 매칭된 행 번호를 함께 출력한다.</li>
<li>-s : 에러 메시지 외에는 출력하지 않는다.</li>
<li>-v : 패턴과 매칭되지 않는 행만 출력한다.</li>
<li>-w : &lt;와 &gt;로 둘러싸인 패턴표현을 하나의 단어로 취급하여 검색한다.</li>
</ul>
<h3 id="정규표현식-메타-문자"> 정규표현식 메타 문자</h3>
<ul>
<li>^ : 행의 시작 지시자 ex) ^joon : joon으로 시작하는 모든 행을 출력함</li>
<li>$ : 행의 끝 지시자  ex) joon$ : joon으로 끝나는 모든 행을 출력함.</li>
<li>. : 하나의 문자와 대응<br>
ex) j..n : 총 4개의 문자로 이루어진 문자열 중에 처음 문자는 j 끝문자는 n으로 끝나는 문자의 행을 출력함</li>
<li>* : 매칭되는 문자가 없거나 하나 이상의 문자에 대해 매칭 ex)joo* : joo, joon, jooo, jood, joon0312 전부 매칭</li>
<li>[] : [ ]안에 문자 중 어떤 하나라도 매칭  ex) joo[n,d,o] : joon, jood, jooo 매칭</li>
</ul>
<br>
<h2 id="_0507-java11"> 0507 - Java11</h2>
<h3 id="oracle-java-support-roadmap"> Oracle Java Support RoadMap</h3>
<p><img src="https://user-images.githubusercontent.com/49400801/117472491-e7445300-af93-11eb-9387-48f5f9524c8f.png" alt="roadmap"></p>
<h3 id="_1-람다-파라미터를-위한-지역변수-표현"> 1. 람다 파라미터를 위한 지역변수 표현</h3>
<p><code>java 10버전에서 편리한 var 구문이 생겨난 상황</code>에서, 11버전에서는 람다 파라미터에서 var를 이용 할 수 있게 됨</p>
<div><pre><code>list<span>.</span><span>stream</span><span>(</span><span>)</span>
    <span>.</span><span>map</span><span>(</span><span>(</span><span>@NotNull</span> <span>var</span> s<span>)</span> <span>-></span> s<span>.</span><span>toLowerCase</span><span>(</span><span>)</span><span>)</span>
    <span>.</span><span>collect</span><span>(</span><span>Collectors</span><span>.</span><span>toList</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_2-http-client-standard"> 2. HTTP Client (Standard)</h3>
<ul>
<li>Non-Blocking request and response 지원 (with CompletableFuture)</li>
<li>Backpressure 지원(java.util.concurrent.Flow 패키지를 통해 Rx Flow를 구현체에 적용)</li>
<li>Factory method 형태로 지원</li>
<li>HTTP/2 지원</li>
<li>Sptring5에서는 Rest Client에 RestTemplate 대신 WebClient를 사용하여 비동기 구현 가능.<br>
=&gt; 기존 멀티쓰레드 방식을 버리고 Reactor(WebFlux) 와 함께 스프링 기반 웹서비스를 구현할 경우 그에 따른  성능과 효율 향상은 어마어마 합니다.</li>
</ul>
<h3 id="_3-모듈"> 3. 모듈</h3>
<ul>
<li>메모리 공간을 더 적게 사용</li>
<li>특히 마이크로서비스 아키텍처에서 유용</li>
<li>런타임이 더 작아지고, 더가벼워져서 더 빠르게 시작</li>
<li>강력한 캡슐화를 적용</li>
</ul>
<h3 id="_4-프로파일링-및-진단"> 4. 프로파일링 및 진단</h3>
<h4 id="java-flight-recorder"> Java Flight Recorder</h4>
<p>실행 중인 Java 애플리케이션에서 진단 및 프로파일링 데이터 수집, Java 11에서는 둘다 오픈 소스</p>
<h4 id="java-mission-control"> Java Mission Control</h4>
<ul>
<li>JFR 및 JMC를 사용하면 메모리 누수, GC 오버헤드, 핫 메서드 스레드 병목 상태 및 I/O 블로킹과 같은 런타임 문제를 진단</li>
</ul>
<h4 id="통합-로깅"> 통합 로깅</h4>
<h4 id="오버헤드가-낮은-힙-프로파일링"> 오버헤드가 낮은 힙 프로파일링</h4>
<h4 id="stackwalker"> StackWalker</h4>
<h3 id="_5-가비지-수집"> 5. 가비지 수집</h3>
<ul>
<li>Java 11의 기본 가비지 수집기는 G1GC(가비지 우선 가비지 수집기)</li>
<li>ZGC는 일시 중지 시간을 10ms 미만으로 유지하려고 하는 대기 시간이 짧은 동시 수집기</li>
</ul>
<h4 id="엡실론"> 엡실론</h4>
<blockquote>
<p>엡실론 가비지 수집기 할당만을 처리하며 메모리를 회수하지않는다. 힙이 소진되면 JVM이 종료</p>
</blockquote>
<h4 id="docker-컨테이너의-향상된-기능"> Docker 컨테이너의 향상된 기능</h4>
<p>Java 10부터 JVM은 컨테이너 제어 그룹(cgroup)에 의해 설정된 제약 조건을 사용</p>
<h3 id="_6-성능-향상"> 6. 성능 향상</h3>
<br>
<h2 id="_0508-맥-터미널에서-aws-ec2-터미널-접속"> 0508 - 맥 터미널에서 AWS EC2 터미널 접속</h2>
<h3 id="키파일-퍼미션-변경"> 키파일 퍼미션 변경</h3>
<div><pre><code>$ <span>chmod</span> <span>400</span> 경로/keyfile.pem
</code></pre>
<div><span>1</span><br></div></div><h3 id="터미널에서-키파일-옵션을-추가한-명령으로-ssh-접속"> 터미널에서 키파일 옵션을 추가한 명령으로 ssh 접속</h3>
<div><pre><code>$ <span>ssh</span> -i 경로/keyfile.pem ec2-user@<span>[</span>서버 아이피 또는 도메인<span>]</span>
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_0509-junit5-사용"> 0509 - jUnit5 사용</h2>
<h3 id="의존성-gradle"> 의존성(gradle)</h3>
<div><pre><code>dependencies {
    testCompile(&#39;org.junit.jupiter:junit-jupiter:5.7.1&#39;)
    testCompile(&#39;org.assertj:assertj-core:3.19.0&#39;)
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="예제"> 예제</h3>
<div><pre><code><span>class</span> <span>RefereeTest</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> ANSWER <span>=</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
    <span>private</span> <span>Referee</span> referee<span>;</span>

    <span>@BeforeEach</span>
    <span>void</span> <span>setUp</span><span>(</span><span>)</span> <span>{</span>
        referee <span>=</span> <span>new</span> <span>Referee</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>@ParameterizedTest</span>
    <span>@CsvSource</span><span>(</span><span>{</span><span>"1,2,3,0 볼 3 스트라이크"</span><span>,</span> <span>"3,1,2,3 볼 0 스트라이크"</span><span>,</span> <span>"1,3,2,2 볼 1 스트라이크"</span><span>,</span> <span>"7,8,9,아웃"</span><span>}</span><span>)</span>
    <span>public</span> <span>void</span> <span>compare</span><span>(</span><span>int</span> number1<span>,</span> <span>int</span> number2<span>,</span> <span>int</span> number3<span>,</span> <span>String</span> expected<span>)</span> <span>{</span>
        <span>String</span> actual <span>=</span> referee<span>.</span><span>compare</span><span>(</span>ANSWER<span>,</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span>number1<span>,</span> number2<span>,</span> number3<span>)</span><span>)</span><span>;</span>
        <span>assertThat</span><span>(</span>actual<span>)</span><span>.</span><span>isEqualTo</span><span>(</span>expected<span>)</span><span>;</span>
    <span>}</span>

    <span>@Test</span>
    <span>void</span> 스트라이크<span>3</span><span>(</span><span>)</span> <span>{</span>
        <span>String</span> result <span>=</span> referee<span>.</span><span>compare</span><span>(</span>ANSWER<span>,</span> <span>Arrays</span><span>.</span><span>asList</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span>
        <span>assertThat</span><span>(</span>result<span>)</span><span>.</span><span>isEqualTo</span><span>(</span><span>"0 볼 3 스트라이크"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ul>
<li>@Test : 테스트 메소드임을 명시</li>
<li>@ParameterizedTest : 매개변수가 있는 테스트임을 명시</li>
<li>@BeforeEach : 해당 메서드는 현재 테스트 클래스의 각각의 메서드 보다 먼저 실행된다.</li>
<li>@CsvSource : 여러 파라미터를 전달하고자 할 때 사용한다. <code>,</code>로 값을 구분 delimiter 속성을 사용해 사용자 정의 가능</li>
</ul>
]]></content:encoded>
      <enclosure url="https://user-images.githubusercontent.com/49400801/117472491-e7445300-af93-11eb-9387-48f5f9524c8f.png" type="image/png"/>
    </item>
    <item>
      <title>0510 - 0516</title>
      <link>ahnjs/TIL/2021/0510/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0510/</guid>
      <source url="ahnjs/TIL/rss.xml">0510 - 0516</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0510-0516"> 0510 - 0516</h1>
<h2 id="_0510-mac-java-여러버전-설치-jenv-관리"> 0510 - (Mac) Java 여러버전 설치 + jenv 관리</h2>
<h3 id="homebrew-자바-설치"> homebrew 자바 설치</h3>
<ol>
<li>homebrew 업데이트</li>
</ol>
<div><pre><code>$ brew update
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>java 설치</li>
</ol>
<div><pre><code>// 공식 저장소 외에 다른 저장소 사용
$ brew tap adoptopenjdk/openjdk
// --cask 옵션으로 변경
$ brew <span>install</span> adoptopenjdk11 --cask
// 확인
$ brew list --cask
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>설치경로 : <code>/Library/Java/JavaVirtualMachines/</code><br>
설치되어 있는 자바 버전 확인하기 : <code>/usr/libexec/java_home -V</code></p>
<h3 id="jenv"> Jenv</h3>
<h4 id="jenv-커맨드"> Jenv 커맨드</h4>
<div><pre><code>$ jenv versions
$ jenv <span>local</span>
$ jenv global
$ jenv <span>add</span> /Library/Java/JavaVirtualMachines/adoptopenjdk-10.jdk/Contents/Home
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><br>
<h2 id="_0511-mac-postgressql-설치-및-실행"> 0511 - (Mac) PostgresSQL 설치 및 실행</h2>
<h3 id="설치-및-실행"> 설치 및 실행</h3>
<ol>
<li>homebrew 설치</li>
</ol>
<div><pre><code>brew install postgresql
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>실행</li>
</ol>
<div><pre><code>pg_ctl -D /usr/local/var/postgres start &amp;&amp; brew services start postgresql
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>확인</li>
</ol>
<div><pre><code>postgres -V
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_0512-오늘-배운-몇가지-intellij-단축키"> 0512 - 오늘 배운 몇가지 IntelliJ 단축키</h2>
<ul>
<li><code>command + option + m</code> : 일부 코드 메서드로 변환</li>
<li><code>command + n</code> : generate</li>
<li><code>control + option + O</code>: import문 정리</li>
<li><code>cmmand + option + L</code>: 코드 자동 정렬</li>
</ul>
<br>
<h2 id="_0516-spring-security"> 0516 - Spring Security</h2>
<blockquote>
<p>애플리케이션의 보안(인증과 권한, 인가 등)을 담당하는 스프링 하위 프레임워크<br>
'인증'과 '권한'에 대한 부분을 Filter 흐름에 따라 처리</p>
</blockquote>
<h3 id="인증과-인가"> 인증과 인가</h3>
<ul>
<li>인증(Authentication): 해당 사용자가 본인이 맞는지 확인 절차</li>
<li>인가(Authorization): 인증된 사용자가 요청한 자원에 접근 가능한지를 결정하는 절차</li>
</ul>
<p>* 인증과 인가를 위해 Principal, Credential을 사용</p>
<ul>
<li>Principal(접근 주체): 보호받는 Resource에 접근하는 대상</li>
<li>Credential(비밀번호): Resource에 접근하는 대상의 비밀번호</li>
</ul>
<h3 id="주요-모듈"> 주요 모듈</h3>
<ul>
<li>Authentication</li>
<li>SecurityContext</li>
<li>SecurityContextHolder</li>
<li>UsernamePasswordAuthenticationToken</li>
<li>AuthenticationProvider</li>
<li>AuthenticatonManager</li>
<li>UserDetails</li>
<li>UserDetailsService</li>
<li>Password Encoding</li>
<li>GrantedAuthority</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0517 - 0523</title>
      <link>ahnjs/TIL/2021/0517/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0517/</guid>
      <source url="ahnjs/TIL/rss.xml">0517 - 0523</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0517-0523"> 0517 - 0523</h1>
<h2 id="_0518-jwt-json-web-token"> 0518 - JWT(Json Web Token)</h2>
<blockquote>
<p>Json 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token이다.<br>
토큰 자체를 정보로 사용하는 Self-Contained 방식<br>
토큰 기반의 인증시스템에서 주로 사용한다.</p>
</blockquote>
<h3 id="구조"> 구조</h3>
<div><pre><code>HEADER.PAYLOAD.SIGNATURE
</code></pre>
<div><span>1</span><br></div></div><p>헤더(Header), 페이로드(Payload), 서명(Signature) 세부분을 점으로 구분하는 구조</p>
<ul>
<li>
<p>Header : typ과 alg 정보로 구성. Signature를 해싱하기 위한 알고리즘 지정</p>
<ul>
<li>typ : 토큰의 타입을 지정 ex) JWT</li>
<li>alg : 알고리즘 방식을 지정하며, 서명(Signature) 및 토큰 검증에 사용 ex) HS256(SHA256) 또는 RSA</li>
</ul>
</li>
<li>
<p>PAYLOAD : 토큰에서 사용할 정보의 조각들인 클레임(Claim)을 담는다. 클레임은 총 3가지로 나누어지며, Json(Key/Value) 형태</p>
<ol>
<li>
<p>등록된 클레임(Registered Claim)<br>
<code>토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터</code></p>
<ul>
<li>iss: 토큰 발급자(issuer)</li>
<li>sub: 토큰 제목(subject)</li>
<li>aud: 토큰 대상자(audience)</li>
<li>exp: 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370</li>
<li>nbf: 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음</li>
<li>iat: 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음</li>
<li>jti: JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며, 일회용 토큰(Access Token) 등에 사용</li>
</ul>
</li>
<li>
<p>공개 클레임(Public Claim)<br>
<code>사용자 정의 클레임으로, 공개용 정보를 위해사용 충동발지를 위해 URI 포맷</code></p>
<div><pre><code><span>{</span> <span>"https://mangkyu.tistory.com"</span><span>:</span> <span>true</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>비공개 클레임(Private Claim)<br>
<code>사용자 정의 클레임으로, 서버와 클라이언트 사이에 임의로 지정한 정보를 저장</code></p>
<div><pre><code><span>{</span> <span>"token_type"</span><span>:</span> access <span>}</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
</li>
<li>
<p>Signature(서명) : 토큰을 인코딩하거나 유효성 검증을 할 때 사용하는 고유한 암호화 코드.
헤더와 페이로드의 값을 각각 base64로 인코딩하고, 인코딩한 값을 비밀 키를 이용해 헤더에서 정의한 알고리즘으로 해싱을 하고, 이 값을 다시 base64로 인코딩하여 생성한다.</p>
</li>
</ul>
<h3 id="토큰-http-통신"> 토큰 HTTP 통신</h3>
<p>생성된 토큰은 HTTP 통신을 할 때 일반적으로 다음과 같이 사용된다.</p>
<div><pre><code><span>{</span> 
 <span>"Authorization"</span><span>:</span> <span>"Bearer {생성된 토큰 값}"</span><span>,</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="jwt-단점-및-고려사항"> JWT 단점 및 고려사항</h3>
<ul>
<li>Self-contained: 토큰 자체에 정보를 담고 있으므로 양날의 검이 될 수 있다.</li>
<li>토큰 길이: 토큰의 페이로드(Payload)에 3종류의 클레임을 저장하기 때문에, 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다.</li>
<li>Payload 인코딩: 페이로드(Payload) 자체는 암호화 된 것이 아니라, BASE64로 인코딩 된 것이다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로, JWE로 암호화하거나 Payload에 중요 데이터를 넣지 않아야 한다.</li>
<li>Stateless: JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료 시간을 꼭 넣어주어야 한다.</li>
<li>Tore Token: 토큰은 클라이언트 측에서 관리해야 하기 때문에, 토큰을 저장해야 한다.</li>
</ul>
<br>
<h2 id="_0519-스트레스-테스트-툴-artillery-사용"> 0519 - 스트레스 테스트 툴 Artillery 사용</h2>
<h3 id="스트레스-테스트-툴로-성능-측정하기"> 스트레스 테스트 툴로 성능 측정하기</h3>
<ol>
<li>설치</li>
</ol>
<div><pre><code><span>npm</span> <span>install</span> -g artillery@버전
</code></pre>
<div><span>1</span><br></div></div><ol start="2">
<li>설정 yaml 작성</li>
</ol>
<div><pre><code><span>config</span><span>:</span>
  <span>target</span><span>:</span> <span>"http://34.64.171.115"</span>
  <span>phases</span><span>:</span>
    <span>-</span> <span>duration</span><span>:</span> <span>60</span>
      <span>arrivalRate</span><span>:</span> <span>1</span>
      <span>name</span><span>:</span> Warm up
<span>scenarios</span><span>:</span>
  <span>-</span> <span>name</span><span>:</span> <span>"just get hash"</span>
    <span>flow</span><span>:</span>
      <span>-</span> <span>get</span><span>:</span>
          <span>url</span><span>:</span> <span>"/hash/123"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>This code describes a load phase which lasts 300 seconds (or 5 minutes), where 10 new virtual users will be created every second.</p>
<ol start="3">
<li>실행</li>
</ol>
<div><pre><code>artillery run --output report.json ./cpu-test.yaml
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>json to html</li>
</ol>
<div><pre><code>artillery report ./report.json
</code></pre>
<div><span>1</span><br></div></div><h3 id="doc"> doc</h3>
<p>https://artillery.io/docs/guides/overview/welcome.html</p>
<br>
<h2 id="_0521-빌드-관리-도구-비교"> 0521 - 빌드 관리 도구 비교</h2>
<h3 id="빌드-관리-도구란"> 빌드 관리 도구란?</h3>
<blockquote>
<p>빌드 도구는 빌드 자동화를 시켜주는 실행가능한 프로그램<br>
빌드 자동화란 실행가능한 프로그램을 만들어주는 과정으로써 코드를 컴파일해서 binary code로 만들고 패키징하며 코드를 테스트하고 실행가능한 프로그램이 나오기 까지의 과정</p>
</blockquote>
<h3 id="maven"> Maven</h3>
<ul>
<li>빌드 중인 프로젝트, 빌드 순서, 다양한 외부 라이브러리 종속성 관계를 pom.xml파일에 명시</li>
</ul>
<h3 id="gradle"> Gradle</h3>
<ul>
<li>Groovy 언어를 사용한 Domain-specific-language를 사용</li>
</ul>
<h3 id="차이점"> 차이점</h3>
<ul>
<li>Gradle은 작업 의존성 그래프를 기반, Maven은 고정적이고 선형적인 단계의 모델을 기반</li>
<li>Gradle은 업데이트 여부를 체크 incremental build를 허용<br>
=&gt; 빌드 시간 단축</li>
<li>멀티 프로젝트의 경우 maven은 특정 설정을 다른 모듈에서 사용하려면 상속 받아야 하지만, gradle은 설정 주입 방식을 제공</li>
<li>gradle은 concurrent에 안전한 캐시를 허용<br>
=&gt; 2개 이상의 프로젝트에서 동일한 캐시를 사용할 경우, 서로 overwirte되지 않도록  checksum 기반의 캐시를 사용하고, 캐시를 repository와 동기화 가능</li>
</ul>
<br>
<h2 id="_0523-m1-rc-ga"> 0523 - M1, RC, GA</h2>
<h3 id="스프링의-릴리즈-버전의-rc-ga-m1-2-3"> 스프링의 릴리즈 버전의 RC, GA, M1(2,3)</h3>
<h4 id="m1-milestone-1"> M1(Milestone 1)</h4>
<ul>
<li>프리 알파 단계에 있는 한 중류. 특정한 집합의 기능이 포함되며 기능이 완성되자마자 공개</li>
</ul>
<h4 id="rc-release-candidate"> RC(Release Candidate)</h4>
<ul>
<li>마지막 제품이 될 가능성이 있는 베타 버전으로, 상당한 버그가 나타나지 않으면 출시할 준비가 되었음을 의미</li>
</ul>
<h4 id="ga-general-availability"> GA(General Availability)</h4>
<ul>
<li>필요한 모든 상업화 활동이 완료되어 웹이나 물리 매체를 통해 시장에서 이용할 수 있게 됨을 의미</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0531 - 0606</title>
      <link>ahnjs/TIL/2021/0531/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0531/</guid>
      <source url="ahnjs/TIL/rss.xml">0531 - 0606</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0531-0606"> 0531 - 0606</h1>
<h2 id="_0531-hal-json"> 0531 - hal+json</h2>
<h3 id="hypertext-application-language-hal"> Hypertext Application Language (HAL)</h3>
<blockquote>
<p>HAL은 JSON 또는 XML 코드 내의 외부 리소스에 대한 링크와 같은 하이퍼 미디어를 정의하기위한 인터넷 초안 표준 규칙.</p>
</blockquote>
<ul>
<li>MIME 유형 media type : <code>application/hal+json</code></li>
</ul>
<h3 id="hal-예"> HAL 예</h3>
<div><pre><code><span>{</span>
<span>"_links"</span><span>:</span> <span>{</span>
  <span>"self"</span><span>:</span> <span>{</span>
    <span>"href"</span><span>:</span> <span>"http://example.com/api/book/hal-cookbook"</span>
  <span>}</span>
<span>}</span><span>,</span>
<span>"id"</span><span>:</span> <span>"hal-cookbook"</span><span>,</span>
<span>"name"</span><span>:</span> <span>"HAL Cookbook"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><br>
<h2 id="_0601-jmap으로-jvm-heap-상태-확인"> 0601 - jmap으로 JVM heap 상태 확인</h2>
<p>JDK에 포함된 jmap 명령으로 실행 중인 JVM의 heap 상태를 확인해보자.</p>
<ul>
<li>JVM의 프로세스 ID 확인</li>
</ul>
<div><pre><code>$ jps
또는
$ <span>ps</span> -ef <span>|</span> <span>grep</span> java
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>JVM의 heap 상태를 확인할 때는 -heap 옵션을 사용한다.</li>
</ul>
<div><pre><code>$ jmap -heap PID
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>-histo 옵션으로 클래스별 객체 수와 메모리 사용량 확인</li>
</ul>
<div><pre><code>$ jmap -histo:live PID <span>|</span> <span>more</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>-dump 옵션으로 heap dump 후, MAT 등으로 분석</li>
</ul>
<div><pre><code>$ jmap -dump:format<span>=</span>b,file<span>=</span>heap.PID.hprof PID
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_0602-jenkins를-이용해서-배포하기"> 0602 - jenkins를 이용해서 배포하기</h2>
<h3 id="젠킨스의-큰-기능-두가지"> 젠킨스의 큰 기능 두가지</h3>
<ul>
<li>Build &amp; Deploy</li>
<li>Batch</li>
</ul>
<h3 id="젠킨스-설치"> 젠킨스 설치</h3>
<div><pre><code><span># jenkins</span>
<span>sudo</span> yum <span>install</span> <span>wget</span>
<span>sudo</span> yum <span>install</span> maven
<span>sudo</span> yum <span>install</span> <span>git</span>
<span>sudo</span> yum <span>install</span> docker

<span>sudo</span> <span>wget</span> -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
<span>sudo</span> <span>rpm</span> --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key
<span>sudo</span> yum <span>install</span> jenkins
<span>sudo</span> systemctl start jenkins
<span>sudo</span> systemctl status jenkins
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>초기 비밀번호 확인</li>
</ul>
<div><pre><code><span>sudo</span> <span>cat</span> /var/lib/jenkins/secrets/initialAdminPassword
</code></pre>
<div><span>1</span><br></div></div><h3 id="배포시-젠킨스-인스턴스만-접속할-수-있게-하기"> 배포시 젠킨스 인스턴스만 접속할 수 있게 하기</h3>
<ul>
<li>
<p>Publish over SSH 플러그인 설치(젠킨스 인스턴스)</p>
</li>
<li>
<p>공개키 &amp; 개인키(젠킨스 인스턴스)</p>
</li>
</ul>
<div><pre><code>// 공개키 <span>&amp;</span> 개인키 생성
ssh-keygen -t rsa -f ~/.ssh/id_rsa

// 키 복사
<span>vi</span> ~/.ssh/id_rsa.pub    // 해당내용 복사
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>*** gcp 환경에서는 authorized_keys 수정 불가능</p>
<ul>
<li>공개키 등록(워커 인스턴스)</li>
</ul>
<div><pre><code>// authorized_keys 파일 끝에 공개키 복사
<span>vi</span> ~/.ssh/authorized_keys 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>폴더들 권한 변경(워커 인스턴스)</li>
</ul>
<div><pre><code><span>chmod</span> <span>700</span> ~/.ssh
<span>chmod</span> <span>600</span> ~/.ssh/authorized_keys
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>Publish over SSH 설정 추가
<ul>
<li>개인키 및 워커 서버정보 추가</li>
</ul>
</li>
</ul>
<h3 id="배포스크립트-관리-및-빌드"> 배포스크립트 관리 및 빌드</h3>
<ul>
<li>item 추가
<ul>
<li>item 설정 및 빌드 후 조치 설정</li>
<li>관리 및 빌드 명령어</li>
</ul>
<div><pre><code><span>nohup</span> docker run -p <span>8080</span>:80 sung431/spring-boot-cpu-bound <span>></span> /dev/null <span><span>2</span>></span><span>&amp;1</span> <span>&amp;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>docker.sock 권한 변경</li>
</ul>
<div><pre><code><span>sudo</span> <span>chmod</span> <span>666</span> /var/run/docker.sock
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>build</li>
<li>console 확인</li>
</ul>
<h3 id="정리"> 정리</h3>
<ol>
<li>소스코드는 GitHub가 가지고 있다.</li>
<li>애플리케이션 실행은 인스턴스에서 되어야 한다.</li>
<li>인스턴스에서 바로 GitHub에 있는 소스코드를 가져와서 빌드 후 실행시킬 수도 있지만, 이러면 매번 인스턴스에 접속해야한다.</li>
<li>인스턴스가 여러개면 여러개의 인스턴스에 각각 다 접속해서 3번을 해야한다. 비효율적</li>
<li>중간에 Jenkins 라는 미들웨어를 두고, GitHub에서 소스코드를 가져와서 빌드하고 인스턴스에 배포/실행 할 수 있다.</li>
<li>5번을 위해 Jenkins에 GitHub 저장소 URL을 등록하고, 빌드 스크립트를 작성하고, 배포될 인스턴스에 SSH로 접속할 수 있도록 세팅한다.</li>
<li>6번까지 완료되었으면 이제 Jenkins에서 간단히 배포할 수 있다.</li>
</ol>
<ul>
<li>명령어 정리</li>
</ul>
<div><pre><code>// <span>1</span>. jenkins-instance 서버 명령어
$ <span>sudo</span> yum <span>install</span> <span>wget</span>
$ <span>sudo</span> yum <span>install</span> maven
$ <span>sudo</span> yum <span>install</span> <span>git</span>
$ <span>sudo</span> yum <span>install</span> docker
$ <span>sudo</span> <span>wget</span> -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
$ <span>sudo</span> <span>rpm</span> --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key
$ <span>sudo</span> yum <span>install</span> jenkins
$ <span>sudo</span> systemctl start jenkins
$ <span>sudo</span> systemctl status jenkins

// <span>2</span>. cpu-instance 서버 명령어
$ <span>vi</span> authorized_keys
$ <span>chmod</span> <span>700</span> ~/.ssh
$ <span>chmod</span> <span>600</span> ~/.ssh/authorized_keys
$ <span>sudo</span> <span>chmod</span> <span>666</span> /var/run/docker.sock
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><br>
<h2 id="_0605-bean-과-component-차이"> 0605 - @Bean 과 @Component 차이</h2>
<h3 id="bean-과-component-차이"> @Bean 과 @Component 차이</h3>
<ul>
<li>@Component는 Class Level에서, @Bean은 Method Level에서 적용된다.</li>
<li>@Bean의 경우 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은경우 사용, @Component는 직접 컨트롤이 가능한 Class들의 경우 사용</li>
</ul>
<h3 id="springbootapplication"> @SpringBootApplication</h3>
<ul>
<li>@SpringBootApplication은 @Configuration, @ComponentScan을 상속</li>
</ul>
<div><pre><code><span>@Target</span><span>(</span><span>ElementType</span><span>.</span>TYPE<span>)</span>
<span>@Retention</span><span>(</span><span>RetentionPolicy</span><span>.</span>RUNTIME<span>)</span>
<span>@Documented</span>
<span>@Inherited</span>
<span>@SpringBootConfiguration</span>
<span>@EnableAutoConfiguration</span>
<span>@ComponentScan</span><span>(</span>excludeFilters <span>=</span> <span>{</span> <span>@Filter</span><span>(</span>type <span>=</span> <span>FilterType</span><span>.</span>CUSTOM<span>,</span> classes <span>=</span> <span>TypeExcludeFilter</span><span>.</span><span>class</span><span>)</span><span>,</span>
		<span>@Filter</span><span>(</span>type <span>=</span> <span>FilterType</span><span>.</span>CUSTOM<span>,</span> classes <span>=</span> <span>AutoConfigurationExcludeFilter</span><span>.</span><span>class</span><span>)</span> <span>}</span><span>)</span>
<span>public</span> <span>@interface</span> <span>SpringBootApplication</span> <span>{</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0614 - 0620</title>
      <link>ahnjs/TIL/2021/0614/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0614/</guid>
      <source url="ahnjs/TIL/rss.xml">0614 - 0620</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0614-0620"> 0614 - 0620</h1>
<h2 id="_0615-리눅스-디렉토리-구조"> 0615 - 리눅스 디렉토리 구조</h2>
<h3 id="리눅스-파일-시스템-구조"> 리눅스 파일 시스템 구조</h3>
<blockquote>
<p>리눅스 시스템의 디렉토리 구조는 역 트리(tree) 구조<br>
리눅스 배포판들은 '리눅스 파일 시스템 구조'인 FSSTND라는 표준을 준수</p>
</blockquote>
<h4 id=""> /</h4>
<p>최상위 디렉토리 루트</p>
<h4 id="bin"> /bin</h4>
<p>기본적인 명령어가 저장된 디렉토리, 명령어 디렉토리</p>
<h4 id="boot"> /boot</h4>
<p>리눅스 부트로더가 존재하는 디렉토리</p>
<h4 id="dev"> /dev</h4>
<p>시스템 디바이스 파일을 저장하고 있는 디렉토리</p>
<h4 id="etc"> etc</h4>
<p>시스템의 거의 모든 설정파일이 존재하는 디렉토리</p>
<h4 id="home"> /home</h4>
<p>사용자의 홈디렉토리</p>
<h4 id="lib"> lib</h4>
<p>커널모듈파일과 라이브러리파일 즉, 커널이 필요로하는 커널모듀파일들과 프로그램에 필요한 각종 라이브러리 파일들이 존재하는 디렉토리</p>
<h4 id="tmp"> /tmp</h4>
<p>공통디렉토리</p>
<h4 id="usr"> /usr</h4>
<p>시스템이 아닌 일반사용자들이 주로 사용하는 디렉토리</p>
<h4 id="var"> /var</h4>
<p>시스템운용중에 생성되었다가 삭제되는 데이터를 일시적으로 저장하기 위한 디렉토리</p>
<br>
<h2 id="_0616-spring-webflux란"> 0616 - Spring Webflux란?</h2>
<p>Spring WebFlux는 Spring 5에서 새롭게 추가된 모듈. WebFlux는 클라이언트, 서버에서 reactive 스타일의 어플리케이션 개발을 도와주는 모듈. WebFlux는 reactive-stack web framework이며 non-blocking에 reactive stream을 지원.</p>
<ul>
<li>reactive?<br>
: I/O 이벤트에 반응하는 네트워크 컴포넌트, 마우스 이벤트에 반응하는 UI 컨트롤러 등과 같은 변화에 대한 반응을 중심으로 구축된 프로그래밍 모델. non-blocking은 blocking과 다르게 작업이 완료되거나 데이터를 사용가능한 상태가 되면 알림에 반응하는 방식이 있으므로 reactive하다고 말 할 수 있다.</li>
<li>reactive Streams는 back pressure가 있는 비동기 컴포넌트간의 상호 작용을 정의하는 소규모 사양
<ul>
<li>Subscriber가 Publisher의 데이터 생성 속도(빠르게/느리게)를 제어 할 수 있도록 하는것</li>
</ul>
</li>
</ul>
<p>=&gt; Spring이 가지지 못했던 비동기 프로그래밍을 보완하기 위한 Spring5에 webflux 모듈을 사용</p>
<h3 id="용도"> 용도</h3>
<ul>
<li>비동기-논블록킹 리엑티브 개발에 사용</li>
<li>효율적으로 동작하는 고성능 웹 어플리케이션 개발</li>
<li>서비스 간 호출이 많은 마이크로서비스 아키텍처에 적합</li>
</ul>
<h3 id="두가지-개발방식-지원"> 두가지 개발방식 지원</h3>
<ul>
<li>기존의 MVC 방식</li>
<li>새로운 함수형 모델 (RouterFuction, HandlerFuction)</li>
</ul>
<h3 id="새로운-요청-응답-모델"> 새로운 요청 - 응답 모델</h3>
<ul>
<li>서블릿 스택과 API에서 탈피 (서블릿 API는 리엑티브 함수형 스타일에 적합하지 않음 - HttpServletRequest, HttpServletResponse)</li>
<li>ServerRequest, ServerResponse</li>
</ul>
<h3 id="동작흐름"> 동작흐름</h3>
<ul>
<li>MVC : request - Dispatcher Servlet - Handler Mapper - Controller - B/L - Controller - ViewResolver ...</li>
<li>WebFlux : request - HttpHandler - WebHandler - Handler Mapper / Handler Adapter - Controller - B/L -Controller - ViewResolver ...</li>
</ul>
<h3 id="mono-flux"> Mono / Flux</h3>
<p>Reactive Streams 인터페이스 중에서 Publisher를 구현 해 놓은 발행자.</p>
<ul>
<li>Mono : 0 ~ 1개의 데이터 전달</li>
<li>Flux : 0 ~ N 개의 데이터 전달</li>
</ul>
<br>
<h2 id="_0620-클라우드-서비스-iaas-paas-saas"> 0620 - 클라우드 서비스 (IaaS, PaaS, SaaS)</h2>
<h3 id="iaas"> IaaS</h3>
<ul>
<li>서비스로서의 인프라스트럭처(Infrastructure as a Service)는 서버, 스토리지, 네트워크를 필요에 따라 인프라 자원을 사용할 수 있게 클라우드 서비스를 제공하는 형태 =&gt; 간략하게 컴퓨터만 할당 받는것</li>
<li>대표 서비스
<ul>
<li>AWS EC2, Google Cloud Platform, Azure Virtual Machines, Naver Cloud Platform</li>
</ul>
</li>
</ul>
<h3 id="paas"> PaaS</h3>
<ul>
<li>PaaS(Platform as a Service)라고도하는 클라우드 플랫폼 서비스는 주로 애플리케이션에 사용되는 동안 특정 소프트웨어에 클라우드 구성요소를 제공 =&gt; 서버, 환경구성 제공 개발자는 소스만 올리면 된다.</li>
<li>대표 서비스
<ul>
<li>AWS Elastic Beanstalk, Windows Azure, Heroku</li>
</ul>
</li>
</ul>
<h3 id="saas"> SaaS</h3>
<ul>
<li>서비스로서의 소프트웨어(Software as a Service)는 소프트웨어 및 관련 데이터는 중앙에 호스팅되고 사용자는 웹 브라우저 등의 클라이언트를 통해 접속하는 형태의 소프트웨어 전달 모델이다. 주문형 소프트웨어(on-demand software, 온디맨드)라고도 한다.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0607 - 0613</title>
      <link>ahnjs/TIL/2021/0607/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0607/</guid>
      <source url="ahnjs/TIL/rss.xml">0607 - 0613</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0607-0613"> 0607 - 0613</h1>
<h2 id="_0609-무중단-배포를-위한-환경-이해하기"> 0609 - 무중단 배포를 위한 환경 이해하기</h2>
<h3 id="무중단-배포"> 무중단 배포?</h3>
<blockquote>
<p>배포를 중단없이 한다는 것<br>
배포(deploy)란 개발환경에서 새로 개발된 코드를 패키징하여 서버에서 새로운 버전의 애플리케이션을 실행</p>
</blockquote>
<h3 id="배포-과정"> 배포 과정</h3>
<ul>
<li>일반적인 배포에서의 애플리케이션 중단</li>
</ul>
<ol>
<li>이전 버전의 애플리케이션을 종료</li>
<li>새로운 버전 애플리케이션을 실행</li>
<li>새로운 버전 애플리케이션이 요청을 받을 준비가 될 때까지 서비스 중단
=&gt; 서비스가 중단되는 시간을 다운타임(downtime)이라한다.</li>
</ol>
<h3 id="무중단-배포-2"> 무중단 배포</h3>
<p>애플리케이션 서버와 사용자 사이에서 요청을 중계해주는 <code>리버스 프록시(Reverse Proxy)</code> 서버를 사용. =&gt; <code>롤링(Rolling) 배포</code></p>
<ul>
<li>프록시란?
<ul>
<li>일반적인 프록시는 클라이언트를 숨겨주는 역할</li>
<li>대리자</li>
<li>리버스 프록시는 프록시와 반대로 서버를 숨겨주는 역할</li>
</ul>
</li>
<li>로드밸런싱이란?
<ul>
<li>트래픽을 분산하여 각 서버가 받는 부하를 분산하는 것</li>
</ul>
</li>
<li>Nginx
<ul>
<li>무중단 배포와 로드밸런싱을 위해 사용</li>
</ul>
</li>
<li>여러가지 배포 방식
<ul>
<li>롤링 배포, 블루그린 배포, 카나리 배포</li>
</ul>
</li>
</ul>
<h3 id="트레픽이-많아졌을-때의-로드밸런싱"> 트레픽이 많아졌을 때의 로드밸런싱</h3>
<ol>
<li>Nginx가 실행되는 서버의 Scale-up</li>
<li>네트워크 장치로 로드 밸런싱(하드웨어 적으로)
<ul>
<li>L4 스위치 또는 L7 스위치</li>
</ul>
</li>
<li>DNS 리다리렉션</li>
</ol>
<br>
<h2 id="_0611-stringtokenizer"> 0611 - StringTokenizer</h2>
<h3 id="stringtokenizer-생성자"> StringTokenizer 생성자</h3>
<div><pre><code><span>// 띄어쓰기 기준으로 문자열을 분리</span>
<span>StringTokenizer</span> st <span>=</span> <span>new</span> <span>StringTokenizer</span><span>(</span>문자열<span>)</span><span>;</span>

<span>// 구분자를 기준으로 문자열을 분리 </span>
<span>StringTokenizer</span> st <span>=</span> <span>new</span> <span>StringTokenizer</span><span>(</span>문자열<span>,</span> 구분자<span>)</span><span>;</span>

<span>// 구분자도 토큰으로 넣을지 (true)</span>
<span>StringTokenizer</span> st <span>=</span> <span>new</span> <span>StringTokenizer</span><span>(</span>문자열<span>,</span> 구분자<span>,</span> <span>boolean</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="stringtokenizer-메서드"> StringTokenizer 메서드</h3>
<p><img src="https://user-images.githubusercontent.com/49400801/121779057-c85d6000-cbd4-11eb-89af-5b76830bc72b.png" alt="st_메서드"></p>
<h3 id="stringtokenizer-vs-split"> StringTokenizer vs Split</h3>
<ol>
<li>StringTokenizer는 java.util에 포함되어 있는 클래스, split는 String클래스에 속해있는 메소드.</li>
<li>StringTokenizer는 문자 또는 문자열을 구분, split는 정규표현식으로 구분</li>
<li>StringTokenizer는 빈 문자열을 토큰으로 인식X, split는 빈 문자열을 토큰으로 인식</li>
<li>StringTokenizer는 결과값이 문자열, split는 결과 값이 문자열 배열</li>
</ol>
<br>
<h2 id="_0612-tdd-bdd-ddd-rdd"> 0612 - TDD, BDD, DDD, RDD</h2>
<h3 id="tdd-test"> TDD (Test)</h3>
<ul>
<li>테스트를 먼저 작성하고 해당 테스트 케이스를 통과하는 코드를 작성</li>
<li>그 후 상황에 맞게 리팩토링 과정을 거침</li>
<li>코드 생산성에 문제가 있고, 러닝커브가 크다.</li>
</ul>
<h3 id="bdd-behavior"> BDD (Behavior)</h3>
<ul>
<li>TDD에서 한발 더 나아가 테스트 케이스 자체가 요구사항이 되는 개발 방식</li>
<li>TDD에서는 유닛 테스트로 작성 된 테스트 케이스에 대한 문서를 작성했지만, BDD는 이것을 결합 테스트와 시나리오 테스트까지 확장하여 각각에 해당하는 문서를 대체한다.</li>
</ul>
<h3 id="ddd-domain"> DDD (Domain)</h3>
<ul>
<li>도메인 그 자체와 도메인 로직에 초점을 맞춘다.</li>
<li>일반적으로 사용하는 데이터 중심의 접근법을 탈피하여 순수한 도메인의 모델과 로직에 집중한다.</li>
</ul>
<h3 id="rdd-responsibility"> RDD (Responsibility)</h3>
<ul>
<li>책임을 찾고 책임을 수행한 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법</li>
<li>객체의 구현이 아닌 채임에 집중</li>
</ul>
]]></content:encoded>
      <enclosure url="https://user-images.githubusercontent.com/49400801/121779057-c85d6000-cbd4-11eb-89af-5b76830bc72b.png" type="image/png"/>
    </item>
    <item>
      <title>0524 - 0530</title>
      <link>ahnjs/TIL/2021/0524/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0524/</guid>
      <source url="ahnjs/TIL/rss.xml">0524 - 0530</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0524-0530"> 0524 - 0530</h1>
<h2 id="_0524-클라우드에-도커이미지-배포하기"> 0524 - 클라우드에 도커이미지 배포하기</h2>
<h3 id="요구사항"> 요구사항</h3>
<ul>
<li>15분</li>
<li>JDK 1.8 이상</li>
<li>Gradle 4+ 또는 Maven 3.2+</li>
<li>Spring Toll Suite 또는 IntelliJ IDEA</li>
</ul>
<h3 id="도커-파일-생성"> 도커 파일 생성</h3>
<div><pre><code><span>FROM</span> openjdk<span>:</span>8<span>-</span>jdk<span>-</span>alpine
<span>ARG</span> JAR_FILE=target/*.jar
<span>COPY</span> $<span>{</span>JAR_FILE<span>}</span> app.jar
<span>ENTRYPOINT</span> <span>[</span><span>"java"</span><span>,</span><span>"-jar"</span><span>,</span><span>"/app.jar"</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="docker-command"> docker command</h3>
<div><pre><code>// 빌드
docker build -t sung431/spring-boot-cpu-bound <span>.</span>

// 로컬 실행
docker run -p <span>80</span>:80 sung431/spring-boot-cpu-bound

// 도커 로그인
docker login

// 원격저장소에 등록
docker push sung431/spring-boot-cpu-bound
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="도커-설치-및-실행"> 도커 설치 및 실행</h3>
<div><pre><code>// 설치
<span>sudo</span> yum <span>install</span> docker

// 실행
<span>sudo</span> systemctl start docker

// 이미지 받아오기
<span>sudo</span> docker pull sung431/spring-boot-cpu-bound

// 도커 이미지 실행
<span>sudo</span> docker run -p <span>80</span>:80 sung431/spring-boot-cpu-bound
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><br>
<h2 id="_0525-mac-node-완전히-삭제"> 0525 - (Mac) Node 완전히 삭제</h2>
<ol>
<li>shell을 열어 두 줄의 코드를 입력한다.</li>
</ol>
<div><pre><code> lsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom | while read f; do  sudo rm /usr/local/${f}; done
 sudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>/usr/local/lib 에 있는 node로 시작하는 directory를 삭제한다.</li>
</ol>
<div><pre><code> cd /usr/local/lib
 sudo rm -rf node*

 sudo rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/{npm*,node*,man1/node*}
 sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp

 /usr/local/lib 로 이동하여 node 및 node_modules를 삭제
 /usr/local/include 로 이동하여 node 및 node_modules 디렉토리를 삭제
 brew install node로 설치 한 경우 터미널에서 brew uninstall node 를 실행
 홈 디렉토리에 로컬 또는 lib 또는 포함 폴더가 있는지 확인 하고 거기에서 node 또는 node_modules 를 삭제
 /usr/local/bin으로 이동하여 모든 노드 실행 파일을 삭제

 sudo rm -rf /opt/local/bin/node /opt/local/include/node /opt/local/lib/node_modules
 sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node.1 /usr/local/lib/dtrace/node.d
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><ol start="3">
<li>/usr/local/include에 있는 node로 시작하는 directory를 삭제한다.</li>
</ol>
<div><pre><code>cd /usr/local/include
sudo rm -rf node*
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="4">
<li>brew에 설치된 node를 삭제한다.</li>
</ol>
<div><pre><code>brew uninstall node
</code></pre>
<div><span>1</span><br></div></div><ol start="5">
<li>/usr/local/bin 에 있는 node 또는 node_modules를 삭제한다.</li>
</ol>
<div><pre><code>sudo rm -rf /usr/local/bin/npm
sudo rm -rf /usr/local/bin/node
ls -las
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="6">
<li>추가적인 것들을 삭제한다.</li>
</ol>
<div><pre><code>sudo rm -rf /usr/local/share/man/man1/node.1
sudo rm -rf /usr/local/lib/dtrace/node.d
sudo rm -rf ~/.npm
sudo rm -rf ~/.nvm
rm -rf ~/.node-gyp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><br>
<h2 id="_0526-nvm-node-version-manager"> 0526 - nvm(Node Version Manager)</h2>
<h3 id="nvm-설치"> nvm 설치</h3>
<ul>
<li>
<p>git</p>
<ul>
<li>https://github.com/nvm-sh/nvm</li>
</ul>
</li>
<li>
<p>설치</p>
</li>
</ul>
<div><pre><code><span>curl</span> -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh <span>|</span> <span>bash</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>환경변수 설정</li>
</ul>
<div><pre><code><span>export</span> <span>NVM_DIR</span><span>=</span><span>"<span><span>$(</span><span>[</span> -z <span>"<span>${XDG_CONFIG_HOME-}</span>"</span> <span>]</span> <span>&amp;&amp;</span> <span>printf</span> %s <span>"<span>${<span>HOME</span>}</span>/.nvm"</span> <span>||</span> <span>printf</span> %s <span>"<span>${XDG_CONFIG_HOME}</span>/nvm"</span><span>)</span></span>"</span>
<span>[</span> -s <span>"<span>$NVM_DIR</span>/nvm.sh"</span> <span>]</span> <span>&amp;&amp;</span> <span>\</span>. <span>"<span>$NVM_DIR</span>/nvm.sh"</span> <span># This loads nvm</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>적용</p>
<div><pre><code>bash: <span>source</span> ~/.bashrc
      <span>source</span> ~/.bash_profile  

zsh: <span>source</span> ~/.zshrc

ksh: <span>.</span> ~/.profile
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="옵션-및-사용-방법"> 옵션 및 사용 방법</h3>
<ul>
<li>node.js 설치</li>
</ul>
<div><pre><code>nvm <span>install</span> <span>{</span>version<span>}</span>
nvm <span>install</span> <span>12.13</span>.1
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>node 목록 확인</li>
</ul>
<div><pre><code>nvm <span>ls</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>사용 버전 지정</li>
</ul>
<div><pre><code>nvm use <span>12.13</span>.1
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_0527-bash-zsh-환경변수-따로-등록되어-있을때"> 0527 - bash, zsh 환경변수 따로 등록되어 있을때</h2>
<ul>
<li>각 환경별 환경변수 설정</li>
</ul>
<div><pre><code>~/.bash_profile
~/.zshrc
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>따라서 bash 환경설정에 변수를 설정하고 zsh 환경에서 실행했을경우
당연히 실행하고자하는 커맨드는 <code>zsh: command not found</code> 가 됨</p>
<ul>
<li>zshrc에서 bash가 작동하도록 등록</li>
</ul>
<div><pre><code><span>if</span> <span>[</span> -f ~/.bash_profile <span>]</span><span>;</span> <span>then</span> <span>source</span> ~/.bash_profile<span>;</span> <span>fi</span>
</code></pre>
<div><span>1</span><br></div></div><br>
<h2 id="_0528-postgres-data-directory-변경"> 0528 - postgres data_directory 변경</h2>
<ol>
<li>현재 data directory 확인</li>
</ol>
<div><pre><code>$ psql
<span>postgres</span><span>=</span><span># show data_directory;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>기존 데이터 복사</li>
</ol>
<div><pre><code> <span>mv</span> 현재디렉토리 옮길디렉토리
</code></pre>
<div><span>1</span><br></div></div><ol start="3">
<li>환경변수 또는 설정파일 변경
<ul>
<li>PGDATA 환경변수 변경</li>
<li>postgres config파일 변경</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>0621 - 0627</title>
      <link>ahnjs/TIL/2021/0621/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0621/</guid>
      <source url="ahnjs/TIL/rss.xml">0621 - 0627</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0621-0627"> 0621 - 0627</h1>
<h2 id="_0621-dynamicupdate"> 0621 - @DynamicUpdate</h2>
<ul>
<li>JPA Entity에 사용하는 어노테이션으로, 실제 값이 변경된 컬럼으로만 update 쿼리를 만드는 기능.</li>
<li>기본적으로 @DynamicUpdate는 Spring JPA에서 제공하는 기능.</li>
<li>JPA는 서버가 실행될 때 CURD에 관한 SQL문을 캐싱해놓음, UPDATE 대상이 모든 열로선언.</li>
<li>특정 값만 업데이트 되는 빈도가 많은 경우 효율성에 대한 문제가 생김.</li>
<li>JPA는 캐시메모리를 이용하고 있기 때문에 업데이트를 하는 컬럼이 많아질 경우 SQL문을 생성하고 실행하는 것보다 캐시메모리에 존재하는 데이터를 이용하는 것이 더 효율적.</li>
</ul>
<h3 id="결론"> 결론</h3>
<p>특정값만 자주 변경되는 상황같은 필요한 경우에만 @DynamicUpdate를 사용하자!</p>
<br>
<h2 id="_0622-systemctl과-service-명령어-차이점"> 0622 - systemctl과 service 명령어 차이점</h2>
<div><pre><code><span>service</span> iptables start
systemctl start iptables
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><code>CentOS 5이전 버전은 service 구문으로,</code><br>
<code>CentOS 6이후 버전은 systemctl 구문으로 제어</code></p>
<p>7버전 이후로 서비스 관리 스크립트들은 서비스 유닛(Unit)으로 변경.</p>
<h2 id="_0624-hibernate-hbm2ddl-auto-설정"> 0624 - hibernate.hbm2ddl.auto 설정</h2>
<p>hibernate에는 <code>hbm2ddl.auto</code> 설정 프로퍼티가 있다. SessionFactory가 생성될 때 스키마 DDL을 db로 검증하고 내보내는 기능을 상황에 따라 다르게 설정할 수 있도록 하는 프로퍼티이다.</p>
<h3 id="option"> Option</h3>
<ul>
<li>create : SessionFactory 시작시 스키마를 삭제하고 다시 생성</li>
<li>create-drop : SessionFactory 종료시 스키마를 삭제</li>
<li>update : SessionFactory 시작시 객체 구성과 스키마를 비교하여 컬럼 추가/삭제 작업을 진행. 기존 스키마를 유지</li>
<li>validate : SessionFactory 시작시 객체 구성과 스키마가 다르다면 예외를 발생시킴</li>
</ul>
<br>
<h2 id="_0627-nginx를-통한-로드밸런싱-구성"> 0627 - nginx를 통한 로드밸런싱 구성</h2>
<h3 id="nginx-설치-및-실행"> nginx 설치 및 실행</h3>
<ul>
<li>설치</li>
</ul>
<div><pre><code>$ sudo yum install nginx
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>실헹</li>
</ul>
<div><pre><code>$ sudo systemctl start nginx
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>확인
host 80 포트로 확인</li>
</ul>
<h3 id="nginx-conf-설정"> nginx.conf 설정</h3>
<div><pre><code>$ sudo vi /etc/nginx/nginx.conf
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>로드밸런싱 설정 추가</li>
</ul>
<div><pre><code>upstream cpu-bound-app {
  server {instance_1번의_ip}:8080 weight=100 max_fails=3 fail_timeout=3s;
  server {instance_2번의_ip}:8080 weight=100 max_fails=3 fail_timeout=3s;
  server {instance_3번의_ip}:8080 weight=100 max_fails=3 fail_timeout=3s;
}

location / {
  proxy_pass http://cpu-bound-app;
  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection &#39;upgrade&#39;;
  proxy_set_header Host $host;
  proxy_cache_bypass $http_upgrade;
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/</p>
<ul>
<li>reload</li>
</ul>
<div><pre><code>$ sudo systemctl reload nginx
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>httpd connect 설정 변경</li>
</ul>
<div><pre><code>$ sudo setsebool -P httpd_can_network_connect on
</code></pre>
<div><span>1</span><br></div></div><h3 id="nginx-로그-확인"> nginx 로그 확인</h3>
<ul>
<li>에러로그</li>
</ul>
<div><pre><code>$ sudo tail -f /var/log/nginx/error.log
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>0705 - 0808</title>
      <link>ahnjs/TIL/2021/0705/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0705/</guid>
      <source url="ahnjs/TIL/rss.xml">0705 - 0808</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0705-0808"> 0705 - 0808</h1>
<h2 id="_0706-springboot-properties와-yaml"> 0706 - SpringBoot properties와 yaml</h2>
<h3 id="yaml-yml-ain-t-markup-language"> YAML (YML Ain't Markup Language)</h3>
<ul>
<li>
<p>XML, C, 파이썬, 펄, RFC2822에서 정의된 e-mail 양식에서 개념을 얻어 만들어진 '사람이 쉽게 읽을 수 있는' 데이터 직렬화 양식.</p>
</li>
<li>
<p>YAML은 모든 데이터를 리스트, 해쉬, 스칼라 데이터 조합으로 적절히 표현할 수 있다는 믿음을 가지고 만들어졌다.
문법은 상대적으로 이해하기 쉽고, 가독성이 좋도록 디자인되었으며, 고급 컴퓨터 언어에 적합하다.
또한 들여쓰기 및 XML의 특수기호를 사용하기 때문에, XML과 거의 비슷 하다.</p>
</li>
<li>
<p>JSON은 yaml의 일종이다.</p>
</li>
</ul>
<h4 id="사용방법-및-properties와-비교시-이점"> 사용방법 및 Properties와 비교시 이점</h4>
<ul>
<li>
<p>장점</p>
<ol>
<li>가독성이 좋다.
<ul>
<li>계층 구조로 표현하여 가독성이 좋다. 또한 불필요한 소스의 중복도 제거 할 수 있다.</li>
<li>들여쓰기, 띄어쓰기로 구분하여 보기 편하다.</li>
</ul>
</li>
<li>리스트 표현
<ul>
<li>여러 줄에 쓸 때에는 하이픈(-)으로 시작하는 한 줄에 하나의 요소를 표현한다.</li>
<li>한 줄에 모아 쓸 대에는 대괄호([])를 이용하여 쉼표로 각 요소를 구분한다.</li>
</ul>
</li>
<li>주석
<ul>
<li>주석은 #으로 표시하며, 한 줄이 끝날 때까지 유효하다.</li>
</ul>
</li>
<li>SpringBoot Profile 적용이 용이하다. (with &quot;---&quot; 구분자)
<ul>
<li>한파일 내에서 여러 파일을 사용하는 것처럼 분리가 가능하다.</li>
<li>application.yml 파일 하나로 여러개의 yml을 생성 한것과 같이 처리 가능</li>
</ul>
</li>
</ol>
</li>
<li>
<p>단점</p>
<ol>
<li>@PropertySource 어노테이션으로 프로퍼티 값을 불러 올 수 없다.</li>
</ol>
</li>
</ul>
<br>
<h2 id="_0707-docker-종료"> 0707 - docker 종료</h2>
<h3 id="실행중인-도커-컨테이너-정보-확인"> 실행중인 도커 컨테이너 정보 확인</h3>
<p><code>docker ps</code></p>
<h3 id="실행중인-도커-컨테이너-중-spring-boot-cpu-bound-애플리케이션이-포함된-줄-찾기"> 실행중인 도커 컨테이너 중 spring-boot-cpu-bound 애플리케이션이 포함된 줄 찾기</h3>
<p><code>docker ps | grep spring-boot-cpu-bound</code></p>
<h3 id="도커-컨테이너-종료시키기"> 도커 컨테이너 종료시키기</h3>
<p><code>docker container kill -s 15 {컨테이너 id}</code></p>
<br>
<h2 id="_0722-jar-war-차이점-및-특징"> 0722 - jar, war 차이점 및 특징</h2>
<p>JAR(Java Archive) WAR(Web Application Archive) 모두 JAVAdml jar 툴을 이용하여 생성된 압축(아카이브) 파일이며 어플리케이션을 쉽게 배포하고 동작시킬 수 있도록 관련 파일(리소스, 속성파일 등)들을 패키징</p>
<h3 id="jar"> JAR</h3>
<p>.jar 확장자 파일에는 Class와 같은 Java 리소스와 속성 파일, 라이브러리 및 액세서리 파일이 포함되어 있다.<br>
쉽게 JAVA 어플리케이션이 동작할 수 있도록 자바 프로젝트를 압축한 파일. 실제로 JAR 파일은 플랫폼에 귀속되는 점만 제외하면 WIN ZIP파일과 동일한 구조.<br>
JAR 파일은 원하는 구조로 구성이 가능하며 JDK(Java Development Kit)에 포함하고 있는 JRE(Java Runtime Environment)만 가지고도 실행이 가능.</p>
<h3 id="war"> WAR</h3>
<p>.war 확장자 파일은 servlet/jsp 컨테이너에 배치 할 수 있는 웹 어플리케이션(Web Application) 압축 파일 포맷. JSP, SERVLET, JAR, CLASS, XML, HTML, JAVASCRIPT 등 Servlet Context 관련 파일들로 패키징 되어있다. WAR는 웹 응용 프로그램을 위한 포맷이기 때문에 웹 관련 자원만 포함하고 있으며 이를 사용하면 웹 어플리케이션을 쉽게 배포하고 테스트 할 수 있다.<br>
원하는 구성을 할 수 있는 JAR 포맷과 달리 WAR은 WEB-INF 및 META-INF 디렉토리로 사전 정의 된 구조를 사용하며 WAR파일을 실행하려면 Tomcat, Weblogic, Websphere 등의 웹 서버 (WEB)또는 웹 컨테이너(WAS)가 필요하다.
WAR 파일도 JAVA의 JAR 옵션(java -jar)을 이용해 생성하는 JAR파일의 일종으로 웹어플리케이션 전체를 패키징하기 위한 JAR파일.</p>
<br>
<h2 id="_0808-maven의-groupid-artifactid-version"> 0808 - Maven의 groupId, artifactId, version</h2>
<h3 id="groupid"> groupId</h3>
<ul>
<li>
<p>groupId는 모든 프로젝트 사이에서 고유하게 식별되는 ID</p>
</li>
<li>
<p>다음과 같은 네이밍 스키마 적용</p>
<ul>
<li>package 명명 규칙을 따르도록 한다.</li>
<li>최소한 당신이 컨트롤 하는 도메인 네임이어야 한다.</li>
<li>하위 그룹은 얼마든지 추가할 수 있다.</li>
<li>예) <code>org.apache.maven</code>, <code>org.apache.commons</code></li>
</ul>
</li>
<li>
<p>프로젝트 구조를 사용하면 잘 구분되는 groupId를 만들 수 있다.</p>
<ul>
<li>현재 프로젝ㅌ으가 다중 모듈 프로젝트라면, 부모 groupId에 현재 프로젝트의 식별자를 추가하는 방식.</li>
<li>예) <code>org.apache.maven</code>, <code>org.apache.maven.plugins</code>, <code>org.apache.maven.reporting</code></li>
</ul>
</li>
</ul>
<h3 id="artifactid"> artifactId</h3>
<ul>
<li>artifactId는 버전 정보를 생략한 jar 파일의 이름이다.
<ul>
<li>이른은 원하는 것으로 아무거나 정해도 괜찮다.</li>
<li>단, 소문자로만 작성하도록 한다.</li>
<li>단, 특수문자는 사용하지 않는다.</li>
</ul>
</li>
<li>만약 써드 파티 jar 파일이라면, 할당된 이름을 사용해야 한다.
<ul>
<li>예) <code>maven</code>, <code>commons-math</code></li>
</ul>
</li>
</ul>
<h3 id="version"> version</h3>
<ul>
<li>숫자와 점으로 이루어진 일반적인 버전 형태를 사용한다.(1.0. 1.1, 1.0.1)</li>
<li>SNAPSHOT(nightly) 빌드 날짜를 버전으로 사용하지 않도록 한다.</li>
<li>써드 파티 아티팩트라면, 버전 넘버를 이어받아 사용하도록 한다.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>0628 - 0704</title>
      <link>ahnjs/TIL/2021/0628/</link>
      <guid isPermaLink="false">ahnjs/TIL/2021/0628/</guid>
      <source url="ahnjs/TIL/rss.xml">0628 - 0704</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="_0628-0704"> 0628 - 0704</h1>
<h2 id="_0628-리눅스-네트워크-관련"> 0628 - 리눅스 네트워크 관련</h2>
<h3 id="라우팅설정"> 라우팅설정</h3>
<ul>
<li>임시 적용</li>
</ul>
<div><pre><code>$ route add -net 아이피 netmask 넷마스크 dev 장치명
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>영구 적용</li>
</ul>
<div><pre><code>$ vi /etc/sysconfig/network-scripts/route-장치명

// 작성
ADDRESS0=아이피
NETMASK0=넷마스크
GATEWAY0=게이트웨이

// 재시작
$ systemctl restart network
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>확인</li>
</ul>
<div><pre><code>$ route
</code></pre>
<div><span>1</span><br></div></div><h3 id="dns-설정"> DNS 설정</h3>
<div><pre><code>$ vi /etc/resolv.conf

// 작성
nameserver 아이피

// 재시작
$ systemctl restart network
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><br>
<h2 id="_0629-포워드-프록시-forward-proxy-리버스-프록시-reverse-proxy-의-차이"> 0629 - 포워드 프록시(forward proxy) 리버스 프록시(reverse proxy)의 차이</h2>
<p>아파치 웹서버(apache web server)에는 mod_proxy라는 모듈에서 forward proxy와 reverse proxy 두 가지 기능을 제공하며 nginx는 필요한 기능만 제공하는 고성능 웹 서버에 맞게 reverse proxy 기능만 제공한다.</p>
<h3 id="forward-proxy"> Forward Proxy</h3>
<p><code>사용자 &lt;=&gt; 포워드 프록시 서버 &lt;=&gt; 인터넷 &lt;=&gt; 서버</code></p>
<p>포워드 프록시는 대개 캐슁 기능이 있으므로 자주 사용되는 컨텐츠라면 월등한 성능 향상을 가져올 수 있으며 정해진 사이트만 연결하게 설정하는 등 웹 사용 환경을 제한 할 수 있으므로 보안이 매우 중요한 기업 환경등에서 사용.</p>
<h3 id="reverse-proxy"> Reverse Proxy</h3>
<p><code>사용자 &lt;=&gt; 인터넷 &lt;=&gt; 리버스 프록시 서버 &lt;=&gt; 서버</code></p>
<p>리버스 프록시로 웹 서버를 설정할 경우 사용자가 웹 서비스에 데이터를 요청하면 리버스 프록시는 이 요청을 받아서 내부 서버에서 데이터를 받은 후에 이 데이터를 사용자에게 전달한다.</p>
<ul>
<li>장점</li>
</ul>
<ol>
<li>보안 : DMZ존 사용으로 보안 강화</li>
<li>속도와 안정성 : Cache Server나 SSL 하드웨어 가속기 연동 등 아키텍처 측면에서 성능 향상을 하기에 용이</li>
<li>신뢰성 증대 : 리버스 프록시를 cluster로 구성하면 가용성을 높일 수 있고 사용자수에 따라 Web Server나 WAS를 유연하게 늘릴 수 있는 장점, 리버스 프록시 앞에 L4나 load balancer를 붙이면 Round Robin, Least connection 등 상황에 맞는 분배 알고리즘을 적용해 서비스 신뢰성을 높임</li>
</ol>
<br>
<h2 id="_0630-배포-전략의-종류"> 0630 - 배포 전략의 종류</h2>
<h3 id="롤링-rolling"> 롤링(Rolling)</h3>
<p>일반적인 배포를 의미하며, 단순하게 서버를 구성하여 배포하는 전략이다. 다시 말해 구 버전에서 신 버전으로 트래픽을 점진적으로 전환하는 배포이다. 관리가 편하지만, 배포 중 한쪽 인스턴스의 수가 감소되므로 서버 처리 용량을 미리 고려해야 한다.</p>
<h3 id="블루-그린-blue-green"> 블루 그린(Blue Green)</h3>
<p>구 버전을 블루, 신 버전을 그린이라고 해서 붙여진 이름이다. 신 버전을 배포하고 일제히 전환하여 모든 연결을 신 버전을 바라보게 하는 전략이다. 구 버전, 신 버전 서버를 동시에 나란히 구성하여 배포 시점에 트래픽이 일제히 전환된다. 빠른 롤백이 가능하고, 운영환경에 영향을 주지 않고 실제 서비스 환경으로 신 버전 테스트가 가능하다. 단 이런 구성은 시스템 자원이 두배로 필요하여 비용이 더 많이 발생한다.</p>
<h3 id="카나리-canary"> 카나리(Canary)</h3>
<p>카나리 배포에 대한 설명에 앞서 카나리에 대한 어원을 알아보자. Canary의 사전적 의미에는 카나리아라는 새이다. 카나리아는 유독가스에 굉장히 민감한 동물로 석탄 광산에서 유독가스 누출의 위험을 알리는 용도로 사용되어왔다. 미리 위험을 감지하기 위함이다.<br>
카나리 배포는 위험을 빠르게 감지할 수 있는 배포 전략이다. 지정한 서버 또는 특정 user에게만 배포했다가 정상적이면 전체를 배포한다. 서버의 트래픽 일부를 신 버전으로 분산하여 오류 여부를 확인할 수 있다. 이런 전략은 A/B 테스트가 가능하며, 성능 모니터링에 유용하다. 트래픽을 분산시킬 때는 라우팅을 랜덤 하게 할 수 있고, 사용자로 분류할 수도 있다.</p>
<br>
<h2 id="_0701-l4-로드밸런서-vs-l7-로드밸런서"> 0701 - L4 로드밸런서 vs L7 로드밸런서</h2>
<h3 id="l4-transport-layer"> L4(Transport Layer)?</h3>
<p>주로 Round Robin 방식을 사용하며, 네트워크 계층(IP, IPX)이나 트랜스포트 계층(TCP, UDP)의 정보를 바탕으로 로드를 분산시킨다.</p>
<h3 id="l7-application-layer"> L7(Application Layer)?</h3>
<p>애플리케이션 계층(HTTP, FTP, SMTP)에서 로드를 분산하기 때문에 HTTP 헤더, 쿠키 등과 같은 사용자의 요청을 기준으로 특정 서버에 트래픽 분산하는 것이 가능하다.<br>
쉽게 말해 패킷의 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배하는 것이 가능한 것이다. URL에 따라 부하를 분산시키거나, HTTP 헤더의 쿠키값에 따라 부하를 분사하는 등 클라이언트 요청을 보다 세분화해 서버에 전달할 수 있다. 또한 L7 로드밸러서의 경우 특정한 패턴을 지닌 바이러스를 감지해 네트워크를 보호할 수 있으며, Dos/DDoS와 같은 비정상적인 트래픽을 필터링할 수 있어 네트워크 보안분야에서도 활용된다.</p>
<h3 id="비교"> 비교</h3>
<p><img src="https://user-images.githubusercontent.com/49400801/124132873-3a321680-dabc-11eb-9d92-a5fc111f6378.png" alt="image"></p>
<h3 id="로드밸런서-알고리즘"> 로드밸런서 알고리즘?</h3>
<ul>
<li>Round Robin(순차방식)<br>
: 요청을 순서대로 각 서버에 균등하게 분배하는 방식<br>
서버 커넥션 수나 응답시간에 상관없이 모든 서버를 동일하게 처리, 다른 알고리즘에 비해서 가장 빠르다.</li>
<li>IP 해시 방식(IP Hash Method)<br>
: 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식, 사용자의 IP를 해싱해 로드를 분배하기 때문에 사용자가 항상 동일한 서버로 연결되는 것을 보장한다.</li>
<li>Least Connection(최소접속방식)<br>
: 서버에 연결되어 있는 Connection 개수만 갖고 단순비교하여 가장 적은곳으로 연결</li>
<li>Weighted Least Connections(가중치 최소접속방식)<br>
: 서버에 부여된 Weight 값을 기반으로 Connection 수의 개수와 같이 고려하여 할당</li>
<li>Fastest Response Time(응답시간방식)<br>
: 가장 빨리 응답하는 서버에 이용자 요구를 연결하는 방법. 응답시간은 각 서버가 패킷 형태의 요구를 송수신하는데 걸리는 시간을 측정한 것이다.</li>
<li>Adaptive(최소대기방식)<br>
: Open 또는 Pending(계류중인) 커넥션을 적게 가지고 있는 서버로 네트웍 커넥션 방향을 지정한다.
Pending 커넥션은 Full TCP Handshake를 완성하지 않은 것으로, 이것은 초당 클라이언트 Thread의 수가 증가할 때 더욱 잘 수행된다.</li>
</ul>
<br>
<h2 id="_0703-자바-람다식"> 0703 - 자바 람다식</h2>
<h3 id="람다-표현식-lambda-expressions"> 람다 표현식(Lambda Expressions)</h3>
<h4 id="란다식이란"> 란다식이란?</h4>
<blockquote>
<p>식별자 없이 실행가능한 함수</p>
</blockquote>
<ul>
<li>메소드를 하나의 식으로 표현하는 것이라고 볼 수 있다.</li>
<li>람다식으로 표현하면 return이 없어지므로 람다식을 anonymous function(익명 함수)이라고도 한다.</li>
</ul>
<h4 id="람다식의-장단점"> 람다식의 장단점</h4>
<p>장점</p>
<ul>
<li>코드를 간결하게 만들 수 있다.</li>
<li>가독성이 향상된다.</li>
<li>멀티쓰레드환경에서 용이하다.</li>
<li>함수를 만다는 과정 없이 한번에 처리하기에 생산성이 높아진다.</li>
</ul>
<p>단점</p>
<ul>
<li>람다로 인한 무명함수는 재사용이 불가능한다.</li>
<li>디버깅이 많이 까다록다.</li>
<li>람다를 무분별하게 사용하면 코드가 클린하지 못하다.</li>
<li>재귀로 만들 경우 부적합하다.</li>
</ul>
<h4 id="람다식-사용법"> 람다식 사용법</h4>
<div><pre><code><span>(</span>매개변수<span>)</span> <span>-></span> 표현 바디
<span>(</span>매개변수<span>)</span> <span>-></span> <span>{</span> 표현 바디 <span>}</span>
<span>(</span><span>)</span> <span>-></span> <span>{</span> 표현바디 <span>}</span>
<span>(</span><span>)</span> <span>-></span> 표현 바디
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>기본 예제<br>
LeagueOfLegend, Setting</li>
</ul>
<div><pre><code><span>@FunctionalInterface</span>
<span>interface</span> <span>Setting</span> <span>{</span>
    <span>void</span> <span>setup</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>class</span> <span>LeagueOfLegend</span> <span>{</span>
    <span>public</span> <span>void</span> <span>running</span><span>(</span><span>Setting</span> setting<span>)</span> <span>{</span>
        setting<span>.</span><span>setup</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"LeagueOfLegend running"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>lambdaSample</p>
<div><pre><code><span>public</span> <span>class</span> lambdaSample <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LegueOfLegend</span> leagueOfLegend <span>=</span> <span>new</span> <span>LegueOfLegend</span><span>(</span><span>)</span><span>;</span>
        leagueOfLegend<span>.</span><span>running</span><span>(</span><span>new</span> <span>Setting</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> <span>setup</span><span>(</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"leagueOfLegend is setup"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>=&gt; 결과</p>
<div><pre><code>leagueOfLegend is setup
LeagueOfLegend running
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>람다예제
lambdaSample</li>
</ul>
<div><pre><code><span>public</span> <span>class</span> lambdaSample <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>LeagueOfLegend</span> leagueOfLegenda <span>=</span> <span>new</span> <span>LeagueOfLegend</span><span>(</span><span>)</span><span>;</span>
        leagueOfLegend<span>.</span><span>running</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"leagueOfLegend is setup"</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>=&gt; 결과</p>
<div><pre><code>leagueOfLegend is setup
LeagueOfLegend running
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="functionalinterface"> @FunctionalInterface</h4>
<ul>
<li>Java8 이전에서는 자바에서 값이나 객체가 아닌 하나의 함수를 변수에 담아두는 것은 허용되지 않았다.</li>
<li>Java8에서 람다식이 추가되고 하나의 변수에 하나의 함수를 매핑할 수 있다.</li>
</ul>
<p>예제</p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Funtional</span> <span>{</span>
    <span>public</span> <span>int</span> <span>calc</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>1개의 메소드를 가진 것이 Functional interface 이다. Single Abstract Method(SAM)이라고도 불리기도한다.</li>
<li>@FunctionalInterface를 지정하게되면 이 인터페이스가 함수형 인터페이스라고 명시를 해주고 컴파일러가 SAM 여부를 체크할 수 있도록 한다.</li>
</ul>
<p>예제2 - Various 사용</p>
<div><pre><code><span>Functional</span> add <span>=</span> <span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>-></span> <span>{</span><span>return</span> a <span>+</span> b<span>}</span><span>;</span>
<span>Functional</span> add1 <span>=</span> <span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>-></span> a <span>+</span> b<span>;</span>
<span>Functional</span> add2 <span>=</span> <span>Integer</span><span>::</span><span>sum</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>이 예제는 모두 결과는 같다.</li>
</ul>
<div><pre><code><span>int</span> result <span>=</span> add<span>.</span><span>calc</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>)</span> <span>+</span> add1<span>.</span><span>calc</span><span>(</span><span>2</span><span>,</span> <span>2</span><span>)</span> <span>+</span> add2<span>.</span><span>calc</span><span>(</span><span>3</span><span>,</span> <span>3</span><span>)</span><span>;</span>
<span>// 결과 12</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
      <enclosure url="https://user-images.githubusercontent.com/49400801/124132873-3a321680-dabc-11eb-9d92-a5fc111f6378.png" type="image/png"/>
    </item>
    <item>
      <title>📖 Today I Learned</title>
      <link>ahnjs/TIL/</link>
      <guid isPermaLink="false">ahnjs/TIL/</guid>
      <source url="ahnjs/TIL/rss.xml">📖 Today I Learned</source>
      <pubDate>Thu, 22 Jul 2021 10:09:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="today-i-learned"> 📖 Today I Learned</h1>
<blockquote>
<p>하루동안 인터넷에서 검색했던 내용이나<br>
책에서 읽은 내용을 간단하게 정리하기<br>
주에 한번은 작성했던 내용중 하나를 블로그에 정리하기<br>
가볍게 생각나는데로 적기</p>
</blockquote>
<h2 id="규칙"> 규칙</h2>
<ol>
<li>찾아본 내용을 그대로 복사, 붙여 넣지 말것. 그대로 쓰더라도 직접작성 할 것</li>
<li>꾸준히 쓰는 것도 좋지만 내게 도움되는 방향으로 작성하기</li>
</ol>
<h2 id="목표"> 목표</h2>
<ol>
<li>글쓰는거에 익숙해지기</li>
<li>마크다운 문법에 익숙해지기</li>
<li>매일매일 학습하는 습관 만들기</li>
<li>그날 배웠던 내용들을 간단하게 정리하기</li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>