<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1122 - 1128 | TIL</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="
1122 - toString을 항상 재정의하라
toString()
Object의 기본 toString메서드는 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다. 이 메서드는 클래스이름@16진수로표현한_해시코드
toString()을 재정의 해야 하는 이유
equals와 hashCode 규 ...">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.9729072d.css" as="style"><link rel="preload" href="/TIL/assets/js/app.face42bf.js" as="script"><link rel="preload" href="/TIL/assets/js/6.5d7ec74f.js" as="script"><link rel="preload" href="/TIL/assets/js/11.eca71194.js" as="script"><link rel="preload" href="/TIL/assets/js/47.fb2d1489.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.5c95ce33.js"><link rel="prefetch" href="/TIL/assets/js/12.44862a55.js"><link rel="prefetch" href="/TIL/assets/js/13.3354667d.js"><link rel="prefetch" href="/TIL/assets/js/14.ebd32721.js"><link rel="prefetch" href="/TIL/assets/js/15.9a5da76a.js"><link rel="prefetch" href="/TIL/assets/js/16.0ec9d5c5.js"><link rel="prefetch" href="/TIL/assets/js/17.197aed0f.js"><link rel="prefetch" href="/TIL/assets/js/18.ac1d8f71.js"><link rel="prefetch" href="/TIL/assets/js/19.52554e37.js"><link rel="prefetch" href="/TIL/assets/js/20.d49a3176.js"><link rel="prefetch" href="/TIL/assets/js/21.703e3b5b.js"><link rel="prefetch" href="/TIL/assets/js/22.b15b40cf.js"><link rel="prefetch" href="/TIL/assets/js/23.f660074b.js"><link rel="prefetch" href="/TIL/assets/js/24.7cae7b6d.js"><link rel="prefetch" href="/TIL/assets/js/25.4544b20e.js"><link rel="prefetch" href="/TIL/assets/js/26.1b3a0d64.js"><link rel="prefetch" href="/TIL/assets/js/27.ef321cf3.js"><link rel="prefetch" href="/TIL/assets/js/28.6559ba71.js"><link rel="prefetch" href="/TIL/assets/js/29.724725e7.js"><link rel="prefetch" href="/TIL/assets/js/3.70c77cf4.js"><link rel="prefetch" href="/TIL/assets/js/30.a52d1089.js"><link rel="prefetch" href="/TIL/assets/js/31.198eeb03.js"><link rel="prefetch" href="/TIL/assets/js/32.1c678662.js"><link rel="prefetch" href="/TIL/assets/js/33.f3411971.js"><link rel="prefetch" href="/TIL/assets/js/34.92db02e4.js"><link rel="prefetch" href="/TIL/assets/js/35.e45ae628.js"><link rel="prefetch" href="/TIL/assets/js/36.454a23c3.js"><link rel="prefetch" href="/TIL/assets/js/37.0853aeff.js"><link rel="prefetch" href="/TIL/assets/js/38.f4787dfc.js"><link rel="prefetch" href="/TIL/assets/js/39.fa931ac4.js"><link rel="prefetch" href="/TIL/assets/js/4.851786b4.js"><link rel="prefetch" href="/TIL/assets/js/40.2f2b7cc1.js"><link rel="prefetch" href="/TIL/assets/js/41.af69bea0.js"><link rel="prefetch" href="/TIL/assets/js/42.266b80d2.js"><link rel="prefetch" href="/TIL/assets/js/43.9eca0436.js"><link rel="prefetch" href="/TIL/assets/js/44.3c9dd560.js"><link rel="prefetch" href="/TIL/assets/js/45.839c0213.js"><link rel="prefetch" href="/TIL/assets/js/46.44355db1.js"><link rel="prefetch" href="/TIL/assets/js/48.117f6110.js"><link rel="prefetch" href="/TIL/assets/js/49.f5f58c80.js"><link rel="prefetch" href="/TIL/assets/js/5.a40fa64b.js"><link rel="prefetch" href="/TIL/assets/js/50.bf663577.js"><link rel="prefetch" href="/TIL/assets/js/51.c3bdfcaa.js"><link rel="prefetch" href="/TIL/assets/js/52.5a372c16.js"><link rel="prefetch" href="/TIL/assets/js/53.796d7943.js"><link rel="prefetch" href="/TIL/assets/js/54.c46aa092.js"><link rel="prefetch" href="/TIL/assets/js/55.3e3ec3b1.js"><link rel="prefetch" href="/TIL/assets/js/56.e7675ae5.js"><link rel="prefetch" href="/TIL/assets/js/57.7e5b274a.js"><link rel="prefetch" href="/TIL/assets/js/58.8674754f.js"><link rel="prefetch" href="/TIL/assets/js/59.b922d1c3.js"><link rel="prefetch" href="/TIL/assets/js/60.7ce728db.js"><link rel="prefetch" href="/TIL/assets/js/61.e69f607b.js"><link rel="prefetch" href="/TIL/assets/js/62.f6f4222a.js"><link rel="prefetch" href="/TIL/assets/js/63.e9323ce2.js"><link rel="prefetch" href="/TIL/assets/js/64.d0c85d08.js"><link rel="prefetch" href="/TIL/assets/js/65.a9819011.js"><link rel="prefetch" href="/TIL/assets/js/66.c87d09bc.js"><link rel="prefetch" href="/TIL/assets/js/67.7ca58cbd.js"><link rel="prefetch" href="/TIL/assets/js/68.321ea5a8.js"><link rel="prefetch" href="/TIL/assets/js/69.a7741122.js"><link rel="prefetch" href="/TIL/assets/js/7.fda50c33.js"><link rel="prefetch" href="/TIL/assets/js/70.bdeee399.js"><link rel="prefetch" href="/TIL/assets/js/71.f312da68.js"><link rel="prefetch" href="/TIL/assets/js/72.91f45247.js"><link rel="prefetch" href="/TIL/assets/js/73.88953b79.js"><link rel="prefetch" href="/TIL/assets/js/74.d1611c1b.js"><link rel="prefetch" href="/TIL/assets/js/75.37f9e0f8.js"><link rel="prefetch" href="/TIL/assets/js/76.dc32c379.js"><link rel="prefetch" href="/TIL/assets/js/77.5433e0a6.js"><link rel="prefetch" href="/TIL/assets/js/78.6fda6ca0.js"><link rel="prefetch" href="/TIL/assets/js/79.3e50b7b1.js"><link rel="prefetch" href="/TIL/assets/js/8.584bc921.js"><link rel="prefetch" href="/TIL/assets/js/80.18405258.js"><link rel="prefetch" href="/TIL/assets/js/81.e4ccf68a.js"><link rel="prefetch" href="/TIL/assets/js/82.6b7c1912.js"><link rel="prefetch" href="/TIL/assets/js/83.34d29caa.js"><link rel="prefetch" href="/TIL/assets/js/84.ee39d9de.js"><link rel="prefetch" href="/TIL/assets/js/85.1184af6c.js"><link rel="prefetch" href="/TIL/assets/js/86.138caca8.js"><link rel="prefetch" href="/TIL/assets/js/87.038c2438.js"><link rel="prefetch" href="/TIL/assets/js/9.ad0ae255.js"><link rel="prefetch" href="/TIL/assets/js/vuejs-paginate.e9164293.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.9729072d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/TIL/" class="nav-link home-link">TIL </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="https://github.com/jaesungahn91" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li><li class="nav-item"><a href="https://velog.io/@ahnjs" target="_blank" rel="noopener noreferrer" class="nav-link external">Blog</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/TIL/" class="nav-link mobile-home-link">TIL </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="https://github.com/jaesungahn91" target="_blank" rel="noopener noreferrer" class="nav-link external">GitHub</a></li><li class="mobile-nav-item"><a href="https://velog.io/@ahnjs" target="_blank" rel="noopener noreferrer" class="nav-link external">Blog</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div><div class="content__default"><h1 id="_1122-1128"><a href="#_1122-1128" class="header-anchor">#</a> 1122 - 1128</h1> <h2 id="_1122-tostring을-항상-재정의하라"><a href="#_1122-tostring을-항상-재정의하라" class="header-anchor">#</a> 1122 - toString을 항상 재정의하라</h2> <h3 id="tostring"><a href="#tostring" class="header-anchor">#</a> toString()</h3> <p>Object의 기본 toString메서드는 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다. 이 메서드는 <code>클래스_이름@16진수로_표현한_해시코드</code>를 반환한다.</p> <h3 id="tostring-을-재정의-해야-하는-이유"><a href="#tostring-을-재정의-해야-하는-이유" class="header-anchor">#</a> toString()을 재정의 해야 하는 이유</h3> <p>equals와 hashCode 규약 만큼 대단히 중요하진 않지만, toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다. toString 메서드는 객체를 println, printf, 문자열 연결 연산자(+), assert 구문에 넘길 때, 혹은 디버거가 객체를 출력할 때 자동으로 불린다. 여러분이 직접 호출하지 않더라도 다른 어딘가에서 쓰인다. 예를들어 객체를 참조하는 컴포넌트가 오류 페이지를 로딩할 때 자동으로 호출 될 수 있다. 이때 toString을 제대로 재정의하지 않는다면 쓸모없는 메시지만 로그에 남는다.</p> <h3 id="tostring-재정의시-주의-사항"><a href="#tostring-재정의시-주의-사항" class="header-anchor">#</a> toString 재정의시 주의 사항</h3> <ul><li>실전에서 toString은 그 객체가 가진 주요 정보를 모두 반환하는게 좋다.
<ul><li>하지만 객체가 거대하거나 객체의 상태의 문자열로 표현하기 어렵다면, 요약 정보를 담아야한다.</li></ul></li> <li>toString을 구현할 때면 반환값의 포맷을 문서화할지 정해야 한다.
<ul><li>포맷을 명시하면 그 객체는 표준적이고, 명확하고, 사람이 읽을 수 있게 된다.</li> <li>다만, 포맷을 한번 명시하면 얽매이게 된다.</li></ul></li> <li>포맷을 명시하든 아니든 의도는 명확히 밝혀야 한다.</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/** * 이 약물에 관한 대략적인 설명을 반환한다. * 다음은 이 설명의 일반적인 형태이나, * 상세 형식은 정해지지 않았으며 향후 변경될 수 있다. * * &quot;[약물 #9: 유형=사랑, 냄새=테레빈유, 겉모습=먹물]&quot; */</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
</code></pre></div><ul><li>정적 유틸리티 클래스는 toString을 제공할 이유가 없고, 대부분의 결거 타입도 자바가 이미 완벽한 toString을 제공하니 따로 재정의하지 않아도 된다.
<ul><li>하지만, 하위 클래스들이 공유해야 할 문자열 표현이 있는 추상 클래스라면 toString을 재정의 해줘야 하며, 대다수 컬렉션 구현체는 추상 컬렉션 클래스들의 toStirng메서드를 상속해서 사용한다.</li></ul></li></ul> <h2 id="_1123-crudrepository-vs-jparepository"><a href="#_1123-crudrepository-vs-jparepository" class="header-anchor">#</a> 1123 - CrudRepository vs JpaRepository</h2> <p><img src="https://blog.kakaocdn.net/dn/HqURy/btq9aM1qvwy/Difw4KKvjTyCcGUcxKahok/img.png" alt="image">
위 상속관계를 살펴보면, 최상위 부모인 Repository를 CrudRepository가 상속받아 확장시키고, 이를 PagingAndSortingRepository가, 그리고 이를 또 JpaRepository가 상속받아 확장시킨 것을 볼 수 있다.</p> <p>각각 소스코드를 IDE를 통해 상세히 살펴볼 수 있지만, 구조상으로 JpaRepository의 구현체들이 당연히 더 많다. 사용하고자 하는 도메인이 어느 정도의 수준까지 필요한가에 따라 사용.</p> <ul><li>CrudRepository : CRUD 관련 기능을 제공. (간단한 CRUD만 필요한 경우)</li> <li>PagingAndSortingRepository : 페이징과 솔팅을 추가로 제공.</li> <li>JpaRepository : 위 기능은 물론 JPA 관련 특화된 기능(지속성 컨텍스트 플러시 및 배치에서 레코드 삭제)들을 제공.</li></ul> <h2 id="_1124-maven-다중모듈-의존성"><a href="#_1124-maven-다중모듈-의존성" class="header-anchor">#</a> 1124 - Maven 다중모듈, 의존성</h2> <h3 id="maven환경-다중-모듈-프로젝트-생성"><a href="#maven환경-다중-모듈-프로젝트-생성" class="header-anchor">#</a> Maven환경 다중 모듈 프로젝트 생성</h3> <ol><li>parent 프로젝트 생성
<ul><li>Maven Project로 생성</li> <li>packaging : pom</li></ul></li> <li>'Parent'의 pom을 상속받는 프로젝트 생성
<ul><li>Maven Module로 생성</li> <li>Parent 를 1에서 정의한 프로젝트로 설정</li></ul></li></ol> <p>=&gt; 하위 프로젝트는 parent에서 정의한 pom.xml(dependency, repository 등등..) 을 그대로 사용할 수 있다.</p> <h3 id="다중-모듈간-클래스-사용"><a href="#다중-모듈간-클래스-사용" class="header-anchor">#</a> 다중 모듈간 클래스 사용</h3> <ul><li>별다른 설정 필요 없이, 둘다 Maven 프로젝트이며 같은 Workspace안에 있을 경우 Dependency로 추가</li></ul> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.mypjt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>myProjectA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> 
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><br> <h2 id="_1125-spring-bean-lifecycle-스프링-빈-생명주기"><a href="#_1125-spring-bean-lifecycle-스프링-빈-생명주기" class="header-anchor">#</a> 1125 - Spring Bean LifeCycle(스프링 빈 생명주기)</h2> <h3 id="빈-생명주기-콜백"><a href="#빈-생명주기-콜백" class="header-anchor">#</a> 빈 생명주기 콜백</h3> <p>데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.</p> <p>스프링 빈도 위와 같은 원리로 초기화 작업과 종료 작업이 나눠서 진행된다.<br>
간단하게 말하면 <code>객체 생성 -&gt; 의존관계 주입</code>이라는 라이프사이클을 가진다.</p> <p>즉, 스프링 빈은 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.</p> <h4 id="spring-의존관계-주입-과정"><a href="#spring-의존관계-주입-과정" class="header-anchor">#</a> Spring 의존관계 주입 과정</h4> <ul><li>가장 처음에는 Spring IoC 컨테이너가 먼저 만들어지는 과정이 일어난다.
<ul><li>Component-Scan으로 Bean을 등록한다.</li> <li>@Configuration, @Controller, @Service 등등 Bean으로 등록할 수 있는 어노테이션들과 설정파일들을 읽어 IoC 컨테이너 안에 Bean으로 등록한다.</li></ul></li> <li>의존 관계를 주입하기 전의 준비 단계까 존재하는데, 이 단계에서 객체의 생성이 일어난다.
<ul><li>생성자 주입: 객체의 생성과 의존관계 주입이 동시에 일어난다.</li> <li>setter, Field 주입: 객체의 생성 -&gt; 의존관계 주입으로 라이프 사이클이 나누어진다.</li></ul></li></ul> <h4 id="스프링-의존관계-주입이-완료된-시점을-어떻게-알-수-있을까"><a href="#스프링-의존관계-주입이-완료된-시점을-어떻게-알-수-있을까" class="header-anchor">#</a> 스프링 의존관계 주입이 완료된 시점을 어떻게 알 수 있을까?</h4> <p>Bean으로 등록된 객체들은 의존관계 주입이 완료된 후에 초기화 작업을 진행해야 한다.</p> <ul><li>스프링의 Bean LifeCycle</li></ul> <div class="language- extra-class"><pre class="language-text"><code>스프링 컨테이너 생성 -&gt; 스프링 빈 생성 -&gt; 의존관계 주입 -&gt; 초기화 콜백 -&gt; 사용 -&gt; 소멸 전 콜백 -&gt; 스프링 종료
</code></pre></div><p>스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메소드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 제공한다.</p> <ul><li>초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출</li> <li>소멸전 콜백 : 빈이 소멸되기 직전에 호출</li></ul> <blockquote><p>객체의 생성과 초기화를 분리하자<br>
생성자는 필수 정보를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에 초기화는 이렇게 생성된 값들을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다.<br>
따라서 생성자 안에서 무거운 초기화 작업을 함께 하는 것 보다는 객체를 생성하는 부분과 초기화 하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다.</p></blockquote> <h3 id="빈-생명주기-콜백-지원-방법"><a href="#빈-생명주기-콜백-지원-방법" class="header-anchor">#</a> 빈 생명주기 콜백 지원 방법</h3> <ul><li>인터페이스(InitializaingBean, DisposableBean)</li> <li>설정 정보에 초기화 메소드, 종료 메소드 지정</li> <li>@PostConstruct, @PreDestroy 어노테이션 지원</li></ul> <h4 id="_1-인터페이스-initializaingbean-disposablebean"><a href="#_1-인터페이스-initializaingbean-disposablebean" class="header-anchor">#</a> 1. 인터페이스(InitializaingBean, DisposableBean)</h4> <ul><li>상속을 통한 생명주기 콜백 지원</li> <li>InitializaingBean -&gt; afterPropertiesSet 메소드로 초기화 지원</li> <li>DisposableBean -&gt; destroy 메소드로 소멸을 지원</li> <li>초기화, 소멸메서드의 이름을 변경 할 수 없다.</li> <li>외부 라이브러리에 적용 할 수 없다.</li> <li>현재 거의 사용하지 않는다.</li></ul> <h4 id="_2-postconstruct-predestory-어노테이션"><a href="#_2-postconstruct-predestory-어노테이션" class="header-anchor">#</a> 2. @PostConstruct, @PreDestory 어노테이션</h4> <ul><li>최신 스프링에서 가장 권장하는 방법.</li> <li>컴포넌트 스캔과 잘어울림.</li> <li>javax.annotation.PostConstruct 패키지로, 스프링 종속 X, 자바 표준</li></ul> <h4 id="_3-빈-등록-초기화-소멸-메소드-지정"><a href="#_3-빈-등록-초기화-소멸-메소드-지정" class="header-anchor">#</a> 3. 빈 등록 초기화, 소멸 메소드 지정</h4> <ul><li>설정 정보에 <code>@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;close&quot;)</code>처럼 초기화, 소멸 메소드를 지정</li></ul> <br> <h2 id="_1127-filter-interceptor-aop-차이"><a href="#_1127-filter-interceptor-aop-차이" class="header-anchor">#</a> 1127 - Filter, Interceptor, AOP 차이</h2> <ul><li>공통 프로세스에 대한 처리
<ul><li>로그인 관련(세션체크)처리, 권한체크, XSS방어, pc와 모바일웹의 분기처리, 로그, 페이지 인코딩 변환 등</li></ul></li> <li>스프링에서 사용되는 Filter, Interceptor, AOP 세 가지 기능은 모두 무슨 행동을 하기전에 먼저 실행하거나, 실행한 후에 추가적인 행동을 할 때 사용되는 기능Handler들이다.</li> <li>순서</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Filter -&gt; Interceptor -&gt; AOP -&gt; Interceptor -&gt; Filter

1. 서버를 실행시켜 서블릿이 올라오는 동안에 init이 실행되고, 그 후 doFilter가 실행된다.
2. 컨트롤러에 들어가기 전 preHandler가 실행된다.
3. 컨트롤러에서 나와 postHandler, after Completion, doFilter 순으로 진행이 된다.
4. 서블릿 종료 시 destroy가 실행된다.
</code></pre></div><ul><li>Filter와 Interceptor는 Servlet 단위에서 이루어진다. 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.</li> <li>실행순서를 보면 Filter가 가장 밖에 있고 그안에 Interceptor, 그안에 AOP가 있는 형태이다.</li></ul> <h3 id="_1-filter-필터"><a href="#_1-filter-필터" class="header-anchor">#</a> 1. Filter(필터)</h3> <p>말 그대로 요청과 응답을 거른뒤 정제하는 역할을 한다.<br>
서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나, 여러가지 체크를 수행할 수 있다.<br>
또한 자원의 처리가 끝난 후 응답내용에 대해서도 변경하는 처리를 할 수가 있다.</p> <h4 id="실행-메서드"><a href="#실행-메서드" class="header-anchor">#</a> 실행 메서드</h4> <ul><li>init() - 필터 인스턴스 초기화</li> <li>doFilter() - 전/후 처리</li> <li>destroy() - 필터 인스턴스 종료</li></ul> <h3 id="_2-interceptor-인터셉터"><a href="#_2-interceptor-인터셉터" class="header-anchor">#</a> 2. Interceptor(인터셉터)</h3> <p>요청에 대한 작업 전/후로 가로챈다.<br>
필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다. 하지만 인터셉터는 스프링의 DispatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대한 처리를한다.<br>
스프링의 모든 빈 객체에 접근할 수 있다.<br>
인터셉터는 여러 개를 사용할 수 있고 로그인 체크, 권한체크, 프로그램 실행시간 계산작업 로그확인 등의 업무처리</p> <h4 id="실행-메서드-2"><a href="#실행-메서드-2" class="header-anchor">#</a> 실행 메서드</h4> <ul><li>preHandler() - 컨트롤러 메서드가 실행되기 전</li> <li>postHandler() - 컨트롤러 메서드 실행직 후 view페이지 렌더링 되기 전</li> <li>afterCompletion() - view페이지가 렌더링 되고 난 후</li></ul> <h3 id="_3-aop"><a href="#_3-aop" class="header-anchor">#</a> 3. AOP</h3> <p>OOP를 보완하기 위해 나온 개념<br>
객체지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.<br>
주로 로깅, 트랜잭션, 에러처리 등 비지니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용한다.</p> <p>Interceptor나 Filter와 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다. Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상을 지정할 수 있다.</p> <p>AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이다. Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다. 반면 HandlerInterceptor는 Filter와 유사하가 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다.</p> <h4 id="aop의-포인트컷"><a href="#aop의-포인트컷" class="header-anchor">#</a> AOP의 포인트컷</h4> <ul><li>@Before: 대상 메서드의 수행 전</li> <li>@After: 대상 메서드의 수행 후</li> <li>@Atter-returning: 대상 메서드의 정상적인 수행 후</li> <li>@After-throwing: 예외발생 후</li> <li>@Around: 대상 메서드의 수행 전/후</li></ul></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/TIL/assets/js/app.face42bf.js" defer></script><script src="/TIL/assets/js/6.5d7ec74f.js" defer></script><script src="/TIL/assets/js/11.eca71194.js" defer></script><script src="/TIL/assets/js/47.fb2d1489.js" defer></script>
  </body>
</html>
