# 1010 ~ 1016

## 1011 - 생성자 바인딩(Constructor Binding)로 프로퍼티(Properties) 설정 값 불러오기
#### [ 생성자로 바인딩하기(@ConstructorBinding) ]
- 설정파일
```java
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.url=jdbc:h2:mem:db;DB_CLOSE_DELAY=-1
spring.datasource.username=h2test
spring.datasource.password=h2test
```

- 생상자를 이용해 properties의 값을 바인딩하도록 @ConstructorBinding 어노테이션을 추가
```java
@Getter
@RequiredArgsConstructor
@ConfigurationProperties(prefix = "spring.datasource")
@ConstructorBinding
public class DataSourceProperties {

	private final String driverClassName;
	private final String url;
	private final String username;
	private final String password;

}
```

<br>

## 1012 - 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유
### 1. 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유
#### [ 불변 객체(Immutable Object)란? ]
불변 객체란 객체 생성 이후 내부의 상태가 변하지 않는 객체이다. 불변 객체는 read-only 메소드만을 제공하며, 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사(defensive-copy)를 통해 제공한다. Java의 대표적인 불변 객체로는 String이 있다.
```java
String name = "Old";
name.toCharArray()[0] = 'E';
```

Java의 String은 불변 클래스이기 떄문에 위와 같이 String 내부의 char형 배열을 얻어 수정하여도 반영되지 않는다. Java에서는 배열이나 객체 등의 참조(Reference)를 전달한다. 그렇기 때문에 참조를 통해 값을 수정하면 내부의 상태가 변하기 때문에 내부를 복사하여 전달하고 있는데, 이를 방어적 복사(defensive-copy)라고 한다. String의 toCharArray는 다음과 같이 복사하여 전달하고 있다.
```java
public char[] toCharArray() {
    // Cannot use Arrays.copyOf because of class initialization order issues
    char result[] = new char[value.length];
    System.arraycopy(value, 0, result, 0, value.length);
    return result;
}
```

#### [ 불변 객체 및 final을 사용해야 하는 이유 ]
> Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
- 멀티 쓰레드 환경에서 동기화 문제가 발생하는 이유는 공유 자원에 동시에 쓰기(Write) 때문이다. 하지만 만약 공유 자원이 불변이라면 항상 동일한 값을 반환하기 때문에 동기화를 고려하지 않아도 된다. 이는 안정성을 보장할 뿐만 아니라 동기화를 하지 않음으로써 성능상의 이점도 가져다준다.

> 실패 원자적인(Failure Atomic) 메소드를 만들 수 있다.  
- 가변 객체를 통해 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있고, 불안정한 상태를 갖는 객체는 또 다른 에러를 유발할 수 있다. 하지만 불변 객체라면 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지할 수 있을 것이다. 그리고 예외가 발생하여도 오류가 발생하지 않은 것 처럼 다음 로직을 처리할 수 있다.

>  Cache나 Map 또는 Set 등의 요소로 활용하기에 더욱 적합하다.  
- 만약 캐시나 Map, Set 등의 원소인 가변 객체가 변경되었다면 이를 갱신하는 등의 부가 작업이 필요할 것이다. 하지만 불변 객체라면 한 번 데이터가 저장된 이후에 다른 작업들을 고려하지 않아도 되므로 사용하는데 용이하게 작용할 것이다.

- 부수 효과(Side Effect)를 피해 오류가능성을 최소화할 수 있다.
- 다른 사람이 작성한 함수를 예측가능하며 안전하게 사용할 수 있다.
- 가비지 컬렉션의 성능을 높일 수 있다.