# 1128 ~ 1211

## 1201 - Spring REST Docs + Rest Assured
**[ build.gradle ]**  

```gradle
plugins {
    ...
    // Asciidoctor 플러그인을 적용
    id "org.asciidoctor.jvm.convert" version "3.3.2"
    ...
}

configurations {
    ...
    // asciidoctorExtAsciidoctor를 확장하는 종속성에 대한 구성을 선언
    asciidoctorExt
    ...
}

dependencies {
    ...
    // asciidoctorExt : spring-restdocs-asciidoctor 구성 의존성을 추가
    // snippets을 .adoc로 가리키고 build/generated-snippets 생성되도록 자동으로 구성 
    asciidoctorExt 'org.springframework.restdocs:spring-restdocs-asciidoctor'
    // spring-restdocs-restassured 의존성을 추가
    testImplementation 'org.springframework.restdocs:spring-restdocs-restassured'
    ...
}

ext {
    ...
    // 생성된 스니펫의 출력 위치를 정의하도록 속성을 구성
    set('snippetsDir', file("build/generated-snippets"))
    ...
}

tasks.named('test') {
    outputs.dir snippetsDir
    useJUnitPlatform()
}


tasks.named('asciidoctor') {
    inputs.dir snippetsDir
    // 	asciidoctorExt확장 에 대한 구성 사용을 구성
    configurations 'asciidoctorExt'
    dependsOn test
}

tasks.named('bootJar') {
    dependsOn asciidoctor
    // 생성된 문서를 jar static/docs디렉토리에 복사
    copy {
        from "${asciidoctor.outputDir}"
        into 'src/main/resources/static/docs'
    }
}
```

**[ 테스트 클래스 ]** 

- AcceptanceTest
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ExtendWith({RestDocumentationExtension.class, SpringExtension.class})
public class AcceptanceTest {

    @LocalServerPort
    int port;

    protected RequestSpecification spec;

    @BeforeEach
    public void setUp(RestDocumentationContextProvider restDocumentation) {
        RestAssured.port = port;
        this.spec = new RequestSpecBuilder()
                .addFilter(documentationConfiguration(restDocumentation))
                .build();
    }

}
```

- OrderRestControllerTest
```java
class OrderRestControllerTest extends AcceptanceTest {

    @Test
    void postOrder() {
        // given
        String menuName = "메뉴";

        // when
        ExtractableResponse<Response> response = 주문_생성_요청(menuName, 2);
        OrderModel order = response.as(OrderModel.class);

        // then
        assertThat(response.statusCode()).isEqualTo(HttpStatus.OK.value());
        assertThat(order.getMenuName()).isEqualTo(menuName);
    }

    private ExtractableResponse<Response> 주문_생성_요청(String menuName, Integer quantity) {
        OrderPostRequestDTO dto = new OrderPostRequestDTO(menuName, quantity);

        return RestAssured
                .given(this.spec).log().all()
                .accept(APPLICATION_JSON_VALUE)
                .filter(document("post-order",
                        requestFields(
                                fieldWithPath("order.menuName").type(STRING).description("order menu name"),
                                fieldWithPath("order.quantity").type(NUMBER).description("order quantity")),
                        responseFields(
                                fieldWithPath("order.menuName").type(STRING).description("order menu name"),
                                fieldWithPath("order.quantity").type(NUMBER).description("order quantity"))
                ))
                
                .body(dto)
                .contentType(APPLICATION_JSON_VALUE)
                .when().post("/orders")
                .then().log().all()
                .extract();
    }
}
```

**[ adoc 문서 작성 ]**  

- common.adoc
```adoc
[[index]]
=== link:./index-docs.html[HOME]

[[common]]
== Common API Docs

=== HTTP Status Code
[cols="2,3,5"]
|===
| Code | Description | Constraint

| 200
| Success
|

| 400
| Bad Request
|
|===
```

- order.adoc
```adoc
= Order API
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectlinks:

include::{docfile}/../common.adoc[]

== Order API Docs

=== POST /orders
Curl Request
include::{snippets}/post-order/curl-request.adoc[]

Request Headers

Path Parameters

Request Parameters

Request Fields
include::{snippets}/post-order/request-fields.adoc[]

Response Fields
include::{snippets}/post-order/response-fields.adoc[]

HTTP Request
include::{snippets}/post-order/http-request.adoc[]

HTTP Response
include::{snippets}/post-order/http-response.adoc[]
```

<br>

## 1205 - Caffeine Cache
### Caffeine vs EhCache
- Ehcache는 multi-level 캐시, distributed 캐시, 캐시 리스너 등과 같은 많은 기능을 지원한다.
- Caffeine은 Ehcache보다 캐시의 성능이 높으며, 실제로 더 우수한 캐시 제거 전략을 사용한다.(Window TinyLfu 퇴출 정책을 사용, 거의 최적의 적중률을 제공)

### Caffeine 기능
#### **[ Population Strategy ]**
캐시 추가 전략

Caffeine Cache는 아래의 세가지 타입의 캐시로 제작하여 사용할 수 있다.

1. Manual
> Cache<K, V> cache = Caffeine.newBuilder().build()

엔트리를 자동 로드하는 캐시를 생성.

2. Loading (Synchronously)
> LoadingCache<K, V> cache = Caffeine.newBuilder().build(CacheLoader<> loader)

동기 방식으로 loader를 통해 캐시 생성한다.

3. Asynchronous Loading
> AsyncLoadingCache<K, V> cache = Caffeine.newBuilder().buildAsync( ... );

비동기 방식으로 loader를 통해 캐시 생성한다.

#### **[ Eviction ]**
Caffeine Cache는 아래의 세가지 타입으로 캐시를 Evict하는 설정을 할 수 있다.  

1. Size-based
> Caffeine.newBuilder().maximumSize(long)

크기 기준으로 캐시를 제거하는 방식은 개발자가 설정한 특정 값을 기준으로, entries의 크기가 그 값을 넘을 떄 entries의 일부분을 제거한다.(Window TinyLfu를 적용하여 가장 최근에 사용되지 않았거나, 자주 사용되어지지 않은 것을 제거)

2. Time-based
> Caffeine.newBuilder().expireAfterAccess(long)  
> Caffeine.newBuilder().expireAfterWrite(long[, TimeUnit])  
> Caffeine.newBuilder().expireAfter(Expiry)

- expireAfterAccess : (캐시 생성 이후) 해당 값이 가장 최근에 대체되거나 마지막으로 읽은 후 특정 기간이 지나면 각 항목이 캐시에서 자동으로 제거되도록 지정한다.
- expireAfterWrite : 캐시 생성 후 또는 가장 최근에 바뀐 후 특정 기간이 지나면 각 항목이 캐시에서 자동으로 제거되도록 지정한다.
- expireAfter : 캐시가 생성되거나 마지막으로 업데이트된 후 지정된 시간 간격으로 캐시를 새로 고침한다.

3. Reference-based
> Caffeine.newBuilder().weakKeys().weakValues()  
> Caffeine.newBuilder().softValues()

- Caffeine.weakKeys(), Caffeine.weakValues() : Week References를 사용하여 키를 저장한다. Week References는 키에 대한 다른 강력한 참조(Strong References)가 없는 경우 가비지 수집할 수 있다. 가비지 수집은 identity에만 의존하므로 전체 캐시가 동등성(.equals()) 대신 identity 동일성(==)을 사용하여 키를 비교한다.

- Caffeine.softValues() : Soft References를 사용하여 값을 저장한다. Soft References 오브젝트는 메모리 수요에 따라 least-recently-used 방식으로 가비지가 수집된다. 소프트 레퍼런스를 사용하면 퍼포먼스가 영향을 받기 때문에 일반적으로 예측 가능한 최대 캐시 크기를 사용하는 것이 좋다. softValues()를 사용하면 Week References와 마찬가지로 값이 equals 대신 identity(==) equality를 사용하여 비교된다.

#### **[ Notification of Removal ]**
제거되는 캐시 엔트리에 대해 리스너를 달아 추가적인 작업을 할 수 있다.

> Caffeine.newBuilder()  
    .evictionListener((K, V, RemovalCause) -> { /* ... */ })  
    .removalListener((K, V, RemovalCause) -> { /* ... */ })  
    .build();  

두 리스너의 차이는 캐시 관련 용어를 이해하면 적절히 사용할 수 있다.

- Eviction : 캐시 정책 Policy에 의한 삭제
- Invalidation : Caller에 의한 수동 삭제
- Removal : invalidation과 eviction, 두 가지를 모두 포함

ex)
```java
Cache<Key, Graph> graphs = Caffeine.newBuilder()
    .evictionListener((Key key, Graph graph, RemovalCause cause) ->
        System.out.printf("Key %s was evicted (%s)%n", key, cause))
    .removalListener((Key key, Graph graph, RemovalCause cause) ->
        System.out.printf("Key %s was removed (%s)%n", key, cause))
    .build();
```

#### **[ Compute ]**
외부 데이터(리소스)에 접근하며 캐시를 쓸 수 있다.

> graphs.asMap().compute(key, (k, v) -> { /* ... */ });

불러온 캐시 데이터를 Map으로 변경한 후 키를 차례로 조작할 수 있다. 
```java
graphs.asMap().compute(key, (k, v) -> {
  Graph graph = createExpensiveGraph(key);
  ... // update a secondary store
  return graph;
});

map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg))
```

#### **[ Statistics ]**
캐시 액세스 통계 정보를 제공한다. 통계 정보를 사용하면 Caffeine.recordStats()를 설정해주면 된다.

Cache.stats() 메소드가 CacheStats를 반환해준다. CacheStats는 아래와 같은 내용을 가진다.
```java
public final class CacheStats {

    // ... 
    private final long hitCount;
    private final long missCount;
    private final long loadSuccessCount;
    private final long loadFailureCount;
    private final long totalLoadTime;
    private final long evictionCount;
    private final long evictionWeight;
    // ... 
    public double hitRate() {/* ... */}
    public long evictionCount() {/* ... */}
    public double averageLoadPenalty() {/* ... */}
    // ... 
}
```

### Caffeine Configuration
- dependency
```maven
<dependency>
  <groupId>com.github.ben-manes.caffeine</groupId>
  <artifactId>caffeine</artifactId>
  <version>3.0.6</version>
</dependency>
```

- yml
```yaml
spring:
  cache:
    caffeine:
      spec: maximumSize=500,expireAfterWrite=5s
    type: caffeine
    cache-names:
      - users
      - books
```

- @configuration
```java
@Configuration
@EnableCaching
public class CaffeineCacheConfig { /* ... */ }
```

ex)
```java
@EnableCaching
@Configuration
public class CacheConfig {

    @Bean
    public Caffeine caffeineConfig() {
        return Caffeine
                .newBuilder()
                .maximumSize(10_000)
                .expireAfterWrite(60, TimeUnit.MINUTES);
    }

    @Bean
    public CacheManager cacheManager(Caffeine caffeine) {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(caffeine);
        return cacheManager;
    }
}
```

<br>

## 1209 - Java 17
- 2021년 9월 출시
- LTS(Long Term Support)
    - Java 8의 종료 일정(EOL, End of Life)이 Java 11보다 뒤인 JDK(Java Development Kit)


<br>

## 1210 - 
### 