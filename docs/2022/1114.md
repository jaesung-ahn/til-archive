# 1114 ~ 1120
 
## 1114 - 도메인 주도 설계의 모듈 구성(패키지 구성)
### 계층 기반 패키지
가장 단순한 첫번째 설계원칙인 수평 계층형 아키텍처  
![image](https://gocheat.github.io/assets/images/2021-03-02-clean-arc-package/1.png)
- 기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할. 보통 웹베이스 코딩을 하게 되면 `MVC`, `MVP` 패턴으로 개발을 하게 되는데 이도 `계층 기반 패키지`라고 부르며 각 계층은 유사한 종류의 것들을 묶는 도구로 사용
- 이 전형적인 아키텍처에서는 `사용 인터페이스`, `업무규칙`, `영속성코드`를 계층이 각각 하나씩 존재하며, 임의의 N계층은 반드시 N+1계층에만 의존 해야한다.

### 기능(도메인) 기반 패키지
기능 기반 패키지는 서로 연관된 기능, 도메인 개념 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식.  
특정 기능을 지칭하는 하나의 패키지 내에 모든 타입과, 개념을 반영해서 구현.  
![image](https://gocheat.github.io/assets/images/2021-03-02-clean-arc-package/2.png)
- 인터페이스와 클래스가 모두 단 하나의 패키지에 속한다. 이로 인해 코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게 된다. 따라서 이 코드베이스가 계층단위(웹, 서비스, 리포지토리)가 아니라 주문(업무 도메인)과 관련된 무언가를 한다는 것을 볼 수 있다.
- 변경시 변경해야 할 코드가 모두 한 패키지 내에 응집력을 갖고 있기때문에 유리하다.

### 포트와 어댑터
엉클 밥에 따르면 `포트와 어댑터` 혹은 `육각형 아키텍처`, `경계, 컨트롤러, 엔티티` 등의 방식으로 접근하는 이유는 업무/도메인에 초점을 둔 코드가 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해서이다.  
![image](https://gocheat.github.io/assets/images/2021-03-02-clean-arc-package/3.png)
'내부' 영역은 도메인 개념을 모두 포함하는 반면, '외부'영역은 UI, 데이터베이스, 서드파티등과의 상호작용을 포함한다. 여기서 중요한 규칙은 '외부'가 '내부'에 의존하며, 그 반대는 불가능하다.  
![image](https://gocheat.github.io/assets/images/2021-03-02-clean-arc-package/3-2.png)
- 도메인 주도 설계에서는 OrderRepository는 Orders라는 명칭으로 바꿔줘야 한다. 그 이유는 도메인에 대해 논의할때 '주문'에 대해 말하는것이지 '주문 리포지토리'에 대해 말하는 것이 아니기 때문이다.

### 컴포넌트 기반 패키지
컴포넌트 기반 패키지는 마틴 파울러가 제시하는 방법으로, 지금까지 방식을 혼합한 것으로 큰 단위의 단일 컴포넌트와 관련된 모든 책임을 하나의 패키지로 묶는데 주안점을 두고 있다.   
이 접근법은 서비스 중심적인 시각으로 소프트웨어 시스템을 바라 보며, 마이크로서비스 아키텍처가 가진 시각과도 동일하다.  
![image](https://gocheat.github.io/assets/images/2021-03-02-clean-arc-package/4.png)
- 여기서 말하는 '컴포넌트'에 대해 마틴파울러는 "컴포넌트는 멋지고 깔끔한 인터페이스로 감싸진 연관된 기능들의 묶음으로, 애플리케이션과 같은 실행 환경 내부에 존재한다."로 정의하고 있다.
- 컴포넌트 기반 패키지 접근법의 주된 이점은 주문과 관련된 무언가를 코딩해야 할 때 오직, OrdersComponent만 둘러보면 된다는 점이다. 이 컴포넌트 내부에서 관심사의 분리는 여전히 유효하며, 컴포넌트 구현과 관련된 세부사항은 사용자가 알 필요가 없다.
- 이는 마이크로 서비스나 서비스 지향 아키텍처를 적용했을 때 얻는 이점과도 유사하다. 따라서 모노리틱 애플리케이션에서 컴포넌트를 잘 정의하면 결합 분리 모드를 통해 마이크로 서비스 아키텍처로 가기 위한 발판으로 삼을 수 있다.

<br>

## 1116 - Spring Security without the WebSecurityConfigurerAdapter
Spring Security 5.7.0-M2 부터는 구성 요소 기반 보안 설정으로 변경된다. 따라서 `WebSecurityConfigurerAdapter` 상속 후, configure 메소드를 오버라이딩 하여 설정하는 방식에서 `SecurityFilterChain`를 빈으로 등록하는 방식을 권장한다.

### HttpSecurity 구성 비교
- WebSecurityConfigurerAdapter의 configure 메소드를 오버라이딩
```java
@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((authz) -> authz
                .anyRequest().authenticated()
            )
            .httpBasic(withDefaults());
    }

}
```

- SecurityFilterChain 빈 등록
```java
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((authz) -> authz
                .anyRequest().authenticated()
            )
            .httpBasic(withDefaults());
        return http.build();
    }

}
```

### LDAP란?
LDAP(Lightweight Directory Access Protocol)란, 네트워크 상에서 조직이나 개인정보 혹은 파일이나 디바이스 정보 등을 찾아보는 것을 가능하게 만든 소프트웨어 프로토콜이다.

### JDBC 인증 설정 비교
- WebSecurityConfigurerAdapter 상속, configure(AuthenticationManagerBuilder auth) 메소드 오버라이딩하여 설정
```java
@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("password")
            .roles("USER")
            .build();
        auth.jdbcAuthentication()
            .withDefaultSchema()
            .dataSource(dataSource())
            .withUser(user);
    }
}
```

- JdbcUserDetailsManager 빈을 등록하는 방식
```java
@Configuration
public class SecurityConfiguration {
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
            .build();
    }

    @Bean
    public UserDetailsManager users(DataSource dataSource) {
        // 이 예에서는 User.withDefaultPasswordEncoder()가독성을 위해 방법을 사용
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("password")
            .roles("USER")
            .build();
        JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
        users.createUser(user);
        return users;
    }
}
```

https://blog.naver.com/PostView.naver?blogId=h850415&logNo=222755455272&parentCategoryNo=&categoryNo=37&viewDate=&isShowPopularPosts=true&from=search
https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter

<br>

## 1117 - 
###